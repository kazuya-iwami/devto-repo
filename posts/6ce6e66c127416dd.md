---
title: 'AWS re:Invent 2025 - Secure Multi-tenant SaaS with AWS Lambda: A Tenant Isolation Deep Dive (CNS381)'
published: true
description: 'In this video, Anton and Bill introduce Lambda''s new Tenant Isolation Mode for building secure multi-tenant SaaS applications. They explain how traditional approachesâ€”either function-per-tenant (high isolation but operationally complex) or custom tenancy frameworks (efficient but requiring manual cleanup)â€”have trade-offs. The new feature automatically creates separate execution environments per tenant within a single function, preventing data leakage across tenants. Demonstrations show how to pass tenant IDs via the X-Amz-Tenant-Id header, integrate with API Gateway for authorization, implement per-tenant observability through CloudWatch Logs with tenant-specific filtering, and use tenant-scoped credentials from STS for fine-grained access control. The solution addresses noisy neighbor problems, simplifies operations, and enables faster innovation while maintaining strong compute isolation without requiring thousands of separate functions.'
tags: ''
cover_image: 'https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/0.jpg'
series: ''
canonical_url: null
id: 3093038
date: '2025-12-08T19:23:53Z'
---

**ðŸ¦„ Making great presentations more accessible.**
This project enhances multilingual accessibility and discoverability while preserving the original content. Detailed transcriptions and keyframes capture the nuances and technical insights that convey the full value of each session.

**Note**: A comprehensive list of re:Invent 2025 transcribed articles is available in this [Spreadsheet](https://docs.google.com/spreadsheets/d/13fihyGeDoSuheATs_lSmcluvnX3tnffdsh16NX0M2iA/edit?usp=sharing)!

# Overview


ðŸ“– **AWS re:Invent 2025 - Secure Multi-tenant SaaS with AWS Lambda: A Tenant Isolation Deep Dive (CNS381)**

> In this video, Anton and Bill introduce Lambda's new Tenant Isolation Mode for building secure multi-tenant SaaS applications. They explain how traditional approachesâ€”either function-per-tenant (high isolation but operationally complex) or custom tenancy frameworks (efficient but requiring manual cleanup)â€”have trade-offs. The new feature automatically creates separate execution environments per tenant within a single function, preventing data leakage across tenants. Demonstrations show how to pass tenant IDs via the X-Amz-Tenant-Id header, integrate with API Gateway for authorization, implement per-tenant observability through CloudWatch Logs with tenant-specific filtering, and use tenant-scoped credentials from STS for fine-grained access control. The solution addresses noisy neighbor problems, simplifies operations, and enables faster innovation while maintaining strong compute isolation without requiring thousands of separate functions.

{% youtube https://www.youtube.com/watch?v=FWxwfcI7FTA %}
; This article is entirely auto-generated while preserving the original presentation content as much as possible. Please note that there may be typos or inaccuracies.

# Main Part
[![Thumbnail 0](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/0.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=0)

### Introduction: Meet Joe and the Challenge of Multi-Tenant Living

 All right, thank you so much for coming. Now I can see that you can hear us. All right, so today's session, we're going to talk about this new thing that we recently launched. But we're not going to be talking about just the feature, we're going to be talking about the overall use case, which is building secure multi-tenant SaaS applications with Lambda, and we'll dive into how you achieve tenant isolation in your SaaS applications. So we'll cover the problem, then we'll cover existing solutions, and then we'll talk about new solutions. I'm Anton, I'm a Principal Solutions Architect for Serverless. This is Bill, pretty much my peer. We're both very excited about Serverless and SaaS. And at this point in time, you're probably wondering who's that third guy, Joe. So, well, meet Joe. He's your average Joe. This is where our story begins.

[![Thumbnail 60](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/60.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=60)

[![Thumbnail 80](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/80.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=80)

[![Thumbnail 90](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/90.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=90)

[![Thumbnail 100](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/100.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=100)

 Now, Joe lives his quiet life in a single family house somewhere in the suburbs. But deep inside his heart, there's this big dream of one day becoming a famous cloud architect. So every night Joe reads books about cloud architecture in his private room,  and builds prototypes on AWS. At some point in time, determined to pursue his dream, he enrolls into a big university in a city.  And moves into his new accommodation. He's very determined to meet his roommates, but Joe quickly discovers that the shared  life is not exactly what he imagined. So he discovers the problem of noisy neighbors, essentially not allowing you to focus on what you're trying to do.

[![Thumbnail 120](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/120.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=120)

[![Thumbnail 130](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/130.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=130)

[![Thumbnail 140](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/140.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=140)

He also learns what it means when one tenant that you live with occasionally leaves that shared environment  a little bit dirty, also something that you're not particularly enjoying. So one day, sitting on a bench, he's thinking, I wish I had some tenant isolation  in place in my shared environment. So this is where Joe discovered the difference between single tenant and multi-tenant environment. I think you understand the analogy we're trying  to say here, private living, shared living.

[![Thumbnail 150](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/150.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=150)

### Single-Tenant vs. Multi-Tenant Models: Understanding the Trade-offs

So in a single tenant environment, also known as dedicated or siloed,  every tenant has their own dedicated resources, compute, storage, et cetera. So this model provides the highest degree of isolation for these resources, but it can also get quite expensive at scale. You need to maintain those resources per tenant. The more tenants you have, the more resources you need to maintain.

[![Thumbnail 180](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/180.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=180)

The multi-tenant model, also known as shared or pooled, on the other hand, helps to overcome these concerns.  In this model, cloud resources can be efficiently shared across multiple tenants. For example, requests coming from different tenants might be served by the same compute unit, the same function, the same container, the same EC2 instance, basically shared compute. So as a result, your costs are lower, your operations are simpler, you don't need to maintain that much infrastructure.

[![Thumbnail 230](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/230.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=230)

That said, this model comes with its own considerations. So now you have multiple tenants reusing resources. You need to maintain some level of isolation between these tenants. Fun problem to tackle. So, you know, Joe graduated, found his first job as a cloud engineer, and, well, guess what? Now  his job is to build multi-tenant cloud applications. And this is where Joe discovers that building multi-tenant applications can actually get quite tricky.

[![Thumbnail 250](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/250.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=250)

### Why Serverless and SaaS Are a Natural Fit

Right on, thanks, Anton. So we like Joe. Joe's a good guy. We're going to go to school with Joe. We're going to learn a little bit about his experiences building SaaS, what he learned about multi-tenancy.  And it started off, he joined a company, he learned a little bit about what they wanted to do. They had business requirements that they wanted him to fulfill. He couldn't just jump into the tech and learn about the tech, but he still had technical requirements he had to fulfill as well.

[![Thumbnail 270](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/270.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=270)

Now, for the purpose of talking about Lambda, talking about Serverless, there's a couple of primary challenges from a  business perspective, what we wanted to achieve, and from a technical perspective of how we achieved them that I want to focus on. So in terms of Joe's journey, his company wanted to innovate fast. They wanted to introduce new features to their customers rapidly, keep ahead of the competition, do a good job of continually keeping their application fresh and their customers happy.

Now to do so, they wanted to have a shared environment, they wanted everything to be completely isolated. They had customers who demanded that everything be perfect in terms of isolation, and they couldn't deal with noisy neighbor problems.

[![Thumbnail 320](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/320.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=320)

And we all know what noisy neighbors means. If one tenant or one of our customers is doing too much activity, that shouldn't affect any of our other customers. So these are some of the primary challenges that Joe was faced with. And he's a serverless guy. He loves serverless,  and I'm not going to read all of these to you, but of course serverless and SaaS are a natural fit. And these are some of the reasons up here, but just in general, if we were to summarize this, the operational efficiency and also the cost efficiency that you get from serverless are a really great fit.

[![Thumbnail 360](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/360.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=360)

Now, if you think about what serverless even is, it's a lot like SaaS. It was born in the cloud. There's no on-premises version of serverless out there. Now you can take a Lambda and you can emulate it, and you can do different environments, but this is born in the cloud technology. It's great, he loves it, and he's embraced all of these principles. And I said that serverless and SaaS are a great  fit and that cost could be one of the reasons. Well, take a look at this and think a little bit about the serverful environments that you've worked in.

[![Thumbnail 400](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/400.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=400)

When you're building serverful environments, you might have the ability to scale. Of course, you can scale up and scale down as you need to. You can do this in containers, you can do this with even just core instances. But as you do so, you're reactively scaling up to your peak requirements. We have this much potential load during this time. I'm going to set up as many servers or as many containers as I need to handle all that traffic. And of course, you are paying for those spikes, right? You're paying for that infrastructure  that's sitting there while it's idle.

[![Thumbnail 430](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/430.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=430)

[![Thumbnail 440](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/440.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=440)

So I have customers who spin up all of the infrastructure they need and they keep it on all the time. Maybe they're not even as efficient as this chart. On the other hand, serverless scales with your costs and utilization pretty evenly. As your usage goes up, as the number of instances you have go up, you don't even have to handle it. And of course the cost of what you're paying for in terms of those is almost in lockstep with the utilization. So serverless allows you to have the best  ratio of cost to usage, and that's a great fit for SaaS, especially SaaS where we see spiky workloads. 

[![Thumbnail 450](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/450.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=450)

[![Thumbnail 460](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/460.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=460)

### How Lambda Concurrency Works: Function Invocations and Execution Environments

How does Lambda even do this? How does it do these executions so that we have this nice even chart of where the cost and utilization are in lockstep? Let's think a little bit  about what Lambda concurrency is. So we're just going to show some invocations, and we call these function invocations. As requests come in, we handle them.  And if one request comes in, you'll see it here, we have it in purple, and that means that the environment that we're in, this is an environment on this line, is now active and it's serving up a customer request. And we have gray in there, and that's going to be idle. So keep that in mind as we're looking at this chart.

[![Thumbnail 480](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/480.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=480)

[![Thumbnail 490](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/490.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=490)

This is a pretty simple chart, we can go through it pretty  quick. One request comes in, we handle it in one environment. Another request comes in, what are we going to do? Well, we're going to handle it in that same environment. It's idle right now, so we can go right into that same environment. As we keep going,  maybe we get another request, but now it comes in at the same time as that second request. What are we going to do? Of course we can spin up another environment.

[![Thumbnail 530](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/530.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=530)

Now, are we spinning up another environment? Not exactly. Lambda and the execution engine behind it is doing it on our behalf. I didn't make an active choice and say, hey, you go spin up another environment for me. No, that all just happened magically in the background. And for most of us now, that seems like a given, right? We can accept that this happens. This was pretty magical when it came out, and it's still very cool in terms of how we think about all of these executions and the scale that we can run into in SaaS. 

[![Thumbnail 540](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/540.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=540)

[![Thumbnail 550](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/550.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=550)

Let's keep going. So now another invocation comes in this time. Our first environment is now free, so we just execute that in our first environment. Another invocation comes in,  and two at the same time. Well, we have two free environments, of course we can handle those both in those environments. Keep going. What happens if there are three executions? Of course, another environment is spun up. 

Now this seems somewhat obvious, like okay, this is fine. Bill, why are you telling me this? Well, a couple of things. One, look at those idle bars. We aren't paying for that consumption, for those execution environments, even though they're available to us to put additional invocations into. And then two, we didn't have to do anything here. This all happened automatically for us, and the automagical part of that is relevant to the conversation for SaaS because not only were we lucky enough to have this happen on our behalf, we didn't control what the specific executions went to, and in a multi-tenant environment, that's important.

[![Thumbnail 600](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/600.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=600)

### Under the Hood: Lambda's Infrastructure and Multi-Tenant Challenges

Now the biggest secret of serverless, I don't think I'm letting any cats out of the bag here, is actually that there are in fact fleets of servers underneath the hood. If you didn't know this, I'm sorry to disappoint  you. It's not in fact serverless. There are EC2s that live in, thousands of EC2s, right? We have whole fleets of EC2s that support our Lambda fleet, and that's good.

The fact that we don't have to know that, that you could go your whole life without understanding that Lambda actually used EC2s, and that could be a secret to you, is actually a benefit to us, and this is what we wanted to create. But let's dig under the hood, let's remove the veil of ignorance for now and say, oh now we actually want to understand what's happening here, because again from an isolation perspective, this is particularly important.

[![Thumbnail 630](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/630.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=630)

[![Thumbnail 670](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/670.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=670)

[![Thumbnail 680](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/680.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=680)

 Look inside one of these individual EC2s. It's just a bare metal EC2. Within the EC2, of course, we have the host OS which provides a certain level of isolation here. We've got the kernel on top of it, but importantly, we use the Firecracker microVMs on top of them, and the Firecracker microVMs have strong isolation around each of them. Nothing is being shared across these Firecracker microVMs, and that means we've already got a layer of isolation that's important for handling any sort of invocations, multi-tenant or not. Within this, within the microVM, we'll have a guest kernel. If you're using our runtimes, our managed runtime, you'll  have our runtime on there as well, and Lambda extensions, if you're using them, also really cool if you haven't. And on top of that, your function code lives. So  all of these different layers provide multiple layers of isolation, almost like a Russian nesting doll, right? You can actually look all the way through this stack and say, hey, look, this is protected from this, this is protected from this. We've created really strong isolation that again is important to SaaS providers and any providers really, but especially in a multi-tenant solution.

[![Thumbnail 700](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/700.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=700)

[![Thumbnail 720](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/720.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=720)

[![Thumbnail 730](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/730.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=730)

 Let's look at these boundaries a little bit closer. So across functions, we're never sharing the same execution environment across functions, right? So never ever are we going to say, hey, the same shared execution environment is shared across multiple Lambdas. And even in the same function, right, where there's full isolation, and that click will show you, right, so we've got a complete grid,  they're never sharing the same execution environment. And even within the same function, we're never sharing CPU, disk, or memory. So  this gives you a slightly different visualization on this, and a different way to think about the problem space that we're in, and the challenges that Joe might be facing as he's learning about how to be a great Lambda developer and an architect.

Across our different functions, nothing is shared, period. End of story. We're not sharing CPU, we're not sharing disk, we're not sharing memory. There's nothing shared across those. Go back to that Firecracker visual that we had. All of those layers, all of those different layers of isolation around that apply here. Now, what about the same function? The execution environments that belong to the same function. And think about again that chart we had with the different execution environments, right, and how the different invocations were coming along in there. We actually have a few things that are potentially shared, and this is one of the problem spaces we're dealing with. Environment variables, IAM execution roles and permissions, and code can actually be shared across the environment.

[![Thumbnail 800](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/800.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=800)

[![Thumbnail 840](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/840.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=840)

So let's go back to that same chart. We've got the same nine executions we talked about, all of them in that same purple active role that we looked at.  But in a multi-tenant environment, there's a lot more color in our universe. For SaaS providers, we have to deal with the fact that multiple customers are coming in, and at any given time, an invocation in a shared environment, I couldn't tell you until runtime who that's coming from. And this is important. That first environment there has handled executions from our blue, green, and yellow tenant. And across our different environments over time, this will be true. All of our tenants will land randomly on different environments, and we don't control that. We don't pick which environment any one of these individual invocations is going to land in. And this is sort of the crux of the problem, right?  And it's not really a problem, but it is something we need to handle, to be fair.

[![Thumbnail 860](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/860.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=860)

[![Thumbnail 870](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/870.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=870)

### Demonstrating the Problem: Memory and Disk Leftovers Across Tenants

So let's get into a demo that sort of demonstrates the principles that we're talking about, because it's one thing to say, hey, these things could potentially be shared. Let's actually look at what this means. We've got a simple memory counter. Within there, we also have a disk counter, and I'll talk about what those mean.  All they're really doing, as it's saying, is writing something to memory or writing something to disk. Now we've got this overarching counter here, pretty basic, right?  Our memory counter, we're simply printing, it's a memory counter, we're printing it, incrementing it, and then storing it back to memory. And the same with the disk, right? Read, print, increment, store, and then we return the value that has those different values in it.

[![Thumbnail 890](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/890.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=890)

Let's look at Joe. He's learning how to do this, and of course, he goes into his Lambda runtime environment  and creates a little test that proves, in fact, that the way this works is exactly what he was thinking. So he invokes this very simple test event that he has, and we can see some of the outputs, right?

[![Thumbnail 920](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/920.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=920)

The logs show the memory counter, the disk counter, and a tenant ID which suspiciously is undefined. Perhaps later on we'll discover what happens with this tenant ID as we start to think about the real implications. Every time this is invoked, the disk and the memory counter increment, and they just continue to increment regardless  of which of our tenants are calling. Joe's not even paying attention. Everything's fine, this is great. He can see that this works exactly the way he designed it.

[![Thumbnail 950](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/950.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=950)

So let's define the concerns that Joe should be thinking about and what brought him here to re:Invent 2025 this year to learn about what we've launched. Each of these tenants as they come in are invoking the Lambda function that Joe created. Now each of these invocations, as they happen, write some things to disk, they write some things to memory, and Joe is happily running this  function. He thinks he's done a great job, and of course he's a hard worker. We really like Joe, we want him to succeed.

[![Thumbnail 980](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/980.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=980)

[![Thumbnail 990](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/990.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=990)

But unfortunately, Joe hasn't sealed all of the code properly as he should, and there are best practices you could do, even now, to prevent this from happening. Unfortunately, Joe wasn't aware of them. So there are some leftovers from that blue tenant's invocation, and those stay in the execution environment. And if you remember the execution environment and we added the colors, a lot of different tenants were coming into each of those execution environments.  The yellow tenant comes in, same problem. Now we've got some more leftovers. Maybe they can see the leftovers from the blue tenant. Maybe our green tenant, as they come in, can  now see leftover data from our blue and our yellow tenant.

[![Thumbnail 1010](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1010.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1010)

Now, is this data important? Well, it could be. It could be tenant-specific data, it could reveal information about our other tenants, or even the existence of other tenants and who they are, all of which can be dangerous to the business that we're in. So just,  I mean, it sounds kind of crazy, right? Is Lambda, does it have this problem? Is it a problem? No, it's not actually. It's a common concern across all architectures, and I think most of you probably realize this. If you step back from this being a Lambda, if you're running containers and you write things to disk, and you're running multiple containers, you have to be careful or the other containers will start picking up that same data.

And the same with EC2, right? I mean there may be levels of isolation around them. You have to manage those, and that's true of almost every compute environment we've come across so far. So I said, Joe actually came here to re:Invent 2025. We get to learn along with Joe. Joe can come back to being our hero. I'm going to hand it back to Anton, and he's going to tell us how we turned Joe back into the hero of our story.

[![Thumbnail 1060](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1060.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1060)

### Existing Solutions: Function-Per-Tenant and Custom Tenancy Frameworks

Thank you, Bill. All right, so  as Bill mentioned, it's an inherent concern regardless of what compute you use, right? If you're sharing compute units across multiple tenants, you need to make sure that you're not leaving some leftovers. Doable, totally doable. Who's responsible? You. Let's see how we address that. Lambda is actually quite unique in this regard because Lambda execution environments are short-lived. They do not exist for days or weeks. We recycle them all the time.

[![Thumbnail 1110](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1110.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1110)

So even if you have some leftovers, it's not a good thing. Don't misunderstand me, it's a bad thing, but it's going to be recycled after some number of minutes. So Lambda actually makes it a little bit less critical while still very important. Again, do not misinterpret that. So let's see what are the existing solutions to this problem, and  yes, existing means there is also a new one. I think you're here for the new one, we're getting there.

Now, before I dive into technical parts, it's important. I work with customers, I'm a Solutions Architect. There are customers who are saying, ah, not a big deal. All of our data for all our tenants is public anyways, so why do we need to worry about that? I'm not buying that, because even if today you don't have a use case for handling that, tomorrow there will be a reason to handle that, and you're kind of going to forget about it. So I highly recommend you do not ignore the problem in multi-tenant environments.

[![Thumbnail 1180](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1180.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1180)

Another thing I'm hearing is, you're going to like it, we have a wiki page and we've documented all the best practices for handling tenant information. Anyone familiar with that? Good intentions are amazing, but not enough. You do not want to solve that problem by providing guidance. You want to have something much more tangible, something that actually works for you more than guidance that Joe probably missed because there is so much onboarding material. So let's talk about solutions.  Now, the first solution, it's kind of obvious. This is going back to single tenant approach. There are some organizations, and usually those are the largest organizations with highest security demands. They adopt function per tenant model. Anyone here using that or heard about that? Yeah, I see a few hands. Essentially, each function is single tenant.

[![Thumbnail 1210](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1210.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1210)

[![Thumbnail 1230](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1230.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1230)

One function only handles  invocations coming from one tenant. This is the highest degree of isolation. It's as isolated as it gets. But the problem is, it comes at a cost. If you have five tenants, it's not a big deal. But what if you have 500, 5,000, or 50,000 tenants? So the benefits of this approach are obviously  strong isolation. Since you have one function per tenant, cost attribution is a little bit easier. You can configure things per tenant for observability. But there are also considerations. Things like operational sprawl. Yes, those are serverless functions, and there is no infrastructure to maintain. But 50,000 is 50,000. It's a huge number. Good luck managing your CDK, Terraform, and so on, and that's just one function with 50,000 tenants.

So it gets harder to maintain at scale. Your CI/CD becomes more complex. You might hit management API limits when you need to update 30,000 functions. Tenant onboarding is slower because you need to provision dedicated resources per tenant. There's duplication, version drift, and the need for a custom routing layer. There are some considerations if you're using this model. That's why we recommend it only if you absolutely have to have that level of isolation. It's not a common model, but yes, it's definitely used by the industry.

[![Thumbnail 1300](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1300.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1300)

A more common model is you do have a multi-tenant function  with multiple tenants using that function, but within that function you have some sort of a framework or SDK or a layer. There are different ways to name it. Essentially, it's a piece of code that your organization wrote that handles that isolation. Essentially, it's decoupled from the business logic, and it handles things like, for example, validating incoming tenants, scoping down credentials, logging on a tenant level, and so on. So it's a piece of code that's implemented by your development organizations that essentially addresses that problem.

[![Thumbnail 1350](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1350.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1350)

This is a very common approach. We do see it quite a lot. One of the companies that I work with, and they're using this approach heavily, is CyberArk.  They're using Lambda. They're a serverless-first identity provider, and they're using Lambda in their multi-tenant SaaS platform. To minimize infrastructure management, enabling clean compute isolation, they've built their custom tenancy framework, which is amazing. You can find it on the internet. Oh, by the way, I forgot to mention the very last slide will have a giant QR code with all the resources you've seen today, including these slides. You'll have these slides in 37 minutes.

[![Thumbnail 1390](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1390.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1390)

So customers are using that approach. It's pretty popular, pretty robust. It has a lot of benefits like higher resource reuse, lower unit costs, because you don't need to manage thousands or tens of thousands of functions.  Tenant onboarding is much faster. You don't need to create dedicated resources. It's just a record in the database. Operations are simpler, rapid feature rollout, and so on. But, you know, we're architects. There's always "it depends" and trade-offs. There are also considerations. What if I have noisy neighbors? If I'm using shared compute, I might have noisy neighbors. I might require additional compute-level isolation.

So I provided isolation in my custom tenancy framework, but what if I want a higher degree of isolation than that? But I still prefer not to create a function per tenant because that's hard to maintain. How do I clean up the leftovers? Who's responsible for that? What about per-tenant observability? If one function is reused by 10,000 tenants, how do I observe per tenant? And so on.

[![Thumbnail 1450](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1450.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1450)

[![Thumbnail 1470](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1470.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1470)

### Introducing Lambda Tenant Isolation Mode: A New Approach to Compute Isolation

So during the lunchtime, remember Joe? He's thinking,  it would be great to have maybe a vendor-provided solution for tenant compute isolation. So when he got back from lunch late last week, he was extremely excited to learn that Lambda just announced the new Tenant Isolation Mode. Now, to explain what Tenant Isolation Mode is, I'm  going to be talking about it for 30 minutes, but I'll explain it in one slide because it's a picture that's worth a thousand words.

[![Thumbnail 1500](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1500.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1500)

You've seen this. Tenants accessing functions. With the new Tenant Isolation Mode, you pass us some sort of tenant ID, something we don't care what that is. I'll talk about this in the following slides, but you need to tell us some unique tenant identifier. What's going to happen under the hood is Lambda's function, a single  function, will create separate execution environments for each tenant.

[![Thumbnail 1520](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1520.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1520)

[![Thumbnail 1530](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1530.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1530)

[![Thumbnail 1540](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1540.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1540)

[![Thumbnail 1550](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1550.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1550)

[![Thumbnail 1560](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1560.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1560)

[![Thumbnail 1570](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1570.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1570)

The execution environments are never reused across different tenants. Let's see an example of that. A demo is the best way to show it. So if you've used Lambda in the last five days,  you've probably noticed this. There is a new property, if you enable tenant isolation, called Tenant ID. So remember the demo? Let's evolve  it. I'm going to specify my Tenant ID. Let's say BlueTenant. And let's invoke the function. So you're seeing that first of all Tenant ID is  now not undefined, and you can see that the counters are incrementing because BlueTenant is hitting execution environments owned by the  BlueTenant. Let's get it to 5. Keep in mind that number, 5, it's important. Look up, we're going to switch tenant to GreenTenant, and we're going to invoke exactly the same function,  no redeploys. You see the counters going from start. Counters are starting from zero because now the execution  environments that belong to the GreenTenant are not overlapping with BlueTenant. The execution environment for BlueTenant is still up there. It's just requests are no longer going to it because we changed Tenant ID to GreenTenant.

[![Thumbnail 1590](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1590.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1590)

[![Thumbnail 1600](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1600.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1600)

[![Thumbnail 1610](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1610.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1610)

[![Thumbnail 1620](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1620.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1620)

So let's get that counter to let's say 9-ish, 9 or 10. Let's switch back, look up, we're changing GreenTenant  back to BlueTenant. Remember 5, let's invoke that function, 6, 7, and so on.  Every tenant, we identify them by Tenant IDs that you provide us, has different execution environments. Let's change that to OrangeTenant, something we haven't seen before.  You invoke it and it starts from the 0 because this is a new tenant. Now those counters are just a simple example, but imagine you load some tenant-specific configurations,  some tenant-specific data, database connection strings. You cache some tenant-specific information.

[![Thumbnail 1660](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1660.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1660)

Previously, if it's a multi-tenant function, it was up to you to clean those leftovers up between requests. Now, well, you know, doable, totally doable. It's not like it's a new thing. It's been in shared compute for years. And now, you know, we kind of isolate those compute environments for you. So the data is never shared across different tenants. All right, let's see how this actually works. 

So, first of all, how do you create a function with tenant isolation mode? It's a new property. It's already supported with CDK and Terraform and a few other infrastructure as code tools. Literally when you create a function, you specify a new property called tenancy config, tenant isolation mode per tenant. So we're isolating compute per tenant. This is only available when you create a new function. It's not something you can change for existing functions because this is security. We don't want to play that game where you're changing this configuration and something unexpected might happen. Security is not a joke.

[![Thumbnail 1700](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1700.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1700)

Next, when you invoke these  functions, you need to supply a Tenant ID. Once again, parameter. You only need it when you enable the tenant isolation mode on a particular function. If you're not going to supply the Tenant ID, there's no default. You're going to receive an error saying missing parameter. It's a required mandatory parameter that you need to supply. That's pretty much it. There's nothing else. That's it. That's how you create it. This is how you use it. This could have been a very short session. We try to make it very, very simple for you, but let's get into more advanced topics.

[![Thumbnail 1760](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1760.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1760)

Probably you're asking, hmm, great, Tenant ID, we're passing that Tenant ID into the function. Any chance I have access to that Tenant ID from within my code because you probably want to do some tenant-specific logic? Well, the answer is yes. We're propagating that Tenant ID into your function handler, so the context object will have a new property called surprise, Tenant ID, and this is exactly the Tenant ID that  you gave us. So within your code, you can actually easily access that information and if you need to do some branching logic based on the Tenant ID.

[![Thumbnail 1780](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1780.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1780)

[![Thumbnail 1790](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1790.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1790)

[![Thumbnail 1800](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1800.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1800)

Now, let's talk a little bit about how you use it. So, first of all, there is no need to pre-register tenants. We're not asking you to give us the list of  tenants, you know, no need to pre-register whatsoever. Second, unlimited number of tenants. We're not limited, there's no quota for like 10,000 tenants.  As many tenants as you want. There are considerations, we'll talk about that, but essentially unlimited number of tenants. 

[![Thumbnail 1820](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1820.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1820)

The tenant ID can be any arbitrary alphanumeric string up to 128 characters. You can have it as a GUID, you can have it as some unique identifier you already have in your system. We don't care as long as it's an arbitrary alphanumeric string up to 128 characters. The last one is that this is obviously supported for both  ZIP and container images. We want everyone to enjoy this new capability.

[![Thumbnail 1840](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1840.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1840)

Sounds great so far, but obviously there are considerations. It's always about knowing the considerations for each capability. So first of all, since we're creating tenant separate execution environments  per tenant, your cold starts are also per tenant now. You want to have compute isolation, so your cold starts are starting to be per tenant as well because tenants are no longer sharing execution environments. That's something important to note. Tenants with a lot of invocations will probably not even notice that. Tenants that invoke like three times a day, probably every single invocation is going to be a cold start. So this is important to remember.

[![Thumbnail 1870](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1870.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1870)

[![Thumbnail 1900](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1900.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1900)

[![Thumbnail 1920](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1920.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1920)

 Concurrency quotas apply. Keep in mind, now we're creating more execution environments. If previously you were handling maybe ten tenants with one execution environment, now ten tenants means at least ten execution environments. So your concurrency quotas are still applicable. Your concurrency quota per account, burst, et cetera, et cetera. We documented it really well in our docs. Provision Concurrency is not supported  for obvious reasons. Provision Concurrency means we're pre-warming a pool of execution environments, but we cannot pre-warm that if we don't know who the tenants are. So at this point we'll see what happens in the future, but at this point Provision Concurrency is not available for this feature. And it's supported for  direct invocations or API Gateway integrations only at this point. So if you have your own control plane and you're invoking Lambdas, you can do it easily, or if you use API Gateway, we'll show how it works with API Gateway in a few slides.

[![Thumbnail 1940](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1940.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1940)

[![Thumbnail 1950](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1950.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1950)

[![Thumbnail 1970](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1970.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1970)

### Achieving Tenant-Level Observability with Logs and Metrics

So the next big question is, what about observability?  We have compute isolation. How do we achieve tenant level observability? Well, first of all, if you're not yet using JSON  formatted logging, please do. We highly recommend you use JSON formatted logging. It makes everyone's life easier. Those are the logs you can query and receive information based on your queries. When you enable JSON-based logging, we will automatically inject tenant ID into your logs, as you can see here on the screen. You no longer need to have specialized  log lines in your code to manually print tenant ID. Now we inject it automatically into your logs.

[![Thumbnail 1980](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/1980.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=1980)

[![Thumbnail 2000](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2000.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2000)

[![Thumbnail 2010](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2010.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2010)

[![Thumbnail 2030](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2030.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2030)

But how do you actually  process those logs? How do you actually make use of them? So you probably know that Lambda can automatically send logs to either CloudWatch, S3, or Firehose. By default, it's CloudWatch. It's probably one of the most common ones, so we'll be talking about CloudWatch today. So by default, each function gets its own log group. This  is how it worked for years. This is not new. Each function will get a dedicated log group. Now within that log group, you will  see a collection of log streams. Again, nothing new. Each execution environment is getting its own log stream. This is how it worked for years. Nothing new so far. What's new is now these log streams are tenant specific,  because you have tenant specific execution environments, those log streams are also tenant specific. To summarize, each tenant will have multiple log streams. Each log stream belongs to a single tenant only. Make sense?

[![Thumbnail 2050](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2050.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2050)

[![Thumbnail 2070](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2070.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2070)

Let's dive deeper.  So, a little something you probably already know, but these names are not completely random. They actually have a meaning. So they start with date, then you have the function name, then you have function version, and then you have that random execution environment ID. So if you know the structure you can make your querying a little  bit more powerful. For example, let's start with a development scenario. I want to observe my logs tenant specific in real time. So you can use Live Tail. It's a feature of CloudWatch, or you have it embedded in Lambda console as well. So you can select log groups. Remember, log group equals function, so you can select multiple log groups, which means multiple functions. You can select log streams, meaning you can select streams that belong to a particular tenant. And you can also specify,

[![Thumbnail 2120](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2120.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2120)

for example, tenant ID as a filter pattern. So we know it's a blue tenant. As a result, this is what you're getting. You're getting logs live because we're using  logs tail here, and you're only getting logs for a particular tenant ID. If you're not using this filtering, once again, you're going to get all the logs. But if you do want tenant-specific observability for a specific tenant, you can easily achieve that with this filtering. Just specify the tenant ID and we're going to filter it for you.

[![Thumbnail 2160](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2160.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2160)

[![Thumbnail 2180](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2180.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2180)

But this is live logs. What if you have like three weeks or three months' worth of logs and you want to get logs for a particular tenant? Well, you can use CloudWatch Logs Insights for that. Once again, it's all query-based logging. So here I have an example  of a Logs Insights query that will get me a list of log streams for a particular tenant. So I'm thinking in my head, all right, I got my blue tenant. I want to see what are all the log streams that belong to this particular tenant. So running this query, for example, will yield me something like this.  You can see I got three log streams that belong to that particular tenant. You can limit it by time, by number, you know, standard querying. And I can see the log count here as well. So I can see what are the log streams that belong to a particular tenant.

[![Thumbnail 2200](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2200.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2200)

[![Thumbnail 2230](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2230.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2230)

I can make it also simpler. What if I don't care about looking at which are the  log streams? I just want to see logs for a specific tenant. I don't care how they are spread across different log streams because obviously each tenant will have multiple execution environments. Every single one of them is tenant-specific, but multiple. So I can run a query, just get me all the messages for BlueTenant, and I want to limit that by 1000. Here, the query will return you tenant-specific logs  that are stored in CloudWatch log groups and log streams. Now if you're using a third-party observability provider, they will have something similar very commonly, you know, some sort of filtering capability, because once again with structured logs, tenant ID is just one of the properties of the JSON object. It's super easy to query on.

[![Thumbnail 2260](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2260.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2260)

[![Thumbnail 2280](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2280.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2280)

[![Thumbnail 2300](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2300.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2300)

But what about beyond logs? What else can you do which is a little bit more sophisticated and advanced?  Well, how about sending tenant-specific custom business metrics? So, who's here using Powertools for AWS Lambda? Quite a lot of people familiar with that. So here I got an interesting example. Powertools is an open source library  that you can use for Lambda that we support for a multitude of languages and runtimes. Here I got a Node.js example. So I'm creating a new metrics object because I want to start emitting tenant-specific metrics, not logs, metrics. Inside of my handler, I'm adding a tenant dimension to my metrics.  So from this point on, every metric I emit from my function will be tenant-specific. I can still emit general metrics which are not tenant-specific, but now I can also emit tenant-specific metrics, which is extremely powerful. So, you know, I can add successful bookings at the bottom and publish those metrics, and now I'm getting that information per tenant. So per-tenant observability story is also quite strong.

[![Thumbnail 2330](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2330.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2330)

[![Thumbnail 2340](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2340.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2340)

[![Thumbnail 2360](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2360.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2360)

### Integrating with API Gateway: Mapping Tenant IDs and Managing Noisy Neighbors

 Let's talk a little bit about integrating with API Gateway, because this is a very common scenario  where your tenants are coming through an API which leads to Lambda. So, you know, you already know that when the tenant isolation mode is enabled, Lambda expects that tenant ID parameter to be sent for each invocation. But how does it actually work on a wire protocol level? Let's get into the nitty-gritty details. Well, from the protocol  perspective, the way the tenant ID is propagated down to Lambda is by using an HTTP header called X-Amz-Tenant-Id. And the value of that header is that BlueTenant, GreenTenant, or whatever you specify.

[![Thumbnail 2390](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2390.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2390)

[![Thumbnail 2400](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2400.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2400)

But the big question is, where's that value coming from in the original request? You know what Lambda expects, but you might have different use cases. For example, what if you're using  HTTP headers to pass tenant ID, or query parameters, or path parameters? You can do all of these. What if you want to use domain prefix?  The way you identify your tenants is you're creating a domain, a subdomain for each tenant. You want to use that as tenant ID? Doable.

[![Thumbnail 2410](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2410.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2410)

What about information coming from Lambda authorizer?  What about information in JWT claims or account or anything else? All of this is doable, and let's see how you do that.

[![Thumbnail 2420](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2420.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2420)

So first, let's define terminology.  This is API Gateway terminology that we will use for the next five minutes or so. It's important to understand it. The inbound request into API Gateway, we call it method request because it hits a particular HTTP method like GET or POST or whatever. So the inbound is method request, the outbound from API Gateway down to Lambda, that's called integration request because this is the downstream backend integration.

[![Thumbnail 2450](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2450.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2450)

Easy. What I want to do is I want to take,  for example, arbitrary example. I want to take some custom header from the method request, and I'm using x-tenant-id, arbitrary name. You can name it whatever you want. I'm just using that as an example. I want to take the value of that inbound x-tenant-id and I want to use it as the value of that X-Amz-Tenant-Id header that goes to the Lambda. So this is something I want to achieve. How do I do it?

I'll be using CDK as an example. Obviously you can do it with any other infrastructure as code or click through in the console. So first of all, when you create a resource and creating a method, a GET method on that resource, you can specify, and this is why we had to do the terminology first, method.request.header.x-tenant-id true. So this configuration basically tells API Gateway that I expect this x-tenant-id header and it's required. True means required because you don't want to process requests without tenant ID.

[![Thumbnail 2510](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2510.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2510)

The second thing is  when you're configuring your integration. Once again, this is the reason we had to do terminology piece first. You're saying that I want to map integration request header X-Amz-Tenant-Id to the value of method request header x-tenant-id. Essentially you're saying that's the header that I want to go to Lambda, to my downstream integration, and this is the source of the value that I want you to use. And this is just as an example of how you can map any custom HTTP header to be your tenant identifier.

[![Thumbnail 2550](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2550.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2550)

Now this is just one of the examples.  This value, like I said, it could come from a lot of different sources. Any request header, any request query parameter, path parameter, request body, principal ID of your authorizer, or any custom property you return from the authorizer, you can use domain prefix for that. Essentially, anything you have access to in API Gateway, you can use it as a value for tenant ID. We published a sample, you'll see the link at the very end. We published a sample code illustrating how to achieve that through an authorizer. JWT tokens and authorizer, how do you do that? It's pretty simple, it's a couple of lines of code.

[![Thumbnail 2590](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2590.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2590)

Since we're already talking about API Gateway, let's address  the noisy neighbor problem. That's kind of one of the things that we've discussed previously. So API Gateway provides a capability to create usage plans. For example, this is a common approach. You have different tiers like silver, gold, bronze tiers, and you can define request rates for each one of those tiers. For example, 10 requests per second, 30, 20, etc.

Now, once you map those tiers to your tenants, this gives you protection for noisy neighbors. So with API Gateway, you implement noisy neighbor protection even before these requests hit Lambda. So you don't need to do it in any way in your code, you just do it at the API level and the service takes care of that for you. And once again, you can use the same tenant ID that you've used before, that is incoming from your client request. You can use the same tenant ID to identify which plan that tenant is associated with. So API Gateway helps you here as well.

[![Thumbnail 2660](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2660.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2660)

[![Thumbnail 2680](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2680.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2680)

### Fine-Grained Access Control: Tenant-Scoped Credentials for Storage Resources

Let's move on. Quick question, what's missing on this picture, if we're talking about a real application?  Storage, you know, dependency. Your architecture doesn't end with Lambda. Your Lambda doesn't live in a vacuum. It does something. It needs to access some downstream like databases, S3. It needs to talk to something. So obviously, you know, there  are some dependencies that your Lambda needs to access. It can be what I have here, S3 bucket, DynamoDB, SQS, and many, many more.

How do you do it traditionally? Well, you use the SDK and how do you manage IAM? You have the function execution role. And this is important. This one is very important security wise. Function execution role is function execution role. It's not a tenant execution role. So it's applicable at the function level.

Whatever the function execution role allows to do, every single tenant will be able to do that. It's a function level construct, very similar to what Bill showed before. For example, environment variables are also function level constructs, not tenant level constructs. But the big question is, can we do it a little bit more fine-grained? Well, let's see how you can do it.

[![Thumbnail 2740](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2740.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2740)

[![Thumbnail 2750](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2750.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2750)

[![Thumbnail 2760](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2760.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2760)

[![Thumbnail 2770](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2770.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2770)

[![Thumbnail 2800](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2800.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2800)

So let's say a typical scenario of clients  using JWT, a very common scenario for authorization. Now the token, since we're using API Gateway, is propagated all the way to Lambda Authorizer,  right? And inside of that Authorizer you can do a few pretty cool things. Well, first of all, obviously you validate the token. That's the reason you got the Authorizer there. So you want to extract information from that  token. You can validate it against Cognito or whatever identity provider you're using. So first thing you do, obviously you validate that token, maybe extract some identity.  Second, optionally, you might have some custom logic there, custom policies you want to apply. So not only is this token valid, but what are the permissions, custom permissions on that token? Maybe you store them in DynamoDB, maybe you have some external system. You validate additional permissions for that specific token. But the next thing is actually pretty cool. You can retrieve tenant-scoped, short-lived credentials from STS. 

[![Thumbnail 2820](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2820.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2820)

[![Thumbnail 2860](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2860.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2860)

So at this point, by the time you're getting to the third bullet here, you've validated that tenant. You know that this tenant is actually who they claim to be, and their policies allow them to do what they're asking to do. So what you can do here is let's get tenant-scoped credentials, not the function execution role, something that is specific to this tenant, and then you  propagate that information from API Gateway down to Lambda. So what it actually means is now your Lambda function has two sets of credentials. The function execution role allows your function to perform actions which are not tenant-specific. It's pretty common for every single tenant to be able to access some shared storage where they have information that everyone needs to access. But the tenant-scoped credential actually restricts your function to be able to access the data that only this particular tenant can access. Let's take a look at the example of this. 

So let's see how this works. We're getting a request from BlueTenant. That tenant is hitting API Gateway. API Gateway forwards the request to Lambda. Obviously, BlueTenant execution environment is being used. So at this point in time, that BlueTenant execution environment can access the shared bucket. You have some shared bucket there. It uses the function execution role to access that shared bucket. But in addition, it can access the Blue bucket. Why? Well, because you have tenant-scoped credentials that allow it to access the Blue bucket. What it cannot do is access the Green bucket or Yellow bucket, because there are no permissions available to that function at this current request that allow it to access these two buckets that belong to two different tenants.

[![Thumbnail 2910](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2910.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2910)

[![Thumbnail 2940](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2940.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2940)

And whenever the next request is coming in from YellowTenant,  for example, it's served by the Yellow execution environment. The Yellow execution environment can access the shared bucket. Everyone can access the shared bucket. It cannot access Blue, it cannot access Green, but it can access the Yellow bucket because you have the function level credentials and then you have tenant-scoped credentials. All right, time to start wrapping up. We've got about 10 minutes left. So obviously, we need to show an end-to-end demo  to actually prove to you that this works, and you have this whole thing available on GitLab. You'll see it in a moment.

[![Thumbnail 2960](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2960.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2960)

[![Thumbnail 2970](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/2970.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=2970)

[![Thumbnail 3000](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/3000.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=3000)

### End-to-End Demo and Conclusion: Joe's Success with Tenant Isolation Mode

So before I show you the demo, I want to explain to you what's going to happen because the demo is going to be like me sending three requests through Postman. It's not that impressive if you do not understand what's happening under the hood. First of all, I'll have two tenants, and I will pass my tenant  ID as a JWT claim. I have an Authorizer function that receives that  JWT and validates it. Those are like real, fine JWTs. It validates it and it returns context with tenant ID. I'm not using usage identifier key here. It's optional. I'm not using it for the sake of this demo, but you can, essentially, if you want to introduce usage plans as well. So the context returned from the Authorizer response contains tenant ID. What do I do next? When I'm defining my Lambda integration,  I'm saying that integration.request.header.x-amz-tenant-id and the value is coming from context authorizer tenant ID.

[![Thumbnail 3030](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/3030.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=3030)

This is the most critical part of the slide. I hope this is clear. This is where I'm saying take the tenant ID from authorizer response and use it for making requests to the Lambda function as that header. It's like one line configuration, and this is where the whole magic is happening. So once I've configured that, the  request from API Gateway to Lambda will actually have that X-Amz-Tenant-Id header saying BlueTenant.

So I validate a token in the authorizer. I return the tenant ID, well, the string I want to use as tenant ID. You don't have to return exactly the same tenant ID. Maybe it's sensitive. Maybe you want to anonymize it or generate hash out of it. As long as it's a unique string, we don't care what it means for you. It can be anything. And that BlueTenant is going to be propagated all the way to my multi-tenant function. It will be processed by the BlueTenant execution environment.

[![Thumbnail 3070](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/3070.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=3070)

[![Thumbnail 3090](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/3090.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=3090)

[![Thumbnail 3100](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/3100.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=3100)

So now that you know how magic works under the hood, let's actually see the magic.  Alright, Postman this time because I'm using API Gateway, it's no longer just Lambda. So I'm sending a few requests here and I'm getting message unauthorized because I don't have the token just yet. You can see here. So let's add the authorization header. I'm a huge fan of JWTs, and this is JWT that represents,  you guessed it, BlueTenant, and it's the same story. I still have my counters running, 45, etc. Keep in mind we stopped at  5, BlueTenant 5.

[![Thumbnail 3110](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/3110.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=3110)

[![Thumbnail 3120](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/3120.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=3120)

[![Thumbnail 3130](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/3130.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=3130)

I'm going to replace the token with another token that this time belongs to GreenTenant. So let's send a new request.  You can see that this is a GreenTenant and the counters are starting from scratch. Why? Once again, because GreenTenant is getting a different set of execution environments. They're not sharing any virtual resources,  CPU, memory, disk, nothing is shared across tenants. I got to 10, let's switch it back to BlueTenant. Invoke, and we're continuing with 6, 7,  and so on. So it's basically the demo you saw before, but now with full integration with API Gateway, including authorization component.

[![Thumbnail 3160](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/3160.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=3160)

So this is the slide that I showed you 20 something minutes ago. The multi-tenant function model got benefits, but also got considerations. In the last 25-ish minutes, I hope I proved that with tenant isolation mode, we've addressed most of these considerations.  So we've addressed the problem of noisy neighbors potential through integration with API Gateway usage plans. We addressed that your architecture might require additional compute isolation, not something you handle in the code, something that we provide you with. Now you have that.

Cleaning up the leftovers, you know, it's still a good practice to clean up leftovers, but now we kind of reduce the criticality of this because compute environments are never shared across tenants. So if you introduce a bug, it's still a good idea to fix that bug, but we made it less critical. Per tenant observability is harder. Now you have per tenant logs, you can emit per tenant metrics, you got all of that.

To be very, very fair, tenant specific feature rollout is harder. You know, let's mark it as yellow. It's not exactly the problem we solved. It is easier because you have the tenant information in your function code, but you still need to do some, you know, if tenant ID equals or case tenant ID. You still need to do something in your code, but it is a little bit easier. So, you know, to be fair, we'll keep it as yellow.

[![Thumbnail 3240](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/3240.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=3240)

So this is where our story comes to a happy end. Joe identified a way forward that will not require his team to create hundreds of thousands  or whatever, functions, separate functions with duplicated code. They can create a small number of functions, and Lambda will provide separate execution environments for each tenant. So the tenant compute isolation mode essentially provided them, Joe's team with the ability to focus on, you know, delivering business value. They can innovate faster. That's another problem that previously they had to solve, and now they can focus on what actually matters.

[![Thumbnail 3280](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/3280.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=3280)

To conclude, understand tenant isolation requirements of your workload and implementation specifics in your architecture.  This tenant isolation mode, like, you know, don't quote me on that, this goes on YouTube, don't quote me on that. Based on my knowledge, Lambda is the only service I'm aware of that provides you tenant level compute isolation within a single compute unit function. I'm personally not aware of anything else that does that. But it doesn't mean it solves 100% of all the use cases.

In some cases, you might still need to do function per tenant where it's a hard requirement of your customers. Sometimes they will say they want isolation, not just per function, but isolated across different accounts. So the first thing is to understand what your customer demand is and how you meet that customer demand in the most efficient way. Tenant isolation mode helps you to make it more efficient.

[![Thumbnail 3330](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/3330.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=3330)

Second,  leverage tenant isolation mode for multi-tenant applications that require a higher degree of vendor-provided compute isolation. Was it a blocker previously? Not exactly, but who was responsible for that? You were. Now we're saying we're going to help you with that. We're going to provide you vendor-provided compute isolation per tenant.

[![Thumbnail 3360](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/3360.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=3360)

[![Thumbnail 3370](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/3370.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=3370)

Three, use built-in observability features  like tenant monitoring and API Gateway integration for stronger security in your SaaS application. Now this slide has some other sessions that are quite interesting on this and related topics, but we're on Thursday afternoon, so you're probably going to  see them on YouTube, not live.

[![Thumbnail 3380](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/6ce6e66c127416dd/3380.jpg)](https://www.youtube.com/watch?v=FWxwfcI7FTA&t=3380)

If you're not yet familiar with  Serverless Land, this is the website that is maintained by our solution architects and developer advocates. It has hundreds, if not thousands, of pieces of information, samples, and reference architecture. We run weekly Serverless Office Hours on YouTube and Twitch where we talk about every single new feature we launch in detail, no marketing, very technical. I highly recommend if you're not subscribed to that, do that.

And the last thing that I promised you but not fulfilled just yet, that's the giant QR code that will give you everything you saw today, including the slides, sample code, additional links, everything, pretty much. So thank you so much for coming. I hope this was helpful. I hope you learned about this new capability. Me, Bill, and Irish, he's the product manager for this amazing feature, we're going to be right outside if you have any questions. We're happy to address any questions just outside. Thank you so much and enjoy re:Invent.


----

; This article is entirely auto-generated using Amazon Bedrock.
