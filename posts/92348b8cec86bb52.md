---
title: 'AWS re:Invent 2025 - Transforming from SaaS to multi-tenant agentic SaaS (SAS304)'
published: true
description: 'In this video, Bill Tarr and Ranjith Raman present a comprehensive guide to transforming existing SaaS applications into multi-tenant agentic SaaS solutions. They outline a four-phase approach: domain analysis and modeling, agent capability development, infrastructure selection (focusing on Amazon Bedrock AgentCore), and scaling with observability. The session demonstrates practical implementations using a CRM application example, covering critical aspects like tenant isolation, identity management through workload access tokens, OAuth flows, and multi-agent orchestration. Key technical details include using AgentCore Runtime for deployment, AgentCore Gateway for tool discovery via MCP, session isolation with Firecracker MicroVMs, and implementing observability with tools like Langfuse while ensuring tenant ID remains a first-class concept. The presentation emphasizes that agentic transformations must maintain all traditional SaaS principles including isolation, security, and operational efficiency, while introducing new pricing models based on outcomes versus activity metrics.'
tags: ''
cover_image: 'https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/0.jpg'
series: ''
canonical_url: null
id: 3092806
date: '2025-12-08T18:01:50Z'
---

**ðŸ¦„ Making great presentations more accessible.**
This project aims to enhances multilingual accessibility and discoverability while maintaining the integrity of original content. Detailed transcriptions and keyframes preserve the nuances and technical insights that make each session compelling.

# Overview


ðŸ“– **AWS re:Invent 2025 - Transforming from SaaS to multi-tenant agentic SaaS (SAS304)**

> In this video, Bill Tarr and Ranjith Raman present a comprehensive guide to transforming existing SaaS applications into multi-tenant agentic SaaS solutions. They outline a four-phase approach: domain analysis and modeling, agent capability development, infrastructure selection (focusing on Amazon Bedrock AgentCore), and scaling with observability. The session demonstrates practical implementations using a CRM application example, covering critical aspects like tenant isolation, identity management through workload access tokens, OAuth flows, and multi-agent orchestration. Key technical details include using AgentCore Runtime for deployment, AgentCore Gateway for tool discovery via MCP, session isolation with Firecracker MicroVMs, and implementing observability with tools like Langfuse while ensuring tenant ID remains a first-class concept. The presentation emphasizes that agentic transformations must maintain all traditional SaaS principles including isolation, security, and operational efficiency, while introducing new pricing models based on outcomes versus activity metrics.

{% youtube https://www.youtube.com/watch?v=YOQlbZojPB4 %}
; This article is entirely auto-generated while preserving the original presentation content as much as possible. Please note that there may be typos or inaccuracies.

# Main Part
[![Thumbnail 0](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/0.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=0)

### Introduction: Transforming SaaS Applications into Multi-Tenant Agentic Solutions

Alright. Hey, welcome to re:Invent. This is our first talk for re:Invent. Probably for a lot of you, this is your first talk as well. Thank you for coming. We really appreciate you coming and your support. Today's topic is going to be really interesting for many of you. If you haven't been under a rock for the last year, you've heard something about GenAI. You've heard something about the agentic experience that's creeping into all of our landscapes.

For many of us, this means taking the existing applications we have and transforming them to be part of the agentic revolution. It's not enough to simply say, hey, we've got this existing application and we're going to just rewrite everything. Most of us who live in the real world know we have to deal with all of our applications and everything that we've built. So today's topic, transforming from SaaS to multi-tenant agentic SaaS, is really topical for a lot of the people that I talk to.

The customers who talk to me aren't interested in just creating new things and toys. They have applications, they have customers, and they want to make these things that they have work for their customers. This is a 300 level talk, so we are going to set the baseline a little bit in terms of some of the basics. We're going to talk about the SaaS fundamentals a little. We're going to talk about some agentic fundamentals. We're mostly going to focus on the transformation aspect of how you take existing applications and build them into an agentic SaaS application.

[![Thumbnail 90](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/90.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=90)

### Workshop Opportunities and the Core SaaS Value Proposition

My name is Bill Tarr. I'm a Principal Partner Solutions Architect, and I'm lucky enough to be joined by Ranjith Raman, also a Principal Partner Solutions Architect. Before I dive into this, I want to spend a tiny bit of time telling you about something else that's going on. This year, a couple of our breakout talks are lucky enough to be accompanied by a workshop. So if you're someone who likes to get hands on, if you want to get your hands dirty, you like going through a workshop flow, feel free to come. We actually have two sessions, Monday and Wednesday.

Now, they're both listed as full on the catalog already, but as you can see, not everybody shows up for every session. These workshops that we have for SaaS are definitely worth waiting in line for. If you have the opportunity to go and check them out, please do. If you don't, don't stress. One of the things I regret most after every re:Invent is a lot of people don't realize all of our workshops are public. If you see them here, you can go find them in our workshop catalog. If you don't, reach out to your account SA and they will help you walk through these workshops and find them.

[![Thumbnail 150](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/150.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=150)

They're great resources. They're also generally backed by GitHub repos. You can usually find the code that lives behind the workshop as well, publicly. So with that, let's move into the content a little bit. The SaaS value proposition. I said I'd set the table just a little bit. If you've ever heard us talk over the last six years about SaaS, you've heard a lot of these topics.

How do you scale an application? What does it mean to be efficient in building and operating your solution? How do you achieve the agility to rapidly add innovation for your customers? And how do you let your customers gain value out of your software as quickly as possible with frictionless onboarding? And then getting into the more technical side, how do we deploy our SaaS applications? What does it mean to have isolation between our tenants? How do we do different price tiering and then data partitioning? How do we take our data, our tenant data, and separate it out from other tenant data for cost and operational efficiency?

[![Thumbnail 200](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/200.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=200)

### Understanding Agentic AI: Autonomy, Decision-Making, and Human Collaboration

All of these are just the general SaaS value propositions, and most of you are probably familiar with them already. Now, in this new world of agentic SaaS, what we're seeing, and what I think is going to remain true, and you'll see throughout this talk, is all of those SaaS value propositions are inherited by an agentic SaaS solution. We don't absolve ourselves from the responsibility to do any of these other things in an agentic solution. Yes, they're fast to build. You can crank out an agentic application quickly, but it doesn't absolve us from having to think about what it means to deliver that agent at scale, about how to operate it so people aren't constantly crunching buttons and redoing the same tasks.

[![Thumbnail 240](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/240.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=240)

How do you create agility? How do you do tenant isolation? All of these topics are the foundation of what we're going to be talking about in terms of agentic SaaS, now and into the near future, as we start to see more of these agentic applications start to reach production and actual customers. What do we mean by Agentic AI? Well, just in general, when we're talking about agentic AI, what we mean is a system that has a high degree of autonomy and the ability to make decisions. But maybe the last part of this, where we're actually saying what it's not, highlighted with minimal human insight, is what I'd like to highlight and emphasize for you.

[![Thumbnail 290](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/290.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=290)

Because agentic solutions have a lot of capabilities, but they don't have the capability to continually make decisions independently, especially in highly valuable or highly regulated industries. Being able to make it easier for humans to do a lot of the existing tasks is really the cornerstone of what I'd say is important for a SaaS transformation into agentic SaaS. Taking off some of that heavy lifting from your individual operators and putting that into an agentic solution to help make them more optimal. That's when we're starting to talk about agentic SaaS, because we're talking about injecting SaaS app agents that do planning, building, and operating, which are the same tasks that humans do today in operating a SaaS solution.

Agents behave similarly, but not the same. They have different usage patterns, which unlocks new capabilities. There are things that agents can do that humans simply couldn't have done operating a SaaS. They can sit there 24 hours monitoring the state of your customer's application. They can replace outdated processes. Oftentimes, we have lots of humans mashing buttons, running reports over and over again, or monitoring operations. Those can be replaced or enhanced by SaaS agents. And of course, just removing the undifferentiated heavy lifting of things that we have to do repetitively, like onboarding processes.

[![Thumbnail 350](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/350.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=350)

[![Thumbnail 370](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/370.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=370)

 Now, when we talk about SaaS, you've probably heard us say before, SaaS is a business solution that has technical implementations. We always want to start from a business use case and work backwards from that into the tech. So when we're thinking about SaaS agents, or agentic SaaS, we want to start thinking about that technical implementation  and what that means from an agentic perspective.

### Business Strategies for Agentic SaaS: Model Selection, Customer Retention, and Layer-Based Transformation

For example, attracting new customers is pretty much key to any SaaS application. If you're not attracting new customers, you're probably not going to be particularly successful. Maybe some of the ways we can do agentic implementations that might enhance that business strategy is model selection. Could having different levels of models and different price points allow us to differentiate products for different types of customers, so we can go up or down market in terms of the offerings we're making? Could we do different integrations? A2A agent technology, MCP Model Context Protocol. Both of these might be familiar to you already. They're simply how we talk to systems either remotely or locally that allow us to unlock additional capabilities.

Again, in SaaS, very few SaaS applications are simply a bunch of code. They're a bunch of code that integrates with third-party providers. Are you using Stripe as your billing provider? Are you using Datadog for your observability? All these different platforms are evolving to have their own A2A and MCP stories. Now, what does this mean for attracting customers? Again, it can give you some flexibility. Can you integrate with different products that you couldn't before? Can that unlock different capabilities for your customers, perhaps in new industries which were inaccessible to you before?

[![Thumbnail 450](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/450.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=450)

[![Thumbnail 490](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/490.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=490)

And how do you retain customers? Well, if you operate a SaaS, reliability  is the cornerstone of this. If your system isn't reliable, if they're having irregular experiences, of course they're not going to be happy with your platform. Can you actually do agent evaluation? Can you do additional testing to your platform that you couldn't before because of how agents and the different operations they unlock can do? Could you actually enhance your customer success story? And this is one of the real stories that we're hearing more and more from customers, is that the customer success teams are increasingly using some of these tools like automation and user flows, not to eliminate the humans who know what they're operating on, but simply focusing them, bringing them to the right tasks at the right time to help customers  who have specific needs.

And easy discovery and onboarding. This could mean all sorts of things, but how you select frameworks in terms of your agentic story that make it easier for you to rapidly onboard customers. And of course, identity and authorization has always been a little bit of a sticky widget in terms of onboarding customers. Can the agentic story reach out and figure out what those identity stories are and help customers set them up without human interaction? All of these can be ways that you can improve your SaaS business by using agentic implementations.

[![Thumbnail 520](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/520.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=520)

[![Thumbnail 540](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/540.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=540)

[![Thumbnail 560](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/560.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=560)

 Now, agentic SaaS comes in a few different flavors. And we are talking about transformations today, right? So sort of keep in the back of your mind, there's going to be lots of talks about how you just write a new SaaS, new application in terms of an agent. We are talking about applications that exist today and what it means to build them out. So think about agent-ready SaaS, right?  This would simply be, you know, we can take an existing application, we can wrap it in MCP or A2A and make this available through new channels for either existing or new customers. And again, like we were talking about with our own capabilities of using third-party software, third parties can also use our software. And this may unlock different patterns for them  to consume our software.

[![Thumbnail 590](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/590.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=590)

Embedded Agentic SaaS, right? And this is actually having automated workflows that come into our system. So this is probably kind of closest to what we think about from most SaaS applications. Can I just take agents, stick them somewhere in the workflows that I have today? Human-facing agents, we're all kind of familiar with this modality, right? A chatbot or something that actually lets you interface with an application that before you would have been clicking through a bunch of buttons. And agent-facing agents. This is sort of the new frontier  that we're all thinking about and talking about. Will there come a point where an agent will simply talk to an agent without any human in between? Can two different third-party software that you're using, can Stripe talk to Datadog and figure out a particular integration that you have without you even needing to tell it what to do?

[![Thumbnail 610](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/610.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=610)

 This is an interesting one from the mindset of what we're going to be talking about next. When we think about existing transformations, transformations for existing SaaS applications, I want you to think in terms of layers and work your way downwards. Most human interactions and workflows happen at the solutions API layer, right, the API UI layer. Humans are interacting with these, systems are being designed to interact with these. There's business logic and there's data underneath. But the easiest place to inject agentic experiences into existing applications is usually at that front edge.

Model your human interactions. Think about what those workflows are and figure out how agents can enhance those experiences, either for your customers or for your own operators. And you're probably going to be pretty happy with the experience overall because it's going to enable you to inject agentic experiences non-invasively, but still visibly to your customers and operators, and remove some of the undifferentiated heavy lifting that they're probably already experiencing. Don't ignore the data in the business logic layer. If you have opportunities to inject the data agents into there, yeah, please do. But maybe focus on that front edge first as you're thinking about transforming your applications. And I think you'll probably find a lot of opportunities to inject agents into that experience.

[![Thumbnail 690](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/690.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=690)

### Agent Deployment Models and Multi-Tenancy: From Dedicated to Shared Architectures

So which flavor of agentic SaaS really fits for my domain and customers?  Let's get just a tad more technical. Yes, I've been skimming along the top of this. We haven't really even seen a technical architecture. Let's start thinking about what it means for agents in these. Well, you can have an agent as a product, right? We already said, hey, you could simply have an agentic experience. We've already seen this. ROS is a perfect example. ROS, Revenue Operating Systems, agents all the way down. They built on agents, they run agents, everything they do is agents. A really interesting solution, very innovative, but that's a brand new solution, right? And we're thinking about transformation. This may or may not be a fit for how we're thinking about things unless we have entirely new work streams we want to develop.

[![Thumbnail 730](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/730.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=730)

[![Thumbnail 750](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/750.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=750)

On the other hand, this probably resembles your architecture a little bit more today. You probably have a front end,  you've got an API, you got some microservices, some databases behind there, perhaps. Maybe we can inject agents into some existing workflows. Maybe we can replace some microservices. Maybe we can think about how we can add new functionality, which is really the easier path to agentic solutions. Can we take the existing functionality we have and enhance it with additional workflows  that involve agents? Or can we simply, again, that chat bot modality, can't we stick agents in the front of this and simply let them talk to the customer and have our application move behind a step and have an API, MCP layer that talks to that new modality.

[![Thumbnail 770](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/770.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=770)

[![Thumbnail 780](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/780.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=780)

But for today, we're going to be focusing on this middle one,  as I said, probably resembles your architecture a little bit more, right? This is closer to an existing SaaS application that we might recognize. So that'll be the focus of today's talk a little bit, even though you'll see, I think some clues  that will help you in the other directions as well.

[![Thumbnail 790](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/790.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=790)

[![Thumbnail 810](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/810.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=810)

Agent deployment models. So just getting a little bit more specific about what we mean here. When we talk about agents  and we talk about SaaS, you've probably heard us use the word dedicated or siloed before. This simply means in a SaaS term, everybody gets their own stack of software. In an agentic term, guess what? It means the same thing. Everyone gets their own agent. Everyone gets their own knowledge bases. Everyone gets their own tenant data stores. All of the agentic parts that make up the complete architecture of an agent.  Everybody gets their own stack.

And compare this to shared or pooled architectures where in fact one agent is operating from multiple tenants. In this world, we have to make different decisions and we have to think about who's operating on that agent at any given time. And again, our knowledge bases, our data stores, everything else could be shared in this model. But with that comes a little bit of responsibility. Because when agents meet multi-tenancy and agentic SaaS, we now have to think about how we're deploying them.

[![Thumbnail 840](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/840.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=840)

There are interesting aspects of agents  that are going to push us a little bit toward the limit compared to where we were before. There were already SaaS solutions. You know, think about Dremio or Datadog where a lot of the system ran in the customer's account. In agentic solutions, you'll be challenged even more to bring your agents closer to your customer's data. So those remote deployments will be on the table for a lot of solutions. We have to open up our mind and think about how we would operate those types of solutions. Those are still dedicated though, right? If we're thinking about those in terms of isolation, if you deploy at your customer's account, they're the only one who can access it. Still a dedicated solution.

[![Thumbnail 880](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/880.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=880)

We'll spend a lot of time thinking and talking about shared as always though.  What does it mean to have a shared solution? The biggest thing we're adding to the slide over the last one is tenant context. And you are going to hear us dive into what it means to do identity and tenant context in AgentCore and in agents in general. Injecting that tenant context, making sure it proliferates through the whole agentic system that we've created, all the way from the front end back to the data sources and back to the observability story is really how you make agentic stories multi-tenant. So with that,

[![Thumbnail 910](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/910.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=910)

 we want to think a little bit about what the agent story is. What is an agent even? If we think about agents holistically, we want to break it down into parts. These are traditional parts, and none of this is new to us. We have an agent that's your compute. If you've ever written any application, there was compute behind that, and there's a prompt for a model. That's what makes it an agent in a sort of pedantic sense. Now it's an agent because it's got a model. But really we have to think about all these other parts. What are the goals or instructions that we're passing into it? What are the tools that it has capabilities for? What is the context? If you've worked with any agentic solutions, you realize there's a context that's going conversation to conversation with it. How do we store those? How do we think about those in terms of isolation? That'll be what we're talking about. And then the downstream thoughts: what about observability? What about the actions we can take in the environments that they take part in? With that, we're going to start to get into the agentic transformation strategy, and we're going to hand it off to Ranjith, and he is going to take you through the next parts.

[![Thumbnail 1020](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1020.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1020)

### Practical Transformation Approach: A Four-Phase Strategy for CRM SaaS Applications

Thanks Bill. Alright, so Bill set it up really nicely by introducing why companies, and especially SaaS companies, may have to undergo an agent transformation. So now what I will be doing in this section is take you through some practical approaches in terms of how do you navigate that transformation. I'll also show you some examples on how to build and implement AI agents as part of your SaaS application. So what you're looking at is a pretty simple and straightforward representation of a CRM SaaS application. CRM stands for customer relationship management, and I assume this is a sales management function within a CRM app.  So there is lead management, there is a creation of opportunity or a task. And what you see on the top is a control plane, which is very standard and typical for any SaaS. So you have services like onboarding services that sets up identity, billing, metering. Basically services that have this crosscutting concern across the entire app. And below that is the application plane, which is where your tenant workloads are actually running.

[![Thumbnail 1050](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1050.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1050)

[![Thumbnail 1070](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1070.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1070)

[![Thumbnail 1080](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1080.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1080)

[![Thumbnail 1130](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1130.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1130)

Now in terms of the request flow,  you have a user coming in through your front-end application. CloudFront serves static assets from an Amazon S3 bucket. The user gets authenticated and the authenticated request flows through API Gateway.  So pretty standard and something that you would have done or you would have seen. And then there's a JWT or a JSON web token that's flowing around the request chain.  And that JWT token reaches application plane services. So pretty standard for a SaaS application. We are using Lambda, but you could use containers for your application plane services, and that's totally fine. But if you think about this, there's typically some kind of a user experience or UI on top of this experience. There is some kind of a form where somebody's entering the contact details or somebody's entering the opportunity or task details. Now, if I'm a SaaS provider, I'm thinking, well, that's a user workflow that is ripe for disruption. So that is something that I could potentially move over to an AI agent and have an AI agent handle that manual user entry and that pull workflow. So how do you go about doing that is exactly what we are going to talk about, or I'm going to cover as part of the rest of the session. 

[![Thumbnail 1150](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1150.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1150)

So what we recommend is taking a phased approach. When I say a phased approach, there are four phases here. The first phase would be your domain analysis.  So this is your domain analysis and modeling, and this is where you identify your domain, your sub-domains, your bounded context. And folks that have already done domain driven design will be already familiar with this. So it's about identifying what your domains are, what the objects within your domains are, what are the boundaries for those objects, and then you orchestrate the flow between those bounded contexts. So that's essentially phase one. And if you already have an application, this is an exercise that you've already done. So this is something that you would have already done and have, but if you have not done it, we highly recommend doing that. Now, phase two is the agent capability development. So once you have done the whole process of identifying a domain, sub-domains, bounded context, you would take those learnings and start creating your initial agent. And you start mapping the agent responsibilities to those bounded contexts that you have determined or figured out in the phase one of this process.

[![Thumbnail 1210](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1210.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1210)

Phase Three is the infrastructure, which is super important.  And this is probably where I'm going to spend most of my time on. You need the right kind of infrastructure to run your agents, something that's managed, something that provides you with the runtime identity and access control, memory management. So all that is super important. Picking the right infrastructure is definitely an important part of this process.

[![Thumbnail 1240](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1240.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1240)

And finally, Phase Four is scaling and monitoring. This is where you are monitoring the agent performance, coming up with scaling strategies.  And just like any application, this is critical as well when you're going through or undergoing an agentic transformation. So these are the four phases, and the phases are evolving. There could be other phases or more phases that might come up. But from what we observe, from what we see, this is how we would recommend approaching your transformation to agentic.

[![Thumbnail 1270](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1270.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1270)

[![Thumbnail 1280](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1280.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1280)

[![Thumbnail 1290](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1290.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1290)

[![Thumbnail 1300](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1300.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1300)

[![Thumbnail 1310](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1310.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1310)

[![Thumbnail 1320](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1320.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1320)

### Domain Analysis and Agent Development: From Single Agents to Multi-Agent Orchestration

I'll quickly go through this again. Like I said, Phase One is domain analysis.  So this is where you're identifying the different domains within your application. Because our example is a CRM SaaS app,  there's a sales management domain and objects within that domain. There's customer support, there's marketing automations, and there could be more domains. There could be a payment domain or account management.  So the first step is really identifying the different domains, and then you would orchestrate the flow between those domains. Like how are those domains connected?  So this is classic domain driven design if you have done it, if you have gone from a monolithic architecture to a microservices architecture.  So this is something that you've already done. And that's where we would recommend to start the process and then start with a single domain.  So pick a domain, let's say you pick the sales management domain, and you start mapping the capabilities into the agent. You would add the customer capability or the lead, or the opportunity or the task.

[![Thumbnail 1330](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1330.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1330)

 And what you would see is we have something called the tools, which are basically API calls or your business logic. So tools are a way where your agent gets access to external data or gets access to certain capabilities. This is perhaps a way you could start the whole process. You'll start with a single agent and start adding capabilities into that agent. But at some point you'll see that, or notice that, as you keep on adding tools, it can potentially overwhelm the LLM and the context of the LLM. So when you send a prompt into the LLM, it may not be able to figure out which tool to invoke or call. So at some point you may want to break it up into multiple agents.

[![Thumbnail 1380](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1380.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1380)

[![Thumbnail 1410](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1410.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1410)

[![Thumbnail 1420](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1420.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1420)

 This again goes back to the whole domain driven concept, where you have separation of concerns. You may not want one agent to expose whatever they're doing to a different agent or a different tool. So you come up with some kind of a boundary and create separate agents. Now, when you have separate agents, you need some kind of an orchestrator or a supervisor agent that knows which agent to call or which agent  to invoke when there is a request coming in. And the supervisor agent is the one that would look at the incoming prompt and it knows which agent to call.  Now this process can get a little bit complex. You have the user request coming in, it goes to the supervisor agent, and then the supervisor agent determines which agent to call.

[![Thumbnail 1460](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1460.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1460)

And if you look at the customer agent, it has a local tool. If you look at the lead agent, it's calling an MCP server, which has more tools. And then there are some common tools that the agent has to invoke. Now add in an external tool call and also identity, this whole process can get really heavy and really complex.  And it gets complex because there is obviously multi-agent collaboration, you have to orchestrate between those agents. Like I said, tools and tool execution becomes a challenge as your number of tools increases and the context increases as well.

Now, there are some frameworks out there, which I'm sure a lot of you would have heard of or even use like LangGraph, LangChain, crewAI, Strands Agents from Amazon that we built and we open sourced. So these are perfect choices because these frameworks give you prebuilt abstractions, so you as a developer or architect or engineer, you don't have to do a lot of the heavy lifting. The frameworks handle that for you. It does that multi-agent collaboration, it knows how to orchestrate and all that. But oftentimes, developers still face challenges.

[![Thumbnail 1520](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1520.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1520)

[![Thumbnail 1530](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1530.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1530)

[![Thumbnail 1540](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1540.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1540)

[![Thumbnail 1550](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1550.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1550)

They hit a brick wall when they're trying to move their proof of concept to production. They still find it challenging and hard.  And now you add tenancy into the mix. So you have your agent, you have multiple tenants accessing the same agent.  Some tenants might be okay to share a particular construct like memory while others may not, because they're in an enterprise tier or premium tier.  And then the same goes with knowledge base and tools. Some might be okay to share depending on the plan or the tier that the tenant is signing up for. If they're in the basic tier, things are probably going  to be shared or pooled. But if you're an enterprise tier tenant, you may want to provide them better isolation and better quality of service. So things are going to be more dedicated. When you add multi-tenancy or tenancy into the mix, things get even more complex.

[![Thumbnail 1600](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1600.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1600)

[![Thumbnail 1620](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1620.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1620)

Now, throw in identity. So you have your enterprise, you have your employees, you have batch processes or some kind of a process talking to the agent. How does the agent know if this is the right source? Can they allow that request to come through? Then you have your tenant users going to the agents. Agent calling other agents, which calls external services. Agent could call other external agents. So there are a lot of considerations when it comes  to a security and identity perspective. Things like access control, authorization, managing the lifecycle, identity lifecycle, integrating with third party applications. And the whole governance and compliance aspect can get really complex and challenging. And that gets us into phase three,  which is picking the right infrastructure and picking the right place to deploy your agents.

[![Thumbnail 1630](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1630.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1630)

[![Thumbnail 1650](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1650.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1650)

### Amazon Bedrock AgentCore Runtime: Secure Deployment with Workload Access Tokens

You need something that does all the undifferentiated heavy lifting of securely running your AgentCore  and remembering past interactions, the whole memory aspect of it. Identity and access control, agent tool use where you execute complex workflows, being able to discover other agents that are out there. And also finally auditing every single interaction that's happening within that whole ecosystem.  And this is where AgentCore, Amazon Bedrock AgentCore comes in. So it's a managed service from AWS which lets you deploy and operate agents in production in a highly secure, safe and reliable manner.

And as you see here, AgentCore has a lot of services and components. And I'm not going to go deep into every single one of those, but we are going to focus on a few of them. And the first one is going to be the runtime. So AgentCore Runtime, think of it as the compute. This is where your agents are actually deployed and this is where it's running. And you can build your agent using any framework, LangChain, LangGraph, Strands, doesn't matter. You can use any model that's available through Bedrock. You can develop that and bring that and deploy that into AgentCore Runtime and it's just going to work.

And then towards the top right, you have the AgentCore Gateway. So this is where you want your agents to discover other agents or other tools, external or internal. Perhaps there is a business unit that has exposed their own agents or tools. And you want your agent that's running within the runtime to access that over MCP, which is the Model Context Protocol. AgentCore provides a really nice abstraction, a really nice way to invoke or access those external tools or targets. And we'll get into how that whole thing works in a little bit here.

Then there is Browser, which is for browser, AgentCore Interpreter, which gives you a sandbox for executing code. Not going to go super deep into those, but AgentCore Identity is central to this whole authentication and security experience. So I'll definitely be covering that. Then you have observability and AgentCore Memory. So AgentCore provides a really nice way to deploy and operate your agents in a safe, secure, and reliable manner.

[![Thumbnail 1790](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1790.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1790)

Alright, so you're ready to deploy your first agent into AgentCore Runtime. So what you're looking at is a really simple, straightforward implementation of an agent.  It's using the Strands SDK and something to notice is the decorator called app entry point. So app entry point is where when you invoke an agent, that's where it's going to enter.

[![Thumbnail 1820](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1820.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1820)

[![Thumbnail 1840](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1840.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1840)

[![Thumbnail 1860](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1860.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1860)

The entry point function gets called, in this case the MyAgent function. Again, this is a Python representation. You could do the same thing in other languages as well, but the entry point is where the request would enter.  If you want to take this agent that you have running locally and deploy it into AgentCore Runtime, all you need to do is come up with a Dockerfile and package up your dependencies. When you say "AgentCore launch," it's going to create an image and push that to an ECR Elastic Container Registry repository,  and then it'll pull down into AgentCore Runtime and deploy that agent into the AgentCore Runtime. So you have your first CRM agent, the monolithic agent that we saw a few slides ago, deployed into AgentCore Runtime. 

[![Thumbnail 1880](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1880.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1880)

[![Thumbnail 1890](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1890.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1890)

[![Thumbnail 1930](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1930.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1930)

[![Thumbnail 1950](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1950.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1950)

Now you may ask, how do I access this agent? It's pretty straightforward. All you have to do is access the endpoint that AgentCore Runtime exposes. You just do an HTTP request and you're able to access or invoke the agent using that endpoint. Now, let's go back to the request flow  that I started with. A tenant comes in, the authenticated request flows in, and there's some kind of a JSON Web Token or JWT that the identity provider provided.  That flows through the proxy, and then from the proxy to the runtime, you pass in the JWT token, and it should be the access token. When you call an agent deployed with AgentCore Runtime, you would use the access token from the proxy when you're making that call. What AgentCore Runtime does is, before it forwards the request to the deployed agent, it sends it to AgentCore Identity, the other service. AgentCore Identity would go back and validate that request with the identity provider, in this case Cognito, and it ensures it's valid.  It's coming from a valid source, it's a valid user, valid identity before it sends a request to the agent that's deployed. I'll get into the weeds on this flow in a little bit, I think it's right here. 

[![Thumbnail 1970](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1970.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1970)

[![Thumbnail 1980](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/1980.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=1980)

[![Thumbnail 2000](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/2000.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=2000)

[![Thumbnail 2010](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/2010.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=2010)

[![Thumbnail 2020](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/2020.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=2020)

This is basically a refresher on OAuth, which even today I find somewhat difficult to understand. So it's a quick refresher. Let's say you have a tenant user. The user's browser connects to the frontend, and the user signs in and makes an authorization request to an identity provider.  In this case Cognito, then Cognito returns an authorization grant code back to the frontend. The frontend comes back with the authorization code,  comes back with the client ID and client secret. Then Cognito recognizes this user and authenticates, so here are the ID tokens, access tokens, and the refresh tokens. Those tokens flow around through the request chain and reach the proxy Lambda. The proxy Lambda uses one of those tokens, which is, as I said, the access token  to access the AgentCore Runtime. Now AgentCore Runtime, before it sends the request to the agent, sends it  to AgentCore Identity, validates the agent, and then it returns what's called a workload access token. This is a new construct within AgentCore  that we have introduced. This is opaque to you, you don't have to do anything here. This is an additional layer of security that AgentCore has introduced with workload access token.

[![Thumbnail 2040](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/2040.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=2040)

[![Thumbnail 2050](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/2050.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=2050)

[![Thumbnail 2070](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/2070.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=2070)

Now, what is a workload access token? When you deploy an agent with AgentCore Runtime, every agent gets its own identity.  We call it the agent identity or an agent workload identity. Then you have the incoming access token. A combination of the incoming access token  and the agent identity is a workload access token. This is not something you are doing, the service does it automatically. You don't have to worry about creating a workload access token. This is a slightly different representation of the same thing. You have the agent identity, incoming access token,  request goes to AgentCore Identity, it gets validated, and then AgentCore Identity creates this workload access token. What happens with this token is that any outbound communication or request that the agent, the CRM agent makes, it uses a workload access token from this point on. If it's calling an MCP server, if it's calling a gateway, or if it's calling a tool, it uses a workload access token as part of that request chain.

[![Thumbnail 2110](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/2110.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=2110)

[![Thumbnail 2120](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/2120.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=2120)

Now, what happens when there are multiple users? Because we are talking about a multi-tenant, multi-user system.  Let me quickly go through the flow. You have a Tenant 1 user who comes in with their access token, and they get their own workload access token. The same thing happens for the Tenant 2 user.  They come in with their own access token, and again, they get their own workload access token. Security is built in, and isolation is built in as part of the AgentCore. AgentCore Runtime provides that by default. Once you have the access token, as I mentioned, the agent is able to make any kind of outbound authentication calls that it needs to make.

[![Thumbnail 2150](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/2150.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=2150)

### Implementation Deep Dive: Code Examples and Authentication Flows with AgentCore Gateway

Let's look at some code. I hope that's okay.  Well, there's no going back now. What you're looking at is the proxy calling the AgentCore Runtime. You have the access token, as I've mentioned a few times. Step one is the URL to call AgentCore Runtime. If you notice, there's an ARN or an escaped ARN. We have to escape the ARN because the ARN is the AWS resource name and it has all the slashes and colons. You're escaping that and adding it as part of the URL in your call. This represents which agent you're calling within the runtime. If you have a supervisor agent, the ARN is probably, most likely, for the supervisor agent that's deployed. That's the URL.

[![Thumbnail 2220](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/2220.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=2220)

Then you create the payload, which has a prompt. You add the payload as part of an HTTP request. There's an HTTP call that you're making to the AgentCore Runtime. You're passing the token, as I've said a few times. It's passed as part of the authorization header. Finally, you're adding the tenant ID as part of the header. This ensures that the tenant ID flows through  across to the agent running within the AgentCore Runtime so that the agent is able to take actions on the tenant, set up isolation policies, and all that good stuff. It's important to make sure some kind of tenant identifier is passed from the proxy into the AgentCore or the agent running within AgentCore. This is the calling side.

[![Thumbnail 2250](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/2250.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=2250)

[![Thumbnail 2270](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/2270.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=2270)

Now this is the agent implementation, the receiving side.  As I mentioned, this entry point should be familiar to you by now. That's the entry point into the agent when the call comes in. We are retrieving the tenant ID that was passed in the previous step. Now, convert lead, and I'll get into what this particular tool is. It's a tool that has business logic.  If you remember where I started off the presentation, I said there are user workflows that you want to automate. There are people entering opportunities manually, there are people filling up forms. The goal or the idea here is to have an AI agent automate that for you. You want to have that business logic because it's a create, read, update operation, a lead operation. You want that as part of an agent. That's what convert lead does, and I'll show you the code for convert lead in my next slide.

[![Thumbnail 2310](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/2310.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=2310)

[![Thumbnail 2340](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/2340.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=2340)

The idea is you have a tool called convert lead, and you're providing that tool to the agent. Now this agent has access to that particular tool. You can add more tools.  Obviously, you can see that it's an array. If you have multiple tools, you can just do a comma-separated list and provide that. BedrockModel is a class within the Strands SDK where you provide the model ID and some of the other parameters. Agent comes from the Strands SDK. Again, you provide the model and also the system prompt. Then finally, that's the prompt. As part of the prompt, you have to specify the tenant ID  to make sure it goes to the right tenant and operates on the right tenant. This is a snippet of the agent implementation for AgentCore.

[![Thumbnail 2350](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/2350.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=2350)

Now the tool code.  I talked about convert lead. You start with the tool decorator, which again comes from the Strands SDK. You make sure there's a tenant ID. If you don't have a tenant ID, you kick back the request. But if you do have a tenant ID, then you do the CRUD operations. Step three is where you're getting the opportunities table or the task table. Step four is where you're updating, or in this case creating a new record. You can see that we have taken the user workflows where someone was entering the form, and we have moved that into an agent, into a tool, and we have provided this tool to the agent. We have transformed that experience. Again, it's a simplistic or simple example, but you get the idea.

[![Thumbnail 2420](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/2420.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=2420)

[![Thumbnail 2430](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/2430.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=2430)

[![Thumbnail 2440](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/2440.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=2440)

So up until now, we have been focused on the agent deployed within the AgentCore Runtime. It had access to some tools, like the convert lead tool,  and it could have access to other tools as you see here. That's totally fine. But there are cases where you want your agent to access other tools  or other targets that could be external, that third parties have exposed, or perhaps a different business unit within your company has exposed. So you want your agent to have access to that, and that is enabled  or achieved using the AgentCore Gateway. Like I said, AgentCore Gateway provides a way to discover new tools and integrate with new targets.

[![Thumbnail 2460](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/2460.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=2460)

Now, what are some of the targets that AgentCore Gateway supports? You can have an API Gateway Target, so any APIs that you expose  as part of an API Gateway, the agent now has access to that. You can have an OpenAPI Target. You can have a Lambda Target, so if you have a Lambda function, AgentCore Gateway can MCPFI that Lambda function and provide that to the agent. So the idea is your CRM agent deployed within runtime has more intelligence by having access to these additional tools. You can have an MCP server Target as well. So the gateway provides a really nice way, it provides an abstraction where it's able to provide access to multiple tools and provide that to the agent running within the runtime.

[![Thumbnail 2530](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/2530.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=2530)

Now there's an arrow going from AgentCore Gateway to identity. Again, security and identity is a first class citizen or construct in this whole experience. So any request coming into AgentCore Gateway has to be authenticated. The agent has to send an access token into the gateway, and that token gets authenticated or validated using Cognito. And that's how Gateway would process that request. If it doesn't find an access token, it wouldn't process the request.  So this is the gateway implementation. The code shows you have the CRM agent running within your runtime, and it is trying to access the gateway.

The first thing that it needs is the Gateway ID. So you would have the gateway deployed, you get the Gateway ID. In this case it's stored in SSM, in a parameter store, Systems Manager parameter store. You get the Gateway ID and add that as part of the URL. Like I said, you need the access token to access the gateway as well. Just like you need an access token to access runtime, you need an access token to access gateway as well. So you get the access token. You can see that there is a requires access token decorator. That comes from the Strands SDK, so you don't have to do a lot of wiring or heavy lifting. You get the access token using that decorator if you just add that as part of your Python implementation.

[![Thumbnail 2650](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/2650.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=2650)

Something to take note of is the auth flow. It's M2M, machine to machine, because you have an agent calling another agent. So it's different from the earlier auth flow because that was from web to an agent. That is an authorization code grant flow. So this is a machine to machine flow. And then once we have that, you can see that we are using MCPClient. MCPClient is part of the Strands SDK. And then you use streamable HCDP client and pass the token. And then number seven is important because this is slightly different from the earlier implementation. You still have the convert lead tool, but you're giving your agent access to other tools that are coming from the gateway now. So you're listing the tools. There is also a semantic search or semantic capability you could use as well, but you're listing the tools that are sitting behind the gateway and you're providing that to the agent in this case. So the agent has more intelligence, has access to more tools to take a decision. 

[![Thumbnail 2700](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/2700.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=2700)

Alright, so this is a really nice feature that literally came, I want to say last week. So the request coming into the gateway, you're now able to examine it, inspect it, or intercept it. And you're able to add things to the header. This is especially helpful if you want to attach a Lambda function to it. If you worked with API Gateway, this is very similar to the Lambda authorizer that you attach to an API Gateway. Same concept. So this will be helpful if you want to inject some tenant specific values or variables before the request goes to the downstream targets or downstream systems. And the same thing, when the response comes back from  the downstream systems, you can have a lambda interceptor process the response and send it back.

The gateway can process the response and send it back, or process the response before it gets sent back to the caller. You can inject more values, tenant-specific information and whatnot, as part of the response as well. Oh, I'm sorry, I can go back.

[![Thumbnail 2730](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/2730.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=2730)

[![Thumbnail 2740](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/2740.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=2740)

Okay, so this is basically a summary of the end-to-end authentication flow.  So you have the user, you have users that want to access the agent. We talked about this at length. They get authenticated, AgentCore Runtime,  there's an inbound authentication. Now, AgentCore Runtime Gateway has an outbound authentication which uses OAuth, but you can also use IAM outbound authentication if your agent wants to access AWS resources. Like if your agent wants to access DynamoDB or any AWS resource, you can use IAM outbound authentication as well. And the call to the gateway, like I said before, you can use OAuth, and then even the Gateway, if you see, there is an inbound authentication. There is also an outbound authentication going for the calls going from the gateway to other external or third-party services. So Gateway has both inbound as well as outbound OAuth as well.

[![Thumbnail 2830](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/2830.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=2830)

### Achieving Isolation: Tier-Based Deployments, Session Security, and AgentCore Memory

Okay, so up until now we have looked at something where you had a single runtime, single gateway, and a few tools. But there could be situations where, because typically in SaaS you have customers that are of different shapes and sizes, they have different requirements. So you could have someone in the basic tier, you could have someone in the premium tier. You could absolutely create a dedicated runtime gateway for your premium tier customers. It would look something like this, but it's still important to maintain some kind of an identity. So you would have AgentCore Identity, and what you can do as part of your identity provider  is create separate application IDs, client applications. For example, you could create a basic client application for your basic tier customers, and for premium tier customers, you can create their own application IDs. And that's how AgentCore Identity would recognize the request coming in. If it's coming from a premium tier customer, it would be authenticated against a premium application ID. You get the idea. So if there are more enterprise tier customers, you can achieve isolation by creating their own application IDs.

[![Thumbnail 2870](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/2870.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=2870)

[![Thumbnail 2890](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/2890.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=2890)

Finally, there is session isolation built in  because every agent session that gets created, it gets created in its own MicroVM. And we use the Firecracker technology that AWS invented. So every session runs in a completely isolated MicroVM. It has its own memory, it has its own compute, it has its own file system.  Because without that session isolation, there is a possibility that local files and state could bleed over and potentially be exposed. So every agent session is created within its own MicroVM.

[![Thumbnail 2910](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/2910.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=2910)

And this is the final thing before I hand it over  to Bill, AgentCore memory. So super important within an agentic system, because you want the agent to retrieve past interactions that you had with it. So AgentCore memory is a service within Amazon Bedrock AgentCore. It has a short-term memory and a long-term memory. So short-term memory is where the interactions are stored within a single session. That's what short-term memory is like. It stores all the past interactions within a single session. And the long-term memory spans across sessions. So it stores interactions across multiple sessions.

[![Thumbnail 2950](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/2950.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=2950)

 Now, in terms of isolation with AgentCore memory, AgentCore memory provides some really nice features. So you can have session tags. There is something called, for short-term memory, there's something called actor ID. So you can dedicate certain tenants and users their own actor IDs. And for long-term memory, you can create their own namespace. And the way you would access that from your front end or from your agent is you extract the tenant ID from the incoming token. You would map that to an IAM session tag. So this is something you may have already done. You create an IAM policy with placeholders, and then you use the tenant IDs to update that. And then you assume that role, and then you can use the STS, the Security Token Service, to get temporary credentials that are specific for that tenant that made the request.

So now you have tenant-scoped credentials using which you can access the specific part of the region within the memory, short-term memory or the long-term memory. So it's a really nice way to achieve isolation when you're using AgentCore memory. Alright, so I think I've covered a lot of things here to talk about phase four, which is the final phase. I'll hand it over to Bill.

[![Thumbnail 3040](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/3040.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=3040)

[![Thumbnail 3060](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/3060.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=3060)

### Phase Four - Observability: Making Tenant ID a First-Class Concept in Agent Monitoring

Thank you Ranjith. So we've covered a lot of ground. We've covered three phases already. The last one, and hopefully the one you didn't  forget, is observability. Because when we talk to SaaS customers, when we're talking to customers with existing SaaS products, often people don't spend quite enough time thinking about the observability story and how to build that in. If you're building agentic solutions, I want you to be thinking about this right at the front edge of your application. I want this to be a part of your original planning phases in part  because it's fairly complex.

[![Thumbnail 3080](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/3080.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=3080)

Now this part of the story hasn't changed all that much when we've talked about SaaS solutions in the past. We've always said, hey, you're going to have different tiers of customers. There's going to be some complexity. Out of everything that they call, we want to be emitting some specific SaaS context. So it has always kind of looked like this.  We've simply added agents into this story. Instead of saying, hey, you're calling a function, you're calling a microservice, whatever you're calling, we want to emit very specific metrics that talk about what the consumer is doing. Are they using a specific agent? Where are they using it? What feature are they using? What's the tenant ID? What's the tier that they belong to? Any of those that could be relevant downstream to your business users to help them to break down this usage by different pricing tiers, different regions, however they need to think about how to successfully operate their SaaS business. Those are the metrics that we need to emit. Because downstream there's going to be a whole other story for how they visualize these things. If we don't provide them the data, they're not going to be able to dig into that data and get to the observability story they need.

[![Thumbnail 3130](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/3130.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=3130)

[![Thumbnail 3200](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/3200.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=3200)

We've talked about all sorts of different parts of AgentCore, and of course observability has its own  functionality within AgentCore. It provides a lot of things out of the box. It has really nice agentic dashboards that come out of the box in CloudWatch. Those are worth looking into right away. Now the caveat I'll give you to both that and the third-party dashboards that we'll be taking a look at is that very few observability platforms consider tenant ID to be a first-class concept. What do I mean by that? When you look into your observability dashboards, it will talk about what agent are you using, what platform are you using, what region did you deploy in. It will not talk about your tenant identifier. This is a business concept that's specific to you because you're a SaaS provider. To them it's just another piece of metadata. Now that's problematic because downstream we want tenant ID to be a first-class concept. We want our dashboards to drive off of tenant ID. So regardless, take a look at the agent dashboards. They're great, really nice functionality out of the box. You're not going to find an easy way to simply say, hey look, I can see tenant ID. You'll see it in your logs. They'll be there if you emit it, but it's not going to occur to be automatic into those dashboards. Just keep that in mind, especially  as we're going through this next example.

[![Thumbnail 3240](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/3240.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=3240)

So I took a look at some of the examples that come out of the box. If you haven't looked, there's a GitHub out there called AgentCore Samples. It's great. It gives you examples of all of the stuff we've been talking about today, including third-party observability. And they actually built out a nice little example with a Jupyter Notebook for Langfuse, which is an AWS partner that has a complete agent platform including observability for agents. I dug into that a little bit. Sorry for the wall of text of code, but there really isn't much to show here except for code. Honestly, if you're doing observability, you're sending data from your agent off to their third-party solution. It's really just how you configure it.  So I wanted to call out a couple specific things on here. We're disabling the built-in OpenTelemetry solution for AgentCore. This is because we're going to directly send these metrics off to Langfuse. You can see just setting up a private key and some endpoints. This is all pretty basic stuff in terms of setup. It looks a little complex because there's a few lines. If you think about it, there's a URL, there's a key, and we're sending data to it. That's really all there is to this setup.

[![Thumbnail 3270](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/3270.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=3270)

When we get onto this, the example uses Strands telemetry,  which has a built-in OTLP exporter that you can use, and you simply have to make sure that however we're sending that data off to our third party, Langfuse in this case, you're emitting tenant metrics. I did it in two different ways here and I'll tell you why. I emitted tenant ID as a trace attribute, which turns into metadata on Langfuse's side. And I also did it as a tag. Now this was important because when I first set this up, I created my metadata as tenant ID and I sent it off to Langfuse and I started looking at the dashboards and I couldn't find it. And this again is the problem where tenant ID is not a first-class concept for almost any third-party solution.

[![Thumbnail 3320](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/3320.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=3320)

[![Thumbnail 3330](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/3330.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=3330)

[![Thumbnail 3340](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/3340.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=3340)

You have to figure out where that Tenant_id is going to surface in the dashboards. When I put the Tenant_id into the tags for Langfuse, it immediately surfaced up into the dashboards and I was able to create interesting visualizations. So there's my tenant ID, I was able  to create interesting models. This is just a query logging it. Here's the metadata as it shows up in Langfuse. Because now I have Langfuse here, umbrella-corp-004, which you could see  down there in the bottom, that's my tenant. It's metadata and it's also a tag which allowed me to create some interesting dashboards like this one.  All I'm really doing here is I'm sorting the count of Tenant_id calls for this specific agent. I can create much more sophisticated models based on the Agent_id, based on region, and everything else. But that Tenant_id has to be a first class concept in here for the dashboarding to properly work.

Now Langfuse is aware of this. There's actually even a ticket out there open on GitHub to make the tenant ID and the metadata available to the dashboards. But what you'll find consistently across all observability platforms is you have to be the one thinking about tenant ID and how that surfaces through your BI tools. Whether your customers are using third party tools, whether they're using AWS tools, you, as you're developing your application, have to think about how that's going to get out to the end users.

There's also an interesting case for this. Our example here is a CRM. This year I was lucky enough to work with Salesforce working on their Agent Force platform alongside our AgentCore and talking about the interoperability between the two. With agentic platforms, we're increasingly going to be pushed to talk about the interoperability of multiple agentic platforms. We'd love for you to build everything on AgentCore. That's awesome. Chances are you have other products that also have agentic stories. How are you going to reconcile this as a developer, as an operator? Well, using third party solutions like Langfuse and having all of your different agentic systems sending your telemetry off to a single source is one of the ways as a SaaS provider you can sort of streamline this operation.

[![Thumbnail 3460](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/3460.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=3460)

When we were working with Salesforce, it was great. It was easy because there were two of us talking to each other. It was, hey, what do you see in your logs? Okay, what do I see in my logs? Let's just compare. In a real world operating solution, that's not how things work. Having a single point for you to create dashboards, for you to visualize all of that data, is actually pretty helpful. So going back to our original use case we're talking about here, for a CRM solution or anything else you're building where there's multiple parts and multiple tools, it'd be awesome if you could figure out a way to use a single tool like an observability platform like Langfuse and send all your data over there. 

### Pricing Models and Strategic Takeaways for Agentic SaaS Transformation

I'm going to hint that there's actually a fifth phase of this. Let's quickly talk about what it means to do pricing in SaaS. We're almost at time, I'm going to shortchange this just a little bit. This could be an hour talk in and of itself. Growth Unhinged, which is a website I really like, has been spending a little bit of time thinking about how to price agentic features. They've sort of broken it down by this metrics activity-based model versus outcome-based model. Outcome-based model is starting to evolve in the agentic world when we price not just on how many widgets did you consume but how many widgets successfully did something you wanted them to do. It's an interesting mental model. Then there's sort of this fixed versus variable model that we always think about in SaaS. Do people want to have a fixed price? Do they want to have a variable price?

[![Thumbnail 3510](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/3510.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=3510)

[![Thumbnail 3540](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/3540.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=3540)

When they broke this down, you started  to see a pattern emerge. When you want to do outcome-based and you want to be fixed, you can do per workflow. So when a workflow completes, we're going to charge on that. If you want to have a variable outcome based process, you could do a per agent outcome. You can actually measure more granularly and this gets a little bit more like consumption based pricing. Activity based, you can do fixed per agent like a monthly fee. Hey, you get an entitlement to this many agent executions versus variable for activity based, which very much starts to resemble consumption based pricing as we're familiar with it.  So this is actually a great website, Growth Unhinged. If you haven't looked into it before, I think it's worth taking a look at.

Now where do we start in terms of this? You want to focus on that agentic business strategy. We haven't spent too much time talking about the overarching strategy, but think about this transformation. How did you get here and where are you going? Identify how and where your agents are going to enrich your offering. Be strategic. Think of that top down model we talked about. Develop new agentic pricing strategies. Again, have you considered whether your customers are willing to do outcome based pricing or consumption based pricing? These are important questions to ask upfront.

[![Thumbnail 3590](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/3590.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=3590)

[![Thumbnail 3600](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/92348b8cec86bb52/3600.jpg)](https://www.youtube.com/watch?v=YOQlbZojPB4&t=3600)

How do we scale? How do we remain agile and efficient? How do we model our agents for tenant onboarding? Because this is probably one of the key areas that we see that's going to evolve very quickly.  And how do we introduce new metrics, evaluations, and operating models that are going to make our existing operations, the things that humans are beating their heads into today, more efficient and work better? 

So I'll quickly throw the takeaways up here so I'm not running into anyone else's time. SaaS is a business. It's not one size fits all. Be diligent about who planned this. You can take a picture and you could read the rest of this on your own time because we are out of time. Thank you all very much for coming. I hope you enjoyed the talk. I will once again make a reminder. Ranjith has a workshop that covers a lot of this topic. If you didn't take a picture before, come up and bug him and ask when it's going to be. Thank you all.


----

; This article is entirely auto-generated using Amazon Bedrock.
