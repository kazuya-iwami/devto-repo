---
title: 'AWS re:Invent 2025 - Databases made effortless so agents and developers can change the world -INV208'
published: true
description: 'In this video, AWS Vice President G2 Krishnamoorthy and Colin Lanier present their vision for databases in the agentic AI era, emphasizing that data is the key differentiator. They announce Aurora Serverless database creation in just seconds, internet gateway with Postgres wire protocol support, and $200 AWS free tier credits. Vercel''s Tom Occhino demonstrates seamless Aurora PostgreSQL integration with v0 for rapid app development. Key innovations include MCP servers for all AWS databases, semantic caching with ElastiCache for Valkey achieving 95% recall rate, agentic memory integration with LangGraph and Mem0, and AWS Transform using AI agents to modernize SQL Server to Aurora PostgreSQL 5x faster. Robinhood''s Tim Ludikar shares their migration of 4.5 petabytes from RDS to Aurora in 120 days, achieving 20% cost savings and 60% improved write throughput. Additional announcements include Aurora patching in seconds, 256 TiB storage capacity, expanded zero-ETL integrations, and open source contributions like Valkey 8.1''s optimized hash table and PostgreSQL 18''s Skip Scan feature.'
tags: ''
cover_image: https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/20.jpg
series: ''
canonical_url:
---

**ðŸ¦„ Making great presentations more accessible.**
This project aims to enhances multilingual accessibility and discoverability while maintaining the integrity of original content. Detailed transcriptions and keyframes preserve the nuances and technical insights that make each session compelling.

# Overview


ðŸ“– **AWS re:Invent 2025 - Databases made effortless so agents and developers can change the world -INV208**

> In this video, AWS Vice President G2 Krishnamoorthy and Colin Lanier present their vision for databases in the agentic AI era, emphasizing that data is the key differentiator. They announce Aurora Serverless database creation in just seconds, internet gateway with Postgres wire protocol support, and $200 AWS free tier credits. Vercel's Tom Occhino demonstrates seamless Aurora PostgreSQL integration with v0 for rapid app development. Key innovations include MCP servers for all AWS databases, semantic caching with ElastiCache for Valkey achieving 95% recall rate, agentic memory integration with LangGraph and Mem0, and AWS Transform using AI agents to modernize SQL Server to Aurora PostgreSQL 5x faster. Robinhood's Tim Ludikar shares their migration of 4.5 petabytes from RDS to Aurora in 120 days, achieving 20% cost savings and 60% improved write throughput. Additional announcements include Aurora patching in seconds, 256 TiB storage capacity, expanded zero-ETL integrations, and open source contributions like Valkey 8.1's optimized hash table and PostgreSQL 18's Skip Scan feature.

{% youtube https://www.youtube.com/watch?v=MBvyZENChk0 %}
; This article is entirely auto-generated while preserving the original presentation content as much as possible. Please note that there may be typos or inaccuracies.

# Main Part
### Introduction: AWS's Vision for Data as the Foundation of Agentic AI

Please welcome to the stage Vice President of Database Services at AWS, G2 Krishnamoorthy. Hello and welcome. Thank you for joining us today. I'm thrilled to be part of your first day at re:Invent and to talk databases.

[![Thumbnail 20](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/20.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=20)

 We have an exciting agenda today. I will be tag teaming with my colleague Colin Lanier to spend some time with you on the big picture, looking out say the next three to five years. We'll address how database services fit into the broader data and AI mission at AWS. Our hope is to give you that important context that you need as you dive deeper and get hands on with the various database services throughout this week. We'll share more details on how we are bringing this vision to life with innovations we have delivered throughout this year.

[![Thumbnail 80](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/80.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=80)

Now, all of this is inspired by what we hear from you, our customers, and what we know you'll need to be successful with this transformational opportunity offered by generative AI and agentic AI. Also joining us today are Tom Occhino from Vercel and Tim Ludikar from  Robinhood, who will share their inspiring stories about the art of the possible built on AWS databases. Let's get started.

[![Thumbnail 100](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/100.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=100)

We at AWS believe that your data is your differentiator in this era of agentic AI. Our mission is to be your best  partner for the long term, to enable you to build your platform for agentic AI with your data at its foundation. We are deeply committed to helping you achieve your most ambitious goals, helping you transform the possibilities of agentic AI that you imagine into reality. And we believe AWS is the best cloud for your agentic AI foundation. Let me expand on why.

[![Thumbnail 150](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/150.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=150)

### The Coming Wave: Preparing for 1.3 Billion AI Agents by 2028

Quick show of hands. How many of you are using an agentic AI tool? Most of you. It's amazing how quickly the adoption of this technology has grown. If you remember, ChatGPT  only came out three years ago. Agentic AI is here and it is transforming the way we build with these powerful tools. Developers can be an order of magnitude more productive, and these tools are democratizing application development, expanding the pool of people who can build by another order of magnitude.

[![Thumbnail 180](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/180.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=180)

[![Thumbnail 210](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/210.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=210)

Combined, we foresee an exponential increase in the number of applications and AI agents, and the amount  of data generated and processed by them. To handle this scale, you need to be in the cloud and your cloud needs to scale to run all these databases securely, reliably, and efficiently. It's predicted that there will be over 1.3 billion AI agents in production by 2028,  and that may be a conservative estimate. Unfathomable, right? Yet just ten years ago, we were seeing the same thing about managing fleets of hundreds or even a thousand databases.

[![Thumbnail 230](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/230.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=230)

[![Thumbnail 240](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/240.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=240)

So our vision is to make it effortless for you to discover insights, make better decisions, and  drive innovation across your entire data estate. And we make this possible by giving you intuitive tools that allow your humans and agents to tackle the hardest challenges  in your business with ease, regardless of their technical expertise. By integrating best-in-class governance and guardrails so that you can innovate on your data with confidence, and by delivering on security, reliability, operational excellence, and price performance at unprecedented global scales.

[![Thumbnail 300](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/300.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=300)

Now we recognize the importance of interoperability. Some of your most critical applications are built on legacy database systems. So we will enable you to unlock your entire data estate, including those in the legacy database systems for agentic AI innovations. And once you're ready, we'll help you modernize to open architectures to future proof your applications. We'll make it effortless for you to build your data foundation on your highest quality data, be it structured data like your  tables, unstructured data like your documents and media, and synthetic data that you're creating to train your models.

[![Thumbnail 320](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/320.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=320)

No matter where it lives, so that your AI agents and applications can access them in real time. We want to enable  you to steer into this changing world of data and agentic AI. We are innovating on these five core building blocks: enabling you to scale effortlessly and be ready for that 1000x scale that we foresee, to continuously and automatically optimize your infrastructure for cost and performance, to build your agentic AI foundation with trusted data at the heart of it, and to embrace open architectures.

### From Today to Tomorrow: How AI Agents Will Transform Business Operations

Now let's visualize this transformation using a real world example and zoom into how things look today at an online retailer. I happen to work with one very closely. Today is Cyber Monday, and I would imagine everyone at this online retailerâ€”the DevOps engineer, data engineer, ML engineer, merchandising managerâ€”they are focused on bringing you the best deals, making your shopping experience in that app snappy, or optimizing your shipping times.

[![Thumbnail 360](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/360.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=360)

[![Thumbnail 410](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/410.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=410)

To make this possible, data from all these systems, like supply chain, is connected to a Unified Data Catalog for easy discovery.  All this data is going through continuous data quality checks to ensure that your delivery times are accurate. Merchandising managers are only accessing their category data using SageMaker. AI data scientists are training the models to provide you with fresh recommendations, and these recommendations are stored in S3 Tables that are easily  fetched by the app using MCP servers.

[![Thumbnail 440](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/440.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=440)

Now imagine there is an inventory issue with the hottest toy this holiday season. Say the merchandise manager made a fat finger mistake and missed a zero in their forecast. It happens. So today it takes many people and many more hours to understand what happened and to build a plan to make it right so that thousands of kids are not disappointed with Santa come Christmas, and  the retailer gets to keep the trust with their parents.

[![Thumbnail 470](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/470.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=470)

So what happens in the future? We foresee a future where agents and agentic tools transform this picture. In this world, agents are capable of doing tasks that we need human hands for today, and humans switch to directing these agents and agent tools to get the job done using prompts and specs. In this future, an AI agent is monitoring the inventory and  order flow and will generate an alert to kick off the investigation. The merchandise manager will tap into more agents to come up with a plan to make it right for the kids, to scour the additional inventory across the vendor base, to find and negotiate with alternate suppliers, and more. All this can happen in parallel and will be much faster. And most importantly, the kids get their toy come Christmas.

[![Thumbnail 510](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/510.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=510)

We recognize that the most critical applications for your enterpriseâ€”your CRM systems, your ERP systems, your supply chain systemsâ€”have their data in operational databases. We at AWS are building to this shared vision across our  database, analytics, and AI services to make it effortless for your applications, AI agents, and teams to get value from all their data. We are making AWS databases effortless to get started, to manage and scale, to migrate and modernize so that you can focus more of your hours building innovative features, shipping delightful customer experiences, and moving faster.

[![Thumbnail 540](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/540.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=540)

[![Thumbnail 560](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/560.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=560)

### Building at the Speed of an Idea: Vercel and AWS Partnership for Effortless Database Provisioning

This is a journey that we have been on for over  15 years since the launch of the first fully managed databases in the cloud. We removed the heavy lifting involved in managing database instances. Then we launched serverless to eliminate the need to plan, provision, and manage database capacity as your application scales up and down.  We took it a step further with DynamoDB, Aurora DSQL, and ElastiCache for key-value, making it effortless for you to get started with zero infrastructure to manage and virtually unlimited scalability. You never have to worry about provisioning capacity, scaling limitations, or maintenance windows. This is why our databases are ideal for the era of agentic AI.

[![Thumbnail 590](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/590.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=590)

With the emergence of powerful agentic tools like Vercel v0 that you  would see next, you can now bring these ideas to life as production-ready applications with just a few prompts. You need a database infrastructure that is just as effortless with all the enterprise goodness of security, reliability, and scalability. I am thrilled to welcome Tom Occhino, Chief Product Officer at Vercel,

[![Thumbnail 630](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/630.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=630)

to share how Vercel and AWS databases are revolutionizing Developer Experience to enable you to build at the speed of an idea. 

[![Thumbnail 660](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/660.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=660)

[![Thumbnail 670](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/670.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=670)

Welcome, Tom. Thank you so much. Hello everyone. I'm Tom Occhino and I lead engineering, product and design at Vercel. For those unfamiliar, Vercel is the AI Cloud that provides the developer tools and cloud infrastructure to scale, build, secure, and deliver a faster, more personalized web. More than 11 million developers use Vercel to deploy their work, and we  handle more than a trillion requests every month. 

[![Thumbnail 690](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/690.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=690)

I'm here today, like most of you, I assume, as a huge AWS fan. AWS is Vercel's preferred cloud provider, and we've built our platform on top of many incredible AWS services like Aurora, DynamoDB, Lambda, S3, and more. We've been working closely with the AWS team on something I'm excited to share today. 

[![Thumbnail 730](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/730.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=730)

One of our mottos at Vercel is you can just ship things. I love this billboard. We're obsessed with removing friction so developers can move as quickly as possible. One source of friction that's all too common is setting up and configuring databases. AWS databases are battle tested and ready for massive production scale, but that scale comes with a lot of critical configuration. Normally, when I need a database, I log into the AWS console and go through the create flow. 

This flow has pages of advanced configuration that I'll need once I'm ready to scale in production. But when I'm just getting started, I don't really want to think about any of this yet. I just want to get my app working as quickly as possible. What if provisioning an AWS database was as simple as installing an integration right from within the Vercel dashboard? We've partnered with the AWS team to enable just that, unlocking the delightful developer experience we are so passionate about.

[![Thumbnail 770](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/770.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=770)

[![Thumbnail 780](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/780.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=780)

[![Thumbnail 790](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/790.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=790)

Let me walk you through a quick demo in my Vercel dashboard. I'll head over to the integrations tab and browse the marketplace right here,  alongside everything else I need to build my app. I'll now see a brand new AWS integration.  The install flow is simple. If I don't have an AWS account, I can create one in one click. This integration gives me direct access to production-ready AWS  databases like Aurora SQL, Amazon DynamoDB, and Aurora PostgreSQL Serverless, with more options coming soon. These are the exact same databases you can create from within the AWS console, ready to power real applications at massive scale.

[![Thumbnail 820](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/820.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=820)

[![Thumbnail 840](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/840.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=840)

I'll go with Aurora PostgreSQL. I've been using Postgres for about a decade. I love itâ€”it's reliable, I know the syntax, and my team knows how to work with it. But the serverless part is what makes this particularly interesting.  Traditionally, configuring a Postgres database meant managing instances, planning for scale, and paying for capacity. Aurora Serverless gives me the Postgres I want, but with automatic scaling and pay for only what you use pricing. Since I needed to create a new AWS account here, that's what  happens next. I'll accept the terms and conditions and in seconds I'm taken to a minimal configuration screen with some defaults selected for me.

[![Thumbnail 860](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/860.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=860)

[![Thumbnail 870](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/870.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=870)

[![Thumbnail 880](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/880.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=880)

I'll be presented with the available plans here. What's really exciting is new AWS customers get a free starter plan with $100 in credits so they can get  up and running. Finally, I'll click create and wait a couple seconds and that's it. When this is done processing, I'm taken right into the storage tab of my dashboard where I can  connect this database to my app. I'll click Connect Project, select my project from the list in the dialog, and then click  connect. That's it. I don't need to do anything else. No managing connection strings, no secrets, no other configuration. Vercel handles it all automatically.

The setup itself from nothing to a working database wired into my app just happened entirely within the Vercel dashboard in less than a minute, and I'm ready to start writing queries.

[![Thumbnail 910](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/910.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=910)

[![Thumbnail 940](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/940.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=940)

There's even a button to open my new database in the AWS console securely in a single click.  It's magical because I don't need to manage a separate account, and I'm logged in and navigated to the exact right place automatically. I've been using V0 a lot lately to build lots of different projects, and it's been a lot of fun. V0 turns my ideas into real working web apps through simple conversation. Let's say I wanted to build a simple food delivery app for me and my family that I wanted to  customize just for us. I'll describe it in V0 and submit. It gets started right away, putting together a plan and scaffolding my app very quickly.

[![Thumbnail 950](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/950.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=950)

[![Thumbnail 960](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/960.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=960)

[![Thumbnail 970](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/970.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=970)

[![Thumbnail 980](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/980.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=980)

It's going to determine that it  needs to store some data, obviously. So it actually will prompt me to create an Aurora database. I'll go through the  same setup flow we just saw and let it process, and then I'm taken right back into V0 to continue building. V0 then  writes all of the code for creating the tables I need in this app, including restaurants, menus, orders, delivery,  tracking, and more. It even populates sample data so I can start testing right away.

[![Thumbnail 990](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/990.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=990)

[![Thumbnail 1000](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1000.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1000)

We'll give it the okay to run this database migration, and then we'll let it cook. Just  like that, I have a full app backed by a real Amazon Aurora database, ready to be customized and iterated on. If I need to access advanced configuration, I'm one click away from the storage tab in the Vercel dashboard where I can view the database that V0 just created, and in one more click, I can open it directly in the AWS console, just like any other database I set up myself.  I can even start CloudShell and write queries just like I always have.

[![Thumbnail 1020](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1020.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1020)

[![Thumbnail 1030](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1030.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1030)

[![Thumbnail 1040](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1040.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1040)

[![Thumbnail 1060](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1060.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1060)

That's  what this integration unlocks. You just describe your idea and you get AWS databases under the hood automatically. This isn't just a toy. This is a production-ready database with best-in-class scaling, reliability, and performance.  You get all the benefits of Aurora without having to think about any of the database setup.  This is the relationship we're building with AWS. Not just integrations, but intelligent infrastructure that adapts as your ideas evolve. This is the future that we're building at Vercel, which is part of our  broader vision to create self-driving infrastructure. Zero-config, framework-defined, autonomous operation of your entire stack.

### Fast Creation and MCP Servers: Connecting Developers to Data in Seconds

Now, I'd like to welcome Colin from AWS to tell us more. Hello. It's great to be here with you today, and I'm excited to walk you through a number of recent innovations and launches that support our data and AWS vision. Naturally, we'll begin with getting started. Let's talk about speed. Speed matters, and we want you to be able to build at the speed of an idea, which means rapid progress from your idea to your running application.

[![Thumbnail 1130](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1130.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1130)

But we've all been there. You're ready to move fast, and it's frustrating when you lose your momentum while you're stuck waiting for your new database to spin up. It doesn't need to be that way. If you're using DynamoDB, you can already create and access a production-ready table  in just a few seconds, the same amount of time that it would take to create a basic desktop database. But when you need a production relational database with all the resiliency and security features that you'll need to build something robustly, it takes time. Sometimes as much as 10 to 20 minutes, depending on your configuration.

[![Thumbnail 1170](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1170.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1170)

[![Thumbnail 1190](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1190.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1190)

[![Thumbnail 1200](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1200.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1200)

So we asked ourselves, how can we bring this fast creation experience to our relational databases? We took a hard look at our newest database, Aurora DSQL, when we launched it this time last year. You could create a new database in under two minutes, but we didn't think that was fast enough. So we kept working  on it. And now you can create an Aurora DSQL database in just a few seconds. We didn't stop there. So today we're excited to announce that coming soon you'll be able to  create an Aurora Serverless database in just a few seconds. Let's take a look at that experience in the Aurora  console. You go ahead and click create. It's preconfigured with an Aurora Serverless cluster, and you have the flexibility to update your configuration during and after database creation.

[![Thumbnail 1220](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1220.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1220)

Let's give it a quick name. In just two clicks  you have an Aurora Postgres database in only a few seconds. Now that it's created, you have access to all of the features and benefits of Aurora. If you have I/O intensive applications, just choose Aurora I/O optimized to improve price performance, saving up to 40% on costs.

[![Thumbnail 1250](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1250.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1250)

If you need replicas for read high availability or scalability, simply add a reader to your cluster and gain access to Aurora's automatic failover capabilities. If you run a  multi-region application, you can enable global database for disaster recovery. It's the same Aurora you love, but simply way faster to create a cluster. From there, you can connect to your database and get building.

[![Thumbnail 1280](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1280.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1280)

Fast creation is only part of the solution. Developers use a wide range of tools and IDE interfaces running outside of AWS infrastructure. To enable smooth connectivity from any tool anywhere in the world, we will soon be launching a new  internet gateway that fully supports the Postgres wire protocol. This layer provides secure internet connectivity for Aurora Postgres with no VPN or AWS Direct Connect required. It's also automatically integrated with AWS Identity and Access Management, or IAM, so you can enforce identity-based permissions for authorized access only and safeguard your data.

[![Thumbnail 1320](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1320.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1320)

Now you're probably wondering why I'm highlighting IAM in a talk about making databases effortless. Well, we made databases for IAM effortless.  We now allow all IAM users, including the root user, to connect easily at login, all while keeping the same high degree of security and the granular controls that you've come to rely on. We didn't stop there. We've updated the AWS Management Console connectivity experience to surface relevant information like code snippets and provide direct access to tools like AWS CloudShell.

[![Thumbnail 1360](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1360.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1360)

This means you can access your database on AWS as easily as you saw earlier with Vercel, with code snippets. Simply choose how  you'd like to interact with your database. Select Copy Code Snippet and then run command to get started with CloudShell. Simply launch CloudShell and click run. From there, you can connect to your AWS database directly from the console and start building.

[![Thumbnail 1390](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1390.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1390)

Finally, as Tom mentioned earlier, we launched a new AWS free tier earlier this year that's available  across a broad set of eligible databases. New customers can get $100 in AWS credits, and you can earn an additional $100 in credits for a total of $200. Coming soon, we'll be unlocking this free tier for the first time ever for Aurora Postgres Serverless. I'd encourage you to try it out and let us know what you think.

[![Thumbnail 1420](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1420.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1420)

[![Thumbnail 1440](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1440.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1440)

Like Vercel, we're also collaborating with AWS partners to bring our  databases seamlessly into their experiences, and we're integrating directly with widely adopted frameworks, AI assistant coding tools, and environments and developer tools all to unlock your ability to build at the speed of an idea. These environments support every phase of the development lifecycle, from writing code to deploying applications at  scale. They break down barriers to entry, meaning you no longer have to be an expert in every technology or aspect of that lifecycle to rapidly make progress.

[![Thumbnail 1480](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1480.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1480)

With so many developer tools, IDEs, and agents to choose from, MCP servers give you the flexibility and ease to build and deploy from the tools and agents of your choice. They are a critical component in agentic AI architectures, providing standardized interfaces needed for agents to interact with tools such as Claude, AWS Bedrock agents, and AWS Database services. By using MCP servers to connect to various data sources, you can build agents that perform a  wide variety of tasks and interactions.

[![Thumbnail 1500](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1500.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1500)

Imagine leveraging agents to automate operational tasks or to build an agentic AI system that orchestrates tasks across tens of thousands of databases. This is why we created local MCP servers for all of our AWS database services, making it  easy for you to access your data. MCP provides you with the right connectivity to develop faster from your trusted data sources.

[![Thumbnail 1530](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1530.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1530)

[![Thumbnail 1540](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1540.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1540)

[![Thumbnail 1550](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1550.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1550)

[![Thumbnail 1560](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1560.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1560)

You can connect via coding or AI-assisted coding tools to make it easier and faster to build applications. You can build operational efficiencies and agents based on your data patterns to reduce manual work. Let's start with the MCP basics. They operate in a standard client-server manner. In this scenario, we'll connect to the MCP server for Aurora SQL, our serverless  distributed SQL database using Kiro. But you can use any AI assistant such as Cursor or Visual Studio Code. We want to understand the shape of our dev database, so we can just ask  Kiro to summarize that for us. It breaks down that task into pieces. You can look at a task if you'd like, and then it gives us a clear answer. This is just a simple example of a  starting point. You can go leverage these tools to build agents, scale data operations, or really anything else you can  imagine.

### Agentic Memory and Semantic Caching: Building Intelligent Agents with AWS Databases

Let's look at an example of a more advanced genetic tool that's embedded within the DynamoDB MCP server. It's fairly straightforward to create a relational data model that can then be queried by SQL. It's intuitive. There's even normalization rules that come close to making it a science. On the other hand, people can struggle with NoSQL data modeling, particularly when they encounter it for the first time. It's often more art than science, and you need to work backwards from your access patterns and application requirements.

[![Thumbnail 1600](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1600.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1600)

[![Thumbnail 1630](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1630.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1630)

While all this becomes more intuitive with practice and you can get huge cost and performance wins, learning these NoSQL modeling patterns can be daunting. With our recently introduced Vibe modeling tool, which lives  within DynamoDB's MCP server, that work can now be done by the LLM. Making NoSQL data modeling an order of magnitude easier. Engineered by our DynamoDB experts, the tool provides a structured natural language workflow that translates your application requirements into an optimized NoSQL data model. It guides you through the design process, prompting you with questions to understand who the users are, what the key  scenarios are, and the desired customer experience.

[![Thumbnail 1650](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1650.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1650)

[![Thumbnail 1660](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1660.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1660)

[![Thumbnail 1670](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1670.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1670)

Let's take a look at that. In this example, we're using Kiro as the AI assistant with the DynamoDB MCP server. We're going to automatically invoke the tool by saying something like, help me design a DynamoDB data model. The structured workflow begins with gathering requirements. The tool knows  the questions to ask, and if you don't know the answers, it will help you make reasonable assumptions for the initial  design. The inputs are saved in markdown format in your local folder for your review. You can even edit the input directly to  add more information before creating the data model.

[![Thumbnail 1680](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1680.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1680)

[![Thumbnail 1690](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1690.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1690)

[![Thumbnail 1700](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1700.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1700)

[![Thumbnail 1710](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1710.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1710)

The tool generates a prototype data model that follows best practices, and this is also saved in markdown format in  your local folder. The data model explains which features were chosen, such as global secondary indexes, design decisions made, and the rationale behind these  decisions. This serves as a great starting point to build your application, because it speeds up your ability to create and optimize DynamoDB data models within minutes. From  this data model, you can then generate your DynamoDB schema and all the application code you need to interact with your  DynamoDB tables.

I'm really excited by the direction that this work is headed, and there's going to be much more in this space in the coming years. Now let's see how you can use AWS databases to create agentic applications that are powered by your data. Agents inherit powerful reasoning from LLMs. But here's the thing: they're only as smart as the data that you feed them. LLMs have a critical limitation. They're stateless. Every conversation, every decision, every interaction requires you to reconstruct that context from scratch. This can be slow and expensive.

[![Thumbnail 1790](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1790.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1790)

You need to use databases to store all of that temporary data that's required to keep the agent contextualized. Otherwise, it's as if you made holiday reservations today, but forgot you'd already made reservations months ago somewhere else. Two separate actions in time, but not connected without context. For agents to be effective, they need short-term memory like the current conversation thread, long-term memories like user preferences learned over time, and enterprise knowledge like transaction  histories. Each type demands different storage patterns. Some need millisecond retrieval, others need complex relationships, and all of them need to scale. This is why agentic memory is important. AgentCore Memory creates and manages context for agents, both short-term and long-term.

[![Thumbnail 1830](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1830.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1830)

AWS databases are a great destination for AgentCore Memory. We've enabled developers to use Bedrock AgentCore with our databases, and we've partnered with open source frameworks LangGraph, Mem0, and Letta to create production-ready database connectors that you can use to  launch agents that remember past conversations. Available today, you can store conversation state in DynamoDB using LangGraph checkpointers. You can build knowledge graphs of your agentic memories to improve retrieval by using Neptune Analytics and Mem0. You can persist long-term memories from agents built with Letta in Aurora PostgreSQL, and for short-term memory, you can achieve millisecond memory retrieval in LangGraph or Mem0 using ElastiCache for Valkey.

[![Thumbnail 1880](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1880.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1880)

[![Thumbnail 1900](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1900.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1900)

Let's see how this works in practice. In this example, we're going to create a very simple agent with memory using Strands, an open source development framework with a memory layer which includes agentic memory frameworks like AgentCore and Mem0, and our AWS databases. Strands is a  great SDK for building and running AI agents, and MCP focuses on providing tools and context to the agent. With just a few lines of configuration code and two lines of code in your agent, you can add the capabilities of Mem0  to enable your agent to create, store, and retrieve valuable agentic memories using AWS databases like ElastiCache, Aurora, and Neptune. It's that simple to get going.

[![Thumbnail 1920](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1920.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1920)

Today, caching exists in your browser, phone, in front of databases,  and almost everywhere you turn in technology. Your agentic AI stack is no different. Consider a use case like an agent and all of the variations there are to ask it how to reset your password. Much like using a cache in front of a database, you use a semantic cache in front of an LLM. With semantic cache, statements like "how do I reset a password?" or "I need to change my password?" have the same semantic meaning. Instead of needing to perform inference for every end user prompt, you can instead cache the semantic meaning of the question using vectors. When a similar question is asked, the response is just quickly returned from the cache.

[![Thumbnail 1970](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1970.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1970)

[![Thumbnail 1990](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/1990.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=1990)

Semantic caching with ElastiCache for Valkey is going to help you reduce costs, improve performance, and increase the throughput of your applications. We're excited  to share that Amazon ElastiCache for Valkey now delivers the lowest latency, highest throughput, and best price performance for these workloads, with over a 95% recall rate. With AI, you can now build at the speed of an idea. To do so,  as we've seen and we'll see this week at re:Invent, your database and development toolchain is evolving to include MCP servers, semantic caching, agentic memory, IDEs, tools and frameworks, just to name a few. While much is changing, one invariant is that data will continue to be the foundation and the underpinning of every application. We're excited to make databases effortless so that you can focus on building, innovating, and delivering what matters most for your customers.

[![Thumbnail 2090](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/2090.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=2090)

### Robinhood's Journey: Scaling Financial Services with Aurora, DynamoDB, and ElastiCache

Joining us on stage to share why they're using AWS databases to power all their applications and how they're approaching AI in their products, I'd like to welcome Tim Ludikar, Director of Software Engineering at Robinhood. Hi, everyone. I'm Tim Ludikar, Director of Software Engineering at Robinhood. At Robinhood, our mission is to democratize finance for all, and to achieve that, it starts with building platforms that make investing more accessible, more affordable, and more available to everyone globally. Today, we manage over 340 billion in customer assets across 27 million funded accounts.  Our users rely on Robinhood for everything from real-time trading to long-term investing, a service they increasingly need around the clock. Operating at this scale requires radically reliable and highly performant systems.

[![Thumbnail 2130](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/2130.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=2130)

That's why our platform is built natively on AWS. At Robinhood, our infrastructure philosophy is reliability.  First built to support massive scale and increasingly shaped by agentic AI. This transition is helping us evolve from AI-assisted troubleshooting to fully AI-directed operations, driving both our internal efficiency and the intelligent experiences our customers rely on every day.

[![Thumbnail 2190](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/2190.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=2190)

This reliability-first mindset drives every architectural decision we make, especially when it comes to our data layer. To that end, earlier this year we partnered with AWS to complete a major migration moving from RDS Postgres to Aurora, evolving our foundation to power the next generation of applications and AI workloads. Today, we run over 24,000 database cores across multiple availability zones.  This entire infrastructure is designed to elastically scale up to handle peak loads during market open, and then scale back down efficiently to baseline.

[![Thumbnail 2220](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/2220.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=2220)

[![Thumbnail 2230](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/2230.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=2230)

We've been AWS native since day one, and this journey has taught us a key lesson: there isn't one database to rule them all. Over time, we've evolved into a  multi-engine architecture built with Aurora, DynamoDB, and ElastiCache.  This variety of data engines allows us to power every single part of the business across all of our core verticals. These include core divisions such as market data, brokerage, crypto, futures, and event contracts.

[![Thumbnail 2270](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/2270.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=2270)

[![Thumbnail 2280](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/2280.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=2280)

Each database has a specialized role. Aurora Postgres powers our core brokerage applications and our user authentication.  DynamoDB, on the other hand, handles real-time market data, low-latency mobile charts, and even supports AI initiatives like Robinhood Cortex and our customer support agents.  Finally, ElastiCache is used to cache request paths, improving the performance and responsiveness of our core systems.

Earlier this year, a small team of just eight engineers completed the fastest ever migration from RDS to Aurora Postgres, moving 4.5 petabytes of data in under 120 days. This result boosted our operational efficiency by a factor of six. We retained all features we had on RDS while immediately gaining 20 percent better cost efficiency. On top of that, we gained critical features like fully managed reader auto scaling, significantly improved failover, and storage and I/O auto scaling.

[![Thumbnail 2340](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/2340.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=2340)

This foundation now runs our most critical and demanding workloads.  These tier-one workloads include critical processes like our core trading platform, tokenization, and fraud detection. These all support everything from Robinhood Gold all the way up to Robinhood Legend. This hybrid database architecture is key. Not only does it provide the added consistency needed for financial transactions, it also provides the speed and scale required for all of our live data and machine learning workloads.

[![Thumbnail 2380](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/2380.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=2380)

Here is what that architecture is actively delivering for us today. For sheer scale and performance, we are processing millions of read and write transactions per second via Aurora.  We also ensure submillisecond response time for all market queries, leveraging both DynamoDB and Aurora. This scale is achieved while sustaining that 20 percent cost efficiency and reduced operational burden, enabled by full infrastructure automation. And finally, this architecture has driven a significant improvement in direct customer experience.

[![Thumbnail 2440](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/2440.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=2440)

The peak write throughput for our core brokerage and crypto systems has increased by 60% on Aurora. Being in financial services means operating under the scrutiny of regulation, and we embrace that responsibility to deliver on our commitments. We leverage key AWS features, including  DynamoDB and Aurora S3 export, which allow us to meet our regulatory compliance commitments. These tools are critical because they enable us to retain and access customer data within 24 hours of any transaction, saving the company millions in potential fines.

[![Thumbnail 2490](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/2490.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=2490)

Additionally, our Aurora configuration includes specialized analytical readers that support our complex audit and reporting needs. Crucially, we retain over seven years of historical data, ensuring we are always prepared for regulatory access. Speed is not just a user experience metric; it is also critical to accuracy. To achieve this, we have built  real-time data pipelines that rely on change data capture from Aurora and DynamoDB streams. This pipeline syncs money transfers across services with near-zero latency and feeds our real-time data lake while meeting our 15-minute SLA target for all of our tier-zero data.

[![Thumbnail 2540](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/2540.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=2540)

Ultimately, this provides us with full observability and control over our entire platform, resulting in a truly real-time experience for our customers. However, having the data is only half the story. The next step is crucial: putting that speed and data freshness to work to maintain absolute platform reliability. That is why agentic AI is not just transforming our products; it is  fundamentally changing how we run our platform. We are now using AI to reduce operational toil by automating issue detection, accelerating root cause analysis, and even recommending or executing remediations all in real time.

[![Thumbnail 2600](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/2600.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=2600)

Over time, these systems will evolve into fully AI-directed operations, allowing us to sustain high reliability and build the operational capacity needed for massive future growth. With global demand for democratized financial tools expanding rapidly, we are no longer thinking locally. We are actively expanding globally to offer 24/7 equity, money, and crypto trading. As you can see, we plan to leverage DynamoDB Global  Tables and Aurora global databases, which are key for providing data replication and reliable performance across all regions. We are also exploring Aurora DSQL to significantly enhance our infrastructure control plane and access management resiliency.

[![Thumbnail 2640](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/2640.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=2640)

[![Thumbnail 2690](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/2690.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=2690)

An active-active architecture means we are always able to read and write to any regional endpoint, allowing us to scale out seamlessly as we grow our business and applications across more geographies. Looking ahead to 2026, the pace of innovation at Robinhood continues to accelerate in line  with our mission to democratize finance. We have already announced several new products built with AWS, and we plan to announce several more throughout 2026. A big shout out to the Robinhood Storage team, whose incredible work provided the critical foundation for our platform architecture, including the successful migration to Aurora. Finally, thank you to the AWS team for their deep expertise in complex infrastructure for financial services, making them a trusted and essential partner in our journey. We thank them for building the infrastructure that helps us innovate quickly, scale globally, and deliver reliably even in one of the most regulated and dynamic  industries in the world.

[![Thumbnail 2730](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/2730.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=2730)

### Making Database Management Effortless: Patching, Zero-ETL, and AWS Transform

To be your partner to deliver a world-class experience for your customers, to build wealth and secure their future. So far, we've talked about how AWS databases is making it effortless to get started for builders and AI agents. Let's switch gears and talk about how we are making it effortless to migrate and manage your databases. I'll be highlighting  four innovations today.

Let's think back to our discussion on mission. Core to our mission is database fundamentals: security, availability, scalability, and performance attributes for which you have come to trust AWS. One of the biggest contributors to application availability is database patching and upgrades. I'm excited to share that Amazon Aurora now applies patches to your database in a few seconds. Switchover from Blue-Green deployments with Aurora now takes less than 30 seconds. We've expanded Blue-Green to support Aurora global databases, enabling you to perform these critical database management operations that are so important for security with little to no application impact.

[![Thumbnail 2780](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/2780.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=2780)

[![Thumbnail 2810](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/2810.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=2810)

 We are now making it even easier to manage patching and upgrades across your fleet of databases using the upgrade rollout policy feature. You can centrally and flexibly manage the order in which your database clusters are patched and upgraded across multiple accounts and clusters. With this feature, you can set up dev and test clusters to be upgraded first, followed by your typical production applications, and have your mission-critical applications  go last. This allows you to better manage risk from database upgrades and adopt automated patching and upgrades with confidence.

[![Thumbnail 2830](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/2830.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=2830)

[![Thumbnail 2850](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/2850.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=2850)

[![Thumbnail 2860](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/2860.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=2860)

 We heard you loud and clear, and we agree that patching dev before prod just makes sense. You asked for more headroom in a single cluster for your applications to continue to scale. It's simpler when you can scale up the database than to make changes to your applications to scale out across many clusters. That's why I'm excited to share that over this year, we doubled the  storage scale in Amazon Aurora to 256 Tebibytes.  Now even the most data-intensive applications can simply scale up and continue to scale.

[![Thumbnail 2890](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/2890.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=2890)

You also told us that the simplicity of zero-ETL integrations is a game changer to unlock your operational data for analytics and AI with ease, especially when the number of applications, agents, and databases are expected to grow exponentially in the future. We are continuing to expand zero-ETL integration. This year,  we added additional support from Postgres, Oracle, and SQL Server, and our vision is to make it effortless for you to enable these AI innovations across your entire data estate. Now you can enable zero-ETL from your databases running not just in our managed services, but also on EC2, in your data center, or even in another cloud.

With a few clicks, you can simply connect to your data no matter where it lives and land that data in real time in Redshift or S3 Tables, and use the breadth of AWS analytics and AI capabilities to unlock value from all your data. Lastly, we know that agentic AI is cloud native. For many customers, adding agentic AI to their application means migrating their application to the cloud first. As they're migrating their legacy Windows .NET and SQL Server applications to AWS, they're also looking to optimize costs by modernizing to .NET Core on Linux and Aurora PostgreSQL. These customers can cut their costs by simply avoiding expensive licensing fees.

[![Thumbnail 2980](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/2980.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=2980)

[![Thumbnail 2990](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/2990.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=2990)

[![Thumbnail 3000](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/3000.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=3000)

Just moments ago, we announced a new set of capabilities in AWS Transform to make just that.  With AWS Transform, the AI agent would do all the heavy lifting, including conversion of your schema, your stored procedures, and migration of  your data. Let's see this in action. Start with pointing AWS Transform to your application code repository. The agent will identify and assess the associated databases before  moving to schema conversion.

[![Thumbnail 3010](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/3010.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=3010)

[![Thumbnail 3020](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/3020.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=3020)

[![Thumbnail 3030](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/3030.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=3030)

[![Thumbnail 3040](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/3040.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=3040)

AWS Transform converts your schema using a generative AI-powered schema conversion tool.  It will then configure DMS replication to move your data.  It will also migrate embedded SQL in your application code, all from within a single, simple experience.  Customers are completing their modernization projects up to five times faster with AWS Transform, reducing their costs by up to 70% and unlocking the security, performance, and scalability of Aurora. 

### Open Source Commitment: Performance Innovations in Valkey and PostgreSQL

Before we close, I want to take a moment to talk about open source. At AWS, we are committed to open formats and open standards because we believe they offer customers the most interoperability and the best value. We have teams at AWS dedicated to contributing to open source projects like PostgreSQL, Galera, MariaDB, and MySQL. This year alone, our engineers upstreamed over 1,000 changes. I want to go into a little more detail with a couple of features that we upstreamed that I'm really excited about.

[![Thumbnail 3090](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/3090.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=3090)

At the heart of Valkey, or any cache for that matter, is a data structure called a hash table. Most of you have encountered it in your CS 101 course. It's the data structure that gives you constant-time lookup and inserts. Let's take a closer look at the implementation in Valkey 7.2.  You can see that we are using an object to wrap the key and value, using pointer chaining to handle collisions. Nothing fancy. However, in a modern CPU like Graviton, chasing pointers often means a CPU cache miss, and it's expensive. Modern CPUs can run up to 2,000 instructions in the time it takes to fetch data from memory. In this design, we are chasing four pointers for every lookup, and since no hashing is perfect, each collision would add three more pointer chases.

[![Thumbnail 3170](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/3170.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=3170)

[![Thumbnail 3180](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/3180.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=3180)

In version 8.1, we have a hash table that is built from the ground up, optimized for cache efficiency in modern CPUs. First, we switched the design to a single object for the whole entry, so that lookup requires only one pointer instead of four. That's a huge improvement. To handle hash collisions better, we switched to a 64-byte cache line bucket.   With clever secondary hashing, this new design can handle up to seven collisions with no additional overhead. So when you are looking for that seventh entry, your overhead remains one instead of 22. That's amazing. The cherry on top is that the new design reduces the hash table overhead per entry by 20 to 30 bytes. This means you can pack up to 20% more objects in the same amount of memory, saving you money.

[![Thumbnail 3210](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/3210.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=3210)

I want to highlight one more example, this time from PostgreSQL.  Here we have a table in the inventory database at an online retailer that we discussed earlier. This table has an index with order status, product ID, and customer ID. This index makes it easy for you to query customers who are waiting for a given product. The optimizer will use the index and process only the rows for the given status and product. Now let's go back to that earlier example from Cyber Monday. What if you want to find all the customers who ordered a toy? Since the query is not filtering on the leading column status, PostgreSQL 17 or earlier cannot use this index, and the query will have to scan the whole table, which is slow and expensive.

[![Thumbnail 3270](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/3270.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=3270)

Now, what if we can teach the optimizer to look at the index as a set of mini indices, one per order status value? Now you can actually quickly find customers for each status by filtering on status and product,  and move on to the next, processing only the few rows each time. This is exactly what Skip Scan does in PostgreSQL 18, and this feature will make some of your queries run much faster and cheaper with your existing set of indices. Just upgrade to PostgreSQL 18. No application changes are required.

[![Thumbnail 3300](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/03a373aa22b7de06/3300.jpg)](https://www.youtube.com/watch?v=MBvyZENChk0&t=3300)

So let's recap. We have shown how we are making databases effortless to migrate your existing applications to AWS,  to operate them far more efficiently, and to build at the speed of an idea through integrations with AI builder tools like Vercel v0, agentic frameworks like Bedrock AgentCore, and MCP servers, all with the security, availability, scalability, and performance to meet all your application needs. We are continuing to innovate at a fast pace. We have a few more exciting announcements, so make sure to watch Matt's keynote tomorrow morning. We can't wait to see what you will build next, powered by AWS databases. Thank you and have a fantastic re:Invent.


----

; This article is entirely auto-generated using Amazon Bedrock.
