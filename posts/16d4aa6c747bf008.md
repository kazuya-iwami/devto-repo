---
title: 'AWS re:Invent 2025 - From concept to production: Build with spec-driven development & Kiro  (DVT320)'
published: true
description: 'In this video, Ryan Yanchuleff and Ryan Bachman from AWS demonstrate Kiro, a generative AI development tool that uses spec-driven development to build applications at scale. They explain how Kiro differs from traditional AI coding tools by generating requirements documents, design documents, and implementation plans before writing code, ensuring consistency across large development teams. The session includes a live demo building a fitness tracking web application, showcasing features like agent steering, MCP server integration, agent hooks for syncing with tools like Jira, and property-based testing. They address challenges of context windows, determinism in LLM outputs, and collaboration workflows, emphasizing how steering documents help reverse-analyze existing codebases and maintain consistency across 150+ developer teams working with millions of lines of code.'
tags: ''
cover_image: 'https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/0.jpg'
series: ''
canonical_url: null
id: 3085375
date: '2025-12-05T05:23:32Z'
---

**ðŸ¦„ Making great presentations more accessible.**
This project aims to enhances multilingual accessibility and discoverability while maintaining the integrity of original content. Detailed transcriptions and keyframes preserve the nuances and technical insights that make each session compelling.

# Overview


ðŸ“– **AWS re:Invent 2025 - From concept to production: Build with spec-driven development & Kiro  (DVT320)**

> In this video, Ryan Yanchuleff and Ryan Bachman from AWS demonstrate Kiro, a generative AI development tool that uses spec-driven development to build applications at scale. They explain how Kiro differs from traditional AI coding tools by generating requirements documents, design documents, and implementation plans before writing code, ensuring consistency across large development teams. The session includes a live demo building a fitness tracking web application, showcasing features like agent steering, MCP server integration, agent hooks for syncing with tools like Jira, and property-based testing. They address challenges of context windows, determinism in LLM outputs, and collaboration workflows, emphasizing how steering documents help reverse-analyze existing codebases and maintain consistency across 150+ developer teams working with millions of lines of code.

{% youtube https://www.youtube.com/watch?v=VRw3g-v4B00 %}
; This article is entirely auto-generated while preserving the original presentation content as much as possible. Please note that there may be typos or inaccuracies.

# Main Part
### Introduction to the Kiro Code Talk Session

Thank you for coming out this afternoon for our session on Kiro. We'll be talking about how to build applications, and we're going to be building a live application in front of you here this afternoon. I am Ryan Yanchuleff, one of our Specialist Solutions Architects here at AWS. I'm part of the Next Generation Developer Experience team. We work with customers who are looking to roll out generative AI development tools inside of their organizations. With me I have Ryan Bachman, also from the same team with the same responsibilities.

As we get into this session, who has done a Code talk before? These sessions are really meant to be interactive. While we are going to be doing live coding, I also encourage us to engage and learn from each other. I'll be walking around as he's presenting and coding. We'll have some downtime, so please ask questions. I'll go ahead and amplify that question, and we can talk about it. Whatever you want to talk about or learn, we're here to discuss agentic AI or spec-driven development as well with Kiro. Feel free to share your opinions and thoughts.

I will be polling the audience numerous times today. We are going to be building an application from scratch inside of Kiro live on the screen. We're going to build an application that you guys and gals recommend. Ryan's going to poll the audience in just a minute, and we're going to take the two or three best ideas and build them live here on the screen. We'll build the best one live on the screen. Be thinking about that as we walk through the next couple of slides here.

[![Thumbnail 0](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/0.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=0)

### The Evolution from Autocomplete to Agentic Development

 Before we dive into it, I want to set the stage and talk a little bit about what Kiro is so that everybody's familiar with it. It's a relatively new product that we released this year, and it just went general availability about two weeks before today. One of the questions that we get asked a lot is why did we build another tool? There are a lot of them out there. Why did we build another one? I think it's helpful to understand where things have gone and how they've evolved.

[![Thumbnail 150](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/150.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=150)

 If you go back a couple of years, we started out with generative AI that just did general helping. It was a glorified IntelliSense autocomplete with simple chat questions and interactions. More recently, we got into a situation where we could do assistants. We could say, "I want to make a change to this function" or "I want to debug this particular log file" or "help me out with this thing"â€”very specific tasks that we could ask the generative AI tools to help us with. In the current age, we have what we call agents, where I take more complex problems and say, "Here's what I want to do. Here's what I want to build. I want to build an application. I want to add a new feature to my existing application. I want to modernize this part of my application. I want to migrate this piece of application code." I need you to help me out with that, and that involves multiple different steps. I've got to run things on the command line. I've got to talk to third-party tools. I've got to generate code. I've got to modify existing code. We call this agentic development.

[![Thumbnail 220](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/220.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=220)

 The term agentic gets overloaded a lot, so I think it's helpful to understand what we mean when we say that. The promise here was that we get autonomy. We could all go sit on the beach while we let the generative AI tools go and write code for us. We get more collaboration. We have a back-and-forth conversation with this generative AI tool, and we chat along and get work done just like you do with your other coworkers. And then we of course get high-quality code. Nobody's producing junk when we do this because we're all professionals. This is the promise.

[![Thumbnail 260](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/260.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=260)

### Three Major Challenges: Scale, Control, and Quality

 The challenge that we saw with customers starting to use these tools in their production environments centered around three major things, and these are the three major things that we set out to solve for when we built Kiro. The first one and the biggest one is how do you scale. It's great when I want to build tic-tac-toe and I'm just one developer in a corner hacking out some code, but when I have an existing production application with 1.2 million lines of code and I've got a team of 150 developers who are all working together, this becomes really important. I need my LLM to be able to understand all that code. I need it to be able to understand that code consistently. And I need to be able to produce similar results for all 150 developers.

It does me no good if the non-deterministic nature of the LLMs creates working solutions for all 150 developers, but it does so in very incompatible ways, which is possible when you think about the non-deterministic aspects of generative AI. So how do we do this at scale? How do we solve for large development teams and how do we solve for large existing code bases?

The other piece is the idea of control. We talked about in the previous slide about this true collaboration concept, but that's not really what we have in generative AI. What we have in generative AI is we take this prompt that we concoct and throw into the chat box, we throw it over the wall and we say make me something. And it goes off and it writes 1000 lines of code and it says, I made you something, and then it hands it to you and hopefully it did it right. But more than likely what happened is that it got to a lot of different decision points, a lot of details that you left out of your prompt that it now has to go and fill in the blanks. And maybe it got it right, maybe it chose the option you would have chosen, maybe it didn't.

But now it's up to you to figure that out. And now you've got 1000 lines of code that you've got to go and figure it out with. And then the last piece is when you take those two factors together, both of those negatively impact the overall quality of the code. What you're getting is code that you don't really want. It doesn't really do what you wanted it to do, and it doesn't really do it the way you wanted it to do, and it does it differently for all the different developers on your team, which is not helpful.

[![Thumbnail 410](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/410.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=410)

### Spec-Driven Development: A Return to First Principles

So what we created for Kiro and what we tightly integrated into the solution  is something that we call spec-driven development. And it's a return back to first principles of software development. We don't bring a team of developers into a room, write four bullet points on a whiteboard and say, guys, we'll check in on you in six months. Let us know how it goes. That would be chaos and for good reason.

What we do is we step back and we say, all right, what are the requirements? Let's detail those. Let's bring in our stakeholders. Let's bring in all the key players and lay that out. Then we say, all right, well these are the requirements. How are we going to build this? We build a design document and we say what are all of the different design specs and the technical details, and we lay all of those out and we bring in all the stakeholders.

And then we say, all right, what is the project plan? We build one of those fun Gantt charts with all of the different tasks that we can do in parallel and in serial, and we lay those things out. And then once we have those, then we bring the team of developers in the room and we say, here's what you're building, here's how you're building it, and here's all the different tasks that you need to do, and we use those to go off and actually do the implementation. And that's how we solve for this problem of building at scale.

So what spec-driven development does is it takes generative AI and it applies the same model. It says, give me your prompt that you concocted that's missing a lot of details, and instead of going off and writing 1000 lines of code, I'm going to go and I'm going to generate a requirements document, and then I'm going to generate a design document and then I'm going to generate a project plan and you're going to have the opportunity to review all those things because they're just text documents.

And then when you're happy with all of those, then we'll start building and whether it's just you on a greenfield application like what we're going to do here in a moment, or whether you've got a team of 100 developers and hundreds of thousands of lines of code, we're going to get very similar results because we're working with the same context, we're working with the same details, and we've had a chance in advance to review all of the different details that might have gotten left out from your prompt. And we can fill in the blanks and we can validate them all and then we can move on.

[![Thumbnail 540](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/540.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=540)

[![Thumbnail 550](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/550.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=550)

[![Thumbnail 580](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/580.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=580)

### Building a Fitness App: Vibe Mode vs. Spec Mode

And so that's what spec-driven development is and that's really what makes Kiro unique. So  if you could build an application and take advantage of that, how would you go about doing it? And so this is where we're going to switch over and we're going to switch to a live coding demo.  And so I'm going to need some ideas because I've got a blank empty screen and I need something to build. Bonus points, anybody that's been to like an improv show, I'm going to try this out. You know, you shout out like random ideas and then we're going to maybe combine a couple or two. So like, we need this is where we need the audience. So like, don't raise your hand. Just yell out. What's that? All right, fitness app. Anyone else? Fitness that the focus on the trainer.  That. AWS what event app event manager that's my app. I came up with that app. It's what I normally do in my demos. Can we combine? I don't know how to combine those two virtual concierge. Oh, hotel. There you go. All right, so we got a fitness app, concierge app and I don't know how to combine all three of those. I'm going to simplify this down a little bit.

Here's my prompt: if you look at that prompt, you can tell pretty quickly right away that there's a lot of detail missing here. I have specified that I want a web application, but I have not specified what I want it to be. It could be React, it could be Python, it could be .NET, or it could be some esoteric language from 40 years ago. We haven't really defined that.

We haven't specified a lot of things in here, like whether we want authentication. That's probably a good idea for a personal fitness app. We haven't specified what a lot of the features are. We haven't defined whether we want a full stack app with a data layer, a business layer, and a front layer, or whether we want to build this all together like a Next.js app, for instance. We haven't said if we wanted it to be mobile. Well, actually we did say we wanted it to be a web application, so we specified that. But you get the pointâ€”there are a lot of details here.

[![Thumbnail 710](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/710.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=710)

In Kiro, I have the ability to switch between two different modes.  If I were to put this in Vibe mode, which is what you'd get from a traditional generative AI tool, and I were to hit go here, it would go off and immediately start building. It would figure out some strategy to build a web application. It might pick React, it might pick Python, or it might pick something else. If there were five of us up here on stage, it might pick something different for each one of us because generative AI by definition is non-deterministic, so we're not guaranteed the same results.

[![Thumbnail 740](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/740.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=740)

[![Thumbnail 750](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/750.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=750)

### Generating and Reviewing the Requirements Document

But I'm going to put it into Spec mode  and I'm going to kick this off. What's going to happen now is that Kiro, instead of going off and actually writing the code, is going to start generating what we call a spec.  A spec here is going to define what it is that we want to build before we actually start building it. We're going to let this run in real time to give you a sense of how much time this actually takes. The spoiler alert is it doesn't take very long, assuming that our network holds up here.

[![Thumbnail 770](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/770.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=770)

It's going to create for us a requirements document, and you can see here it's opened it up on the screen.  I've got my requirements document on the screen here. This requirements document starts out with a high-level introduction. I wrote one sentence into the prompt box here, and I've gotten a paragraph of details that are laid out. I've also gotten a glossary of terms so that we are clear on what we're talking about.

[![Thumbnail 830](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/830.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=830)

[![Thumbnail 840](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/840.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=840)

It's laid out a lot of different details like what's a user, what's an activity, what kind of activity types are there, how do we calculate calorie consumption, and how do we deal with the activity logs. All of these different things are laid out. These are all important things if I'm going to go and build this application that I didn't specify in my original prompt. Then we're going to get into the meat of this, which is the requirements themselves.  Each requirement is going to have a user story and it's going to have a set of acceptance criteria.  The user story combined with the acceptance criteria is going to detail all the different things that I want.

[![Thumbnail 850](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/850.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=850)

You can see here that it came up with seven requirements, which is not bad considering that I gave it one sentence.  Now, is that enough requirements to build a full-fledged web application for fitness tracking with all of those other details? Probably not, but it does get us quite a bit farther down the road than we would have been if we had just taken this prompt and thrown it over the wall. One of the things that's important to understand about specs is that they're not really designed to be used to write an entire operating system. You want to use something like a spec to do feature development.

So our application here is going to evolve over time. There are going to be things that we want to add to it. There are going to be things that as we show off our initial MVP to our stakeholders, they're going to say, "Well, this is really cool, but I want to add this thing. This is really cool, but I want to change this piece. I hate this thing. I can't believe you built this." We're going to go all a couple of different routes here, and we're going to be able to evolve as we go.

[![Thumbnail 910](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/910.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=910)

We've got our user stories here and they follow a specific format.  They follow what we call EERS, an industry standard for writing requirements. It stands for easy accessible requirements system. It follows that key system which creates a user story and then creates acceptance criteria. So what we can do now is review this. Do we like this? Does it capture the things that we want? Did we think of something else in the five minutes that it took to create this document that we want to add? We can evaluate and iterate on this and make adjustments. For the sake of time, I'm going to leave it here as it is, but it says here "as a user I want to create and manage fitness activities." That's a good start that aligns with the prompt that I have here so that I can plan and track my exercise routines.

[![Thumbnail 960](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/960.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=960)

I want to mark the activities as completed with their actual duration so that I can track what I actually accomplished.  You can see here that each one has acceptance criteria. So when a user creates a new activity, the application should store that activity with the details, with the type, with the planned duration, with the planned date. All of that information should get tracked. Maybe I want to add another attribute there. Maybe I want to track a location as well. Now is my opportunity to come in here and make an adjustment, and I can say I want to add location to my data that's being stored. All I'm doing here is modifying a markdown file.

### Creating the Design Document with Technical Specifications

Once I'm happy with the requirements, I move on to the design phase and I say, all right, well this is great, but now I want to know how am I actually going to build this? What language am I going to write it in? What libraries am I going to use? What am I going to do for authentication? How am I going to handle error handling? What am I going to do for testing? All of these different details need to be captured here. We gave it no details except for a web application, so we're all going to find out together what this thing actually decides to build and how it decides to build it.

This is going to be our opportunity to say no, I don't want to build it with Python. I want to build it with React. I don't want to build it with React. I want to build it with Go. I want to build it with a SQL database. I don't want to build it with a SQL database. I want to build it with NoSQL databases. This is my opportunity to correct for all these things because at this point, if we just threw this over the wall with vibe coding, the LLM would make those decisions for you. It would say you didn't tell me what kind of database you wanted. I feel like SQL today. I'm going that route. And if you wanted NoSQL, you're out of luck. You're going to have to go back and rebuild that code after the fact. That creates complications and it takes time to evaluate for all of those things.

So at this point we're going to get an evaluation and you can see here one of the things that it's doing is formalizing the requirements for correctness properties. Kiro has a feature in it called property-based testing, and property-based testing is a really fancy term for essentially testing with edge cases, but it's going to evaluate my requirements and it's going to say what are the things that need to be checked for. How am I going to check for them and not just the happy path, but what are all the edge cases? You say that you want to know what your planned duration is for your activity. Well, what happens if you enter a bunch of letters into that field? What's it going to do? Is it going to give you an error? Is it going to crash? Is it going to blow up? How's it going to handle that?

[![Thumbnail 1150](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/1150.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=1150)

That's just one example, but you can see here that it's looking at the different requirements and it's saying, all right, what do we need to do to test for all of that? When we go now and we look at the design document, what we have here is another summary at the top with all of these details.  We have more architecture, so we have a foundation layer, we have a business layer, we have a data access layer, we have our browser's local storage, we have a tech stack. It looks like it's using React with TypeScript here. That's what it settled on. It's going to use the React context API for state management. It's going to use Tailwind for my UI. A lot of different things here are being specified.

[![Thumbnail 1180](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/1180.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=1180)

[![Thumbnail 1190](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/1190.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=1190)

[![Thumbnail 1200](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/1200.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=1200)

And again, if I don't like any of those things, it's pretty simple. I just go in and modify this application, this document here,  and I'm good to go. It's going to lay out the stack for all of the different models that I have. We're going to get into the data layer,  we're going to get into the correctness properties and all of the different ways in which we're going to do that.  What happens if we have a planned and actual duration both preserved? For any activity with a planned duration, completing it with a different actual duration should result in both the planned duration and actual duration being stored and retrievable.

[![Thumbnail 1220](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/1220.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=1220)

[![Thumbnail 1230](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/1230.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=1230)

How are we going to calculate that? What are we going to do for triggering the calorie calculation? There are a lot of different details there. Then we get into error handling and input validation.  We get into business logic errors. We get into testing strategies, including employing all of those different property-based tests that we outlined above. What do we do for unit testing and integration and  test execution? There is a lot of detail here that is captured.

[![Thumbnail 1250](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/1250.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=1250)

### MCP Servers and Agent Steering: Managing Existing Codebases

We have some questions over here. The question was about two things: MCP servers and whether that is the default addition. So for the room, the questions are about MCP servers that are configured, which you can see in this video, and also about agent steering.  What is agent steering? So the MCP servers I installedâ€”by default, Kiro does not come installed with any MCP servers. It has support though for local MCP servers and for remote MCP servers. You can go through the remote MCP server flow. You can use OAuth to connect to your remote MCP servers if you want to do that, or you can install local MCP servers and configure them.

I have these installed at the user level, which means that they work for all of the different projects that I open. You can also install MCP servers at the project level, so they are only relevant to the specific project. These MCP servers here have to be installed locally on my machine. I do not know that we are necessarily going to use them over the course of our demo here, but you can install whatever you want. They do not come pre-installed.

Now, the question about agent steering. Over here on the left-hand side, this is my Kiro panel. I get to it by clicking on the little ghost here. Kiro by default is a VS Code fork. If you are looking at this thinking it looks pretty familiar, it is because it is a VS Code fork. A lot of the UI and elements here are going to be very familiar to you. There is a section here at the bottom with a little ghost that brings up the details that are unique to Kiro.

You can see here at the top the spec that we are working on is listed here, so I can see the spec that I have here. I can create as many specs as I want. I am not limited to one spec. I do not have to try and build my entire project in one go. I can create multiple different specs and I can track them all as I go along. We will finish this one out here in a moment. But down here I have agent steering.

So what is agent steering? Well, if you have used other generative AI tools before, you are familiar with the idea of context and the idea of rules. In Q Developer, for instance, we have the idea of rules. What a rule is, is essentially just a piece of context that provides guidelines for the LLM to follow. Whenever you document or whenever you write a function, I want you to include a comment block that looks like X Y Z at the top of it. That is a rule. I want Kiro to do that for me.

Steering documents though, and particularly this button called generate steering documents, deal with one of the challenges that we talked about in the slide presentation, which is how do I deal with projects that have existing code? How do I deal with a project that has hundreds of thousands of lines of code? In order to do that, what I need to do is document that somehow. I need to create some context around it. I need to summarize it. I need to make that available to the LLM in the form of rules or context or something like that.

What generate steering documents does is that the first time I went, or whenever I open up a new code base in Kiroâ€”and by new here I mean new to Kiro, so maybe I have been working on this project for ten years, but I am going to open it up in Kiro and I am going to go down and I am going to hit that generate steering documents buttonâ€”what it is going to do for me is reverse analyze that code for me. It is going to go through all of that source code and it is going to summarize it for me. It is going to say, all right, here are the details that I need to be aware of when you ask me to make a change to this code.

[![Thumbnail 1500](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/1500.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=1500)

It is going to create a file called a product file. The product file is a natural language summary of the code. It is a layout of what this code is doing that I, as a reader, as a human, could quickly pull up and say, all right, give me a summary of what this eight hundred thousand line code project is doing. I can read through that. Then it is going to build a tech file and the tech file is really going to mirror what our design document file looks like here.  It is going to be the tech stack. What language is it written in? What libraries is it using? What is its strategy for error handling? What is its strategy for testing?

What are the commands necessary to boot the dev server? What's the command necessary to run the test suite? All of those different things are going to get captured in the tech file and then it's going to build the product file. I think the product file is the last file and is essentially the roadmap. The roadmap file is going to lay out the directory structure of this project, all of the different directories, the code, the files that are in each of these directories, what's relevant about each of these directories and each of these files, and the major classes and modules and elements inside of these.

Equally as important, if I ask you to make a change to this particular module, what's the blast radius? If I ask you to make a change to the authentication component in my 800,000 line project and I go in and modify that, how many other things in this project are going to be impacted by that change? In order to know the answer to that, I need to know what the spider web looks like of how these different modules interact with each other. Kiro is going to capture all of that information for me in the form of these three steering files, and it's going to do that for me automatically when I press that button.

That steering directory is open-ended, so I can add whatever other things I want to add there. If I have a rule about how I do software development, I can generate that and add it to the steering directory. If I have information about a third party API that I talk to and I want to be able to be aware of that, I want the LLM to understand how I use that API, what it does, how it works, I can document that and add it to the steering directory.

All of these files live inside of this .kiro directory at the root of my project. If we go back to the file explorer, you can see here we're starting out from scratch. I don't have anything in my file explorer yet except the specs that I created, but as we start generating out more code, this will all get captured in here as we go along. Does that answer your question?

### Context Windows, Session Management, and Team Collaboration

Well, so you mentioned that we're not going to always work in this fashion, which from a perspective totally makes sense. Small increments and a human needs to also understand the increment. There are technical limits. We are flirting with a lot of context. The question is whether there's a technical context limit that we need to be aware of. Just like every LLM, there is a context window that applies. Kiro has a 200,000 token context window at the moment. We have some plans to release bigger token windows as the models are evolving and the token windows are expanding, so the product is evolving along with that.

If you get to a point where your token window is full, Kiro will ask you if you want to compact your current session down and essentially reset your context window. One of the things about using specs and using them with steering documents is that the combination of steering files and spec files is a really powerful combination. All of this information is already documented largely in these markdown files. If I need to reset my session or if I want to go on vacation and come back on Monday, I can do that and I haven't lost a whole lot because I'm detailing everything here in these static files.

I can share these files across the team. If somebody else needs to come in and pick up where I left off and do it from their own machine, we don't need to worry about transferring the session details because we've captured all of the major important points in these markdown files. That's why that's a big part of why we're doing this because again we want to work on collaboration. We want to be able to make sure that every member of the team is working with the same context and moving in the same direction so we cut out all of those variables.

[![Thumbnail 1790](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/1790.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=1790)

[![Thumbnail 1800](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/1800.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=1800)

To keep things moving here, I'm going to move from the design document now and I'm going to move on to the implementation plan.  While it's doing that, if we have more questions, I can certainly answer those. 

### Integrating with Jira Using MCP Servers and Agent Hooks

So the question is, how does this interact with something like Jira for product management and similar use cases? What does the interaction look like? As an organization, my product managers are writing their user stories in Jira, and I want to be able to use Kiro and development, but I don't want to create multiple sources of truth. I don't want to take what's in Jira and replicate it into my repo and then have to deal with drift and the potential of things splitting apart.

[![Thumbnail 1850](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/1850.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=1850)

The way you solve for that is twofold. First, you can install an MCP server.  I can install the Jira MCP server and integrate that with my Jira project. I can enter my credentials, use a remote MCP server or a local one, and enter the details for my Jira project. Then in the prompt, I can say, go get the user story ABC, or go get the user story for adding the authentication module to my application and pull that in. What that does is it goes in and gets the information from Jira, pulls that information in, reads it, and uses it to create the spec.

That's how I bridge the gap from Kiro to Jira, but that doesn't necessarily entirely solve my problem. It does get me access to that information and helps me build the spec so I don't have to write or copy paste all that information into the prompt block. But what happens if I make a change to the design document or the requirements document? What if I want to tweak one of these user stories or make an adjustment to one of these acceptance criteria? I want to be able to reflect that information back into Jira so that my data stays in sync and I'm not creating that drift situation.

The way I do that is using the last feature of Kiro that we haven't talked about yet, which is agent hooks. An agent hook is essentially an event-driven prompt. I take a prompt, and in this case it would be, whenever there's a change to my requirements document, I want you to summarize that change and reflect it back to the appropriate user story in Jira. I want you to run this prompt automatically whenever there's a change to a requirements.md file. So whenever you detect a file save event on a requirements.md file, summarize the change and push it back to the appropriate Jira user story.

What this does now is it creates a circular feedback loop. In the prompt, I say go get the details for the user story related to my auth module and pull that in and generate the spec for it. Then when I go and make a change to one of the acceptance criteria in that spec, my agent hook says, I detect you made a file save event in your requirements document. I'm going to go and summarize that and push that change back to Jira. That connection is happening via the MCP server. The MCP server doesn't just allow me to read information; it also allows me to write, assuming I have the correct permissions to do so.

It summarizes and pushes it back, and so now my user stories are staying in sync with my third-party tools. Things like Jira can be managed that way. I can also do this if a lot of companies have their design standards or software development standards documented in something like Confluence. They have an internal wiki or a SharePoint server that lays out how we do design, how we do software development, and all of those things. We can solve for that as well with an MCP server that connects to that and then a steering file that says, whenever you generate a design document, make sure you go and refer to our design standards or our architecture standards available at this MCP server and use that information.

[![Thumbnail 2080](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/2080.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=2080)

### Implementing the Task List and Generating Code

That way you're not just inventing some standard for how you want me to do software development. Use the standards that you've already established. That's how you would go about creating that feedback loop. We can see here now that we've created our requirements, we've created our design, and now we've  created our task list. Our task list here is essentially the project plan. What are the things that I need to do to go and implement these requirements to this particular design standard?

[![Thumbnail 2100](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/2100.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=2100)

What Kiro comes back with is this list of things that need to be implemented, and it's fairly exhaustive.  We have seventeen to eighteen tasks in this list, and you can see that some of them are grayed out, some are bold.

[![Thumbnail 2110](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/2110.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=2110)

Some of our tasks have subtasks.  For example, task two has task 2.1, 2.2, and 2.3. What that means is that some of these tasks are optional. Kiro is going to make a distinction here for me now. It's going to say, all right, well, are you building an MVP? Do you just want something quick and dirty that you can test out and see what it looks like, or are you building a production-grade application, in which case we need to make sure we cover all the bells and whistles?

[![Thumbnail 2160](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/2160.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=2160)

It's going to ask me here in the task or the execution log, which one are you making? Are you making a quick MVP or are you making a comprehensive production app? Since we're pressed on time here, I'm going to say we're going to make an MVP and I'm going to leave those things optional.  Really, those tasks are around testing and documentation. Our quick and dirty MVP application here doesn't need a robust unit testing and documentation strategy for it. We just want something that we can test out and give it a try.

If we look at these individual tasks here now, we can see that each task has a checkbox next to it that's going to track our progress. It's going to tell us if this task is done, if it's in progress, or if it hasn't been started yet. It's going to lay out some of the details that the task involves, and then in blue at the bottom, it's going to say which of the requirements we're fulfilling by doing these particular tasks. So we're going to get some traceability here from the requirements to the actual implementation.

[![Thumbnail 2220](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/2220.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=2220)

The first task here has a button at the top of it that says start task. When I click that start task button, it's going to switch from spec mode and it's going to switch into vibe mode.  When I click the start task button, it's actually going to go and start producing the code to implement this. This is going to involve running commands. It's going to need to be able to set up React. It's going to need to be able to configure TypeScript. It's going to have to install the dependencies, and you can see here now that it's going to get started on that.

It's going to start out by running the create Vite command and it's going to ask me for my permission to do so because it's about to run a command on my command line. It's going to make some changes to my local code or to my local environment, and I'm going to have to approve this. I can either accept this command, add this command to a trusted list of commands essentially saying I'll give you permission to this and don't ask me about this again, so the next time you come across a command that looks like this, go and do it automatically without asking me. I can reject the command, or I can modify the command.

To keep this simple, we're going to go ahead and tell it to run the command. We can see right here it ran into a problem. I have Node installed. Why is it not finding it? Well, in this effort to be helpful here, it's going to try and figure out how to do this automatically without the fact that I have Node installed. We're going to let this run and see how it goes. Essentially, what it's going to do here is it's going to kick off and you can see that it's running in the terminal window here at the bottom.

[![Thumbnail 2340](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/2340.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=2340)

[![Thumbnail 2350](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/2350.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=2350)

 It's going to start to generate the files that are necessary. So it's creating the Vite config file, the TypeScript config file, a git ignore file, the package.json, and all of the different things that are necessary here. It's creating our main file, our app.tsx file, our index. It's going to go through and create the structure for my application. If we switch over to the file explorer here,  we can see that it is generating all of the different files in our repository here. So we're getting all of these things built out for us as it goes along, and we'll figure out why it can't find Node here in a moment.

[![Thumbnail 2370](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/2370.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=2370)

It's going to go through this and you can see in the task list here that it marks this task as in progress.  We've got a little hash here in the checkbox denoting the fact that this is in progress, and we can view the changes here that are happening in a git diff. If I click on this, I can see all the different files that are being modified and the changes that are being made to them. Since we're starting everything from scratch, this is not going to be a particularly exciting diff to look at, but you can see here exactly what's happening.

[![Thumbnail 2380](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/2380.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=2380)

[![Thumbnail 2390](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/2390.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=2390)

[![Thumbnail 2400](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/2400.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=2400)

 When it finishes, we'll be able to look at the execution log as well.  So now you can see that the task is completed.  We can view the changes and we can view the execution log.

This means we can come back and see exactly what happened during executionâ€”what commands were run and what the results were. Notably, we'll discover that I don't have Node installed on my machine and the issue that created, and so it works through that. At the end, it also tells me how many credits were used and how much time it took to run. This particular task took 2.3 credits. You'll note the decimal there. Credits can be consumed in partial fractions, so it's not going to charge me for 3 credits; it's going to charge me for 2.3 credits rather than rounding up. It took 2 minutes and 59 seconds to complete.

We've got our task here, and if we come back to the file explorer, these files are captured in the repo. Now I can do a git commit and check this code into my repository and say, here are the specs that I'm working from. If I have multiple developers, I can say I want this developer to do task one, this developer to do task two, and this developer to do task three. I can divvy out the workload, but they're all working from the same requirements document, the same design document, and the same task list, so we're all moving in the same direction.

If we had an existing codebase here, we could say they're all working from the same steering documents as well, so they all have the same understanding of that core codebase. We're not relying on three different inferences of the LLM to draw the same conclusions about that existing code. It's all happening and it's documented and it's shared across the team, so we get that collaborative nature that we were talking about.

[![Thumbnail 2520](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/2520.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=2520)

### Creating Agent Hooks for Automated Workflows

Now, somebody asked about what we do with Agent Hooks.  With an Agent Hook, I can come in here and say I'm going to create an Agent Hook. I'm going to say whenever a change is made to a requirements.md file, summarize the changes and reflect them back to the associated Jira user story. I'm going to kick this off and tell Kiro to go and create a hook that does this. I specified what I want the hook to doâ€”I wanted to summarize changes and reflect them back to Jiraâ€”and I told it what files I care about, namely the requirements.md file. It's going to go off and do the rest.

[![Thumbnail 2550](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/2550.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=2550)

That looks accurate.  So we can see here in the hook panel, it's created a hook with the title "Requirements to Jira Sync." It's created a description. It's going to monitor the requirements.md files and automatically summarize those changes and reflect them back to the associated Jira story. It's going to look for a file save event. There are a couple of different options here. I've got file created, file saved, file deleted, or a manual trigger. Essentially, a manual hook is just a saved prompt that I can run whenever I want to kick it off.

It's going to tell me the file paths to look for. It's going to look for anything called requirements.md. I could tell it to look for any file in a particular directory. I could add multiple different things that I want it to look for, and then we get the actual prompt itself. This is the prompt that it generated based on the input that I gave it. So a requirements.md file has been modified. Please analyze the changes, summarize them in a clear and concise way, identify the associated Jira story, and then push the changes up to that Jira story when you're done.

[![Thumbnail 2580](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/2580.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=2580)

[![Thumbnail 2670](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/2670.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=2670)

We've got an Agent Hook, and just like my specs and my steering files, these hooks get stored inside the .kiro directory, so I've got my hooks here as well.  What that means now  is that all of the users on the team have the same hooks. All the developers now have the same specs, the same steering files, and the same hooks. Everybody is working from the same set of information, and this is how we solve for scale, how we solve for collaboration, and how we solve for visibility into the actual understanding of what the LLM is going to doâ€”how it's going to behave, what things it's going to perform, and how it's going to actually perform them.

I want to open it up for some more questions. We are unfortunately not going to have enough time to actually build this entire application in the next 15 minutes, but Kiro is spitting a little bit of gibberish here anyway. So the question is how deterministic is this process. LLMs are, as we've said a couple of times now, non-deterministic by definition. The way in which you make them more deterministic is to provide more context. The more guardrails, guidelines, and context you can provide, the more consistent the output you'll get.

For instance, if I say generate a web application and that's all I say and I ask that five times, I'm going to get a web app, a React application, a Python application, a Rails application, maybe another React application. I'm going to get a lot of variability there. But if I add context and I say generate a React application, all five times it's going to generate a React application for me. So the point being, the more context I provide and the more detail I lay out, the more deterministic the output will be.

The challenge with that is that historically writing the context of these spec files into the prompt every time I want to do something is not particularly scalable. The more expansive I'm trying to build, the more details there are and the more gaps I have to fill when I generate that prompt. I have to rely on every member of the team to do that, which is not realistic. So what we're trying to solve for here is providing that context up front and giving everybody visibility into what that context is and the opportunity to change that context if they deem it appropriate before we've gone off and actually done the work.

Once we have that design file, once we have those requirements files, once we've laid out what the tasks are, and once we've coupled that with our steering files, we've got a fairly high deterministic output in the sense that we've covered all the gaps and closed a lot of the variables that the LLM would normally have to go off and figure out for itself. It's still not 100% deterministic. There's still room for variability, and that's why we don't want it to remove the human in the loop.

We don't want Kiro to just take this code and deploy it into production unseen. We still want to do our pull requests and code reviews and those types of things. What we are trying to solve for here is a lot of wasted time reviewing code that is obviously wrong because the context wasn't specified up front. By doing this work up front, we can cut down on the amount of wasted code generated and improve the likelihood that a particular pull request can be approved as is and merged in.

The other thing I'll say to that too is the actual code that's written. If you were to take the spec file and requirements and blow away all the code and regenerate it, it's going to look different each time, but that's implementation details. The requirements stay the same. How those requirements are satisfied is strictly implementation details. What we're doing here, in essence, is abstracting away the details of the code and focusing on the business requirements and the acceptance criteria because the actual specifics of the code implementation, while able to change, is not as important as satisfying the requirements. That's where you're going to see the consistency.

[![Thumbnail 2940](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/2940.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=2940)



I'm going to start over here because they've been ignored so far. What do you have? How do you like hooks?

[![Thumbnail 2950](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/2950.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=2950)



Hooks across projects are shared by the fact that they're checked into the repo. You asked how you share them across projects, not across developers. The way in which you share hooks across projects at the moment is that you have to copy that hook into another project. You take that JSON file and you copy it into another project. That's not a particularly scalable approach. We do have some things on the roadmap and in the pipeline to make those things more manageable at the organization level to be able to push those down from an administrative level. But today, in order to share hooks across projects, you need to replicate the JSON file into the appropriate repo.

### Q&A: Determinism, Reliability, Specs Management, and Best Practices

My question was: How reliable is Kiro? How often do we run into issues with it?

Well, normally I would tell you that it's very reliable. Obviously, it struggled on the generation of that agent hook. The issue with Node, I think, is actually a local problem on my machine, which I will figure out after this session. But generally speaking, Kiro is fairly reliable in the sense that it has a good understanding of the source code and it generates source code fairly reliably.

You'll also find in many cases when it does run into a challenge, and you can see this actually in the task that we completed, it ran the command and it said, "You don't have Node installed," and so it actually self-corrected there and said, "Well, let me try something else." It tried that and it didn't work either because I don't have NPX installed either apparently. Then it said, "All right, well now I'm going to go and just generate the code for you manually, so I'm going to skip that step and keep going."

The point I want to make there is that these LLMs are designed to be helpful by nature, so they want to produce results for you. Given the context that's there, they're getting increasingly intelligent in how they work. They're going to try a particular strategy, and if that strategy doesn't work, they're going to move on to a different strategy and problem-solve along the way. Generally speaking, Kiro is pretty effective in that regard in saying, "Hey, this is the approach that I want to take. Wait a minute, this approach didn't work. Let me try a different approach and see if that solves the problem, and I'm going to keep going."

At any point I can step in and intervene and say, "You know what, you're right, I forgot to install Node, so let me pause you right here and go take care of that and then pick it back up again and have you keep going," rather than trying to solve for something that I obviously know is not right. So generally speaking, Kiro is pretty reliable in that sense, notwithstanding this particular example.

[![Thumbnail 3150](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/3150.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=3150)



If I want to make a change to a requirement, do I directly do it in that document? If I'm directly making the change, yes, Kiro will check whether it will break anything. So the question there was, if I need to make a change to the requirements document. In this particular case, we have this spec and we've actually started building the code. We've already run the first task in the task list. So what happens now, as is common in life, somebody comes back and they say, "Hey, you know, this requirement changed. We don't want red, we want blue. We need to make an adjustment." What do I do? How do I actually implement that? There are two ways you can do that.

You can actually come back into the prompt and say, "Here, I need to make an adjustment to this spec. I need to change it from red to blue," and Kiro will go off and make that change for me. Or I can manage it, or I can change it manually. I can say, "You know what, I want to get the planned date here and also a planned location." If I put that change in there manually like that, what I can do is hit the refine button up here.

When I hit the refine button, what Kiro does is it actually goes and evaluates the change that I just made to that requirements document. Not only is it going to refresh the requirements document to make sure that this is logically consistentâ€”because I only changed it in one acceptance criteria, the likelihood is that this is probably going to need to be reflected in a couple of different acceptance criteriaâ€”it's also going to make changes to the design. In the design document we laid out what the models looked like, what the database tables looked like, all of those different things.

Well now we've gone and added a new attribute. So we're going to need to make an adjustment to that model. We need to reflect these changes downstream. We make the change not only in the requirements but also in the design document. And given that, you know, if we had gotten far enough in the task list that we'd actually implemented those tables already, we'd actually written the code for them, we would then need to create another task to go in and modify those tables. We want to reflect that in the task list as well.

[![Thumbnail 3300](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/3300.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=3300)



So what Kiro does when we hit the refine button is that it says, "All right, I can see that you've made a change. I've gone through and I've validated in the requirements. Now I'm going to move on to the design phase and I'm going to make the adjustments there and I'm going to carry that downstream." If I need to create more tasks because we've already implemented this piece of the code, then I'll add some new tasks. If we haven't implemented this yet,

then I can just modify the task and say, "Hey, do it the new way when you implement it." So I have a couple of different strategies there for how to deal with this. But generally speaking, that's how you would adjust for that. You'd make the change. You can either ask Kiro to make the change for you in the prompt, or you can do it manually and then hit the refine button and let Kiro run it through downstream.

And it's going to trace that downstream. I see that it created a few architectural factors to understand these diagrams if I provide my information. So two strategies there: you can create architectural diagrams and the design document using ASCII text here. You can provide ASCII text files that have similar design diagrams and it can infer those. You can also draw a design document on a whiteboard, take a picture of it, and upload it as an image file, and then have it say, "Go and implement this architecture diagram based on this image." It will evaluate the image file, infer the contents of that image, and actually do the spec or the implementation based on that.

So you can do it based on either ASCII text implementations or you can do it based on an image file like a PNG or a GIF or whatever the case may be. If you have a Lucid Chart, you could do that most likely with a screenshot uploaded of the Lucid diagram and then use that.

I have a question. You said that a project can have more than one spec, right? Correct. This is the only part. What do you mean? How do you define a spec? So I want to add an authentication layer to my fitness tracker app to keep track of which user is doing the activity. I'm going to again put this into spec mode. I'm going to type in my prompt here and I'm going to hit go, and what it's going to do here is create another spec for me.

[![Thumbnail 3500](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/3500.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=3500)

[![Thumbnail 3510](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/3510.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=3510)

[![Thumbnail 3530](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/16d4aa6c747bf008/3530.jpg)](https://www.youtube.com/watch?v=VRw3g-v4B00&t=3530)

I've got a couple of things running here. It's going to create another spec. So the specs here are laid out. I've got a spec directory and I've got a subdirectory here for the fitness activity tracker. That subdirectory there has my design file, my requirements file, and my task file in it. Now I've kicked it off and I've asked it to generate a new spec for my authentication layer.  So now I'm going to add a new feature to my existing application.  And so now what it's going to do is start building out a new spec for me, and it's going to say, "Oh, it's actually making changes to the existing spec for me because I haven't implemented it yet." 

If it were to build another spec, it would just create another subdirectory there with another three new files: a requirements file, a design file, and a task file. Get off state requirements. And how do you? Are there best practices that I started? Sure, the question is around best practices. How do you? What's the best way to think about a spec or how to treat it? Generally speaking, the way, and Ryan, you may have different opinions on this, but generally speaking, the way I treat a spec is as a bounded feature.

In this case, an authentication layer, and that feature has a specific set of things that I want to get done. If those things are not done yet, so in this case we've got a whole lot of tasks that haven't been implemented yet, and something changes. I need to add another field. I need to change a color. Then it makes sense to go in and modify that spec. I add that feature or whatever. If that spec is done, all the tasks are done, they're finished,

we've completed that spec. Now if you come to me and say you want to add another thing or make a change, generally what I would do is create another spec. That spec is done, it's finished, we're going to put a bow on it, slide it over to the side, and now we're going to create a new spec for this new thing, whether it's a change or a new feature. I generally try to treat my specs as contained entities. When I've done the work there, I slide it over and say this is done. If I need to make any more changes, I'm going to create a new spec and deal with it there so that I have this running list of specs.

You technically can go back and modify an existing spec even if all the tasks are done, but I find that makes it really muddy to keep track of the work I've done and how I've done it. So I don't know if you have any other thoughts on that, but I definitely think it's more art than science. There's obviously going to be general guidance. Don't put too much into it. You have to get a sense. What you put into a spec also influences how you organize around that spec. While there are collaboration aspects to it, I don't think I can divvy up a spec to three different teams. Think about the boundaries of the way you work and how you work.

I think to emphasize the point is clear exit criteria. It's not an ongoing thing. It's a defined thing that we know has concrete, discrete acceptance criteria that we can call done. Then we ship it before we create another one. They're not long-living. They're organized around how we are organized. I wouldn't put in more than, I don't know, 21 in Fibonacci. Nothing too big.

What do you do with the developers who are using something other than VS Code and who would rather stick with their VM application than migrate to something newer? It's a fair question and there isn't a great answer for it. Q Developer has a number of different plugins that can be installed. We have a JetBrains plugin for Q Developer. What we have found though is that trying to maintain plugins for every conceivable IDE under the sun is a very complicated process and you end up with a lot of leapfrogging and lack of parity between them. So the strategy we have generally gone to is to recommend the CLI.

The CLI allows you to do a lot of these things directly from the terminal, and you can open up a terminal window in JetBrains or in Eclipse or in VS Code, the native version of VS Code or in Visual Studio, and you can do whatever work you want to do there and benefit from the generative AI capabilities in the CLI. That's generally the strategy we would propose there. Understanding that that's not entirely the same experience as what you have here, it allows you to keep your preferred IDE and still get some of those benefits. It does come with a CLI.

How do you prevent Kiro from hallucinating? Hallucinations really are a product of the model, how good the model is, the training data in the model, and then the context that the model has in responding to the prompt. The models that we are using have all been vetted, so Kiro doesn't have a bring your own API key strategy to it. We have a predefined set of models. We have support right now for Sonnet 4.5 and 4. We have support for Haiku and we have support for Opus.

Those models are there and we've vetted them and we've made sure that they generally understand the context well. Then the steering files and the spec files add the necessary context. It doesn't guarantee that you won't see hallucinations, but it does reduce the load fairly substantially. We are looking at local LLMs, but if we do that, they will be defined the same way we define our remote LLMs as well. So there will be a defined set of LLMs that you can use that would work there.

I think we have run out of time here. I appreciate everybody coming out. Hopefully you found this useful. We didn't succeed in building a fitness application, but hopefully you get a sense for how you would approach that and walk through that process. I will make sure I have a note installed next time. Thank you, everybody.


----

; This article is entirely auto-generated using Amazon Bedrock.
