---
title: 'AWS re:Invent 2025 - AWS infrastructure as code: A year in review (DVT203)'
published: true
description: 'In this video, AWS product managers Aakash and Praneeta present infrastructure as code innovations at re:Invent 2025. They cover CloudFormation''s new Drift-Aware Change Sets for managing configuration drift, pre-deployment validation to catch errors during change set creation, and CDK refactor for safely restructuring applications without data loss. The session introduces CDK Mixins library for composable abstractions, CloudFormation Hooks integration with AWS Controls Catalog for proactive security controls, and stack set dependencies for multi-account deployments. They also discuss AI integration through the AWS MCP server, which provides agents with AWS best practices and validation tools to improve AI-generated infrastructure code quality and reliability.'
tags: ''
cover_image: 'https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/0.jpg'
series: ''
canonical_url: null
id: 3085364
date: '2025-12-05T05:20:32Z'
---

**ðŸ¦„ Making great presentations more accessible.**
This project enhances multilingual accessibility and discoverability while preserving the original content. Detailed transcriptions and keyframes capture the nuances and technical insights that convey the full value of each session.

**Note**: A comprehensive list of re:Invent 2025 transcribed articles is available in this [Spreadsheet](https://docs.google.com/spreadsheets/d/13fihyGeDoSuheATs_lSmcluvnX3tnffdsh16NX0M2iA/edit?usp=sharing)!

# Overview


ðŸ“– **AWS re:Invent 2025 - AWS infrastructure as code: A year in review (DVT203)**

> In this video, AWS product managers Aakash and Praneeta present infrastructure as code innovations at re:Invent 2025. They cover CloudFormation's new Drift-Aware Change Sets for managing configuration drift, pre-deployment validation to catch errors during change set creation, and CDK refactor for safely restructuring applications without data loss. The session introduces CDK Mixins library for composable abstractions, CloudFormation Hooks integration with AWS Controls Catalog for proactive security controls, and stack set dependencies for multi-account deployments. They also discuss AI integration through the AWS MCP server, which provides agents with AWS best practices and validation tools to improve AI-generated infrastructure code quality and reliability.

{% youtube https://www.youtube.com/watch?v=_4hvWns9ICY %}
; This article is entirely auto-generated while preserving the original presentation content as much as possible. Please note that there may be typos or inaccuracies.

# Main Part
[![Thumbnail 0](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/0.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=0)

### Welcome to AWS re:Invent 2025: Infrastructure as Code Year-in-Review

 Hello and good morning, everybody. It is so good to see all of you here on day one of re:Invent 2025. Welcome, welcome again. In 2025, infrastructure as code is not just an option for cloud development; it is the go-to mechanism for building and managing serious applications in the cloud. Today, in the AWS infrastructure as code year-in-review session, we'll tell you about all things infrastructure as code in AWS and share some new innovations that will multiply your deployment speed on the cloud while strengthening your safety and security posture.

I hope those morning coffees have kicked in by now because we have some exciting stuff to cover today. For those of you who are still figuring out your bearings, we'll start the session by clarifying who we are, who the session is for, and what you can expect to get from this session. My name is Aakash, and I am a senior product manager for the AWS infrastructure as code, or IAC, team. I lead some of our core infrastructure management products that help both developers and platform engineers, and my focus is on helping our customers scale their AWS usage with safety.

I'll now pass the spotlight to Praneeta. Hey everyone, welcome to the first session for many of you. I'm Praneeta Prakash, a senior product manager. I focus on developer experience in our developer tools organization. My products are Cloud Development Kit, CDK, which many of you might be familiar with, and Amplify for front-end web development. I'm really excited to be here speaking to you all today.

[![Thumbnail 110](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/110.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=110)

[![Thumbnail 130](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/130.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=130)

 Now that you know a little bit about us, we would love to know a little bit about you. Let's do a raise hands exercise. Clearly you all love infrastructure as code because you're here on a Monday morning, so we're not going to ask that. But I want to know how many of you are here because your organization is trying to scale cloud usage  without creating a compliance horror movie. Scaling usage, there you go, awesome. Or you're here because you want infrastructure to be secure by default instead of secure by oops, I forgot. There you go, icy hands. Come on, guys, energy. Where is the coffee set coming in still? And maybe you're deep in IC like me, you like to build infrastructure as code applications, and you just want everything to go lightning fast. I've got a lot of developers in the room. Hello, friends, you're among friends.

[![Thumbnail 190](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/190.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=190)

So good news is we are addressing all these requirements today with our talk, so you're in the right room. The bad news is we are an hour away from lunch, but we'll keep this interesting.  The agenda for today is we're going to do a brief refresher on what is IAC. We want to make sure we're speaking the same language here. Then we're going to move into the latest launches we've made in speeding up or improving developer experience with our IAC tools. Then we're going to go into how IAC helps evolve applications safely as applications are ever-changing, and this is really important.

[![Thumbnail 250](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/250.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=250)

[![Thumbnail 260](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/260.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=260)

We'll talk to our platform and security folks on how they can standardize application development, set standards, put guardrails in their organizations to help their development teams. Finally, we're going to approach how we think IAC is changing with all the new trends around AI coming up and how our teams are addressing that as well. So let's get started with the first section.  Thank you, Aakash.  Now let's spend a few minutes revisiting the fundamentals of IAC because they're more important than ever today for application development.

### Understanding Infrastructure as Code: From CloudFormation to CDK and the Democratization of Cloud Development

Very simply, IAC is the practice of modeling your infrastructure through configuration files or templates. You can see an IAC template on the left of your screen. It is defining an S3 bucket resource and certain properties of that bucket. You can deploy this IAC template with an infrastructure as code tool, which will convert the template into a set of control plane API calls and orchestrate the calls on your behalf. So at the end of the deployment, you have a correctly configured S3 bucket in your environment.

[![Thumbnail 300](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/300.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=300)

 AWS pioneered IAC in 2011 with the launch of a service called CloudFormation. CloudFormation was designed to address three critical needs that all customers face.

When they scale their cloud infrastructure, first, customers want to replicate infrastructure in new AWS accounts and regions, either for expanding their business, for creating test environments, or for disaster recovery. Second, customers want to make safe and predictable updates to running applications that can contain hundreds of interdependent AWS resources. Third, customers want to version infrastructure states and audit changes to their infrastructure. If you relate to these problems, the good news is that Infrastructure as Code can solve all of these problems because Infrastructure as Code templates are repeatable, they are versionable, and they help you achieve a desired infrastructure state with consistency.

[![Thumbnail 360](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/360.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=360)

[![Thumbnail 380](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/380.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=380)

Let's take a look at the AWS Infrastructure as Code portfolio.  At the center of our portfolio is a service called CloudFormation, which is our core Infrastructure as Code service that accepts JSON or YAML templates. You can pair CloudFormation with a proactive controls tool called CloudFormation Hooks, and we'll talk about Hooks a little later in the session. Underneath CloudFormation is a service called the CloudFormation resource registry.  This service connects CloudFormation to hundreds of AWS features and capabilities, like S3, Lambda, and DynamoDB. As AWS develops new features and capabilities, they are immediately integrated into the registry so that you can access these capabilities through CloudFormation.

[![Thumbnail 400](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/400.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=400)

[![Thumbnail 420](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/420.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=420)

We recently externalized the benefits of the registry through a service called the AWS Cloud Control API.  This allows third-party Infrastructure as Code tools like Terraform and Pulumi to provide the same coverage for AWS resources that CloudFormation offers. On top of CloudFormation sit these opinionated higher-level tools for infrastructure management.  This includes tools like the AWS Cloud Development Kit and AWS Amplify. How many of you here use CloudFormation through the Cloud Development Kit, or CDK? As you can see, the CDK is our most popular higher-level tool.

[![Thumbnail 450](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/450.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=450)

What the CDK does is it allows developers to model infrastructure with a programming language of their choice.  You can use CDK through TypeScript, JavaScript, Python, C#, Go, and several other languages. With the CDK, developers can continue to use their existing autocomplete, linter, and testing tools for development. They can also use familiar concepts like looping and inheritance when they are defining infrastructure. On top of all this, the CDK offers a powerful capability called constructs.

[![Thumbnail 500](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/500.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=500)

[![Thumbnail 510](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/510.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=510)

You can think of constructs as packaged infrastructure components that are infused with AWS best practices. Developers can now declare infrastructure without having to understand every single low-level setting. The CDK offers three levels of constructs.  L1s are constructs that map most closely to the underlying CloudFormation resource types. L1 constructs in CDK are precise and granular, but they can also get verbose.  L2s are a higher level of construct that combine multiple resources, often of the same service, into a functional component. An example L2 could be an S3 bucket component that comes equipped with the logging bucket and auto-deletion capabilities.

[![Thumbnail 530](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/530.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=530)

On the other end of the spectrum are L3 constructs, which combine multiple resources into an entire architecture.  An example L3 construct could be an end-to-end serverless application. As a developer, L3s are super easy to use, but they're not as flexible as L1s. We'll talk about constructs and their trade-offs a little later in the session. The key message on this slide is that the CDK is full of capabilities that make it easy for application developers to get comfortable with the cloud and with Infrastructure as Code.

[![Thumbnail 570](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/570.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=570)

That is a great segue into our next insight about Infrastructure as Code. Infrastructure as Code is now the front end to the cloud for all teams in your organization.  This democratization of Infrastructure as Code across stakeholders is being driven by three factors. First, today platform teams want to decentralize infrastructure management responsibilities, which means that platform teams want application teams to independently provision and manage applications. This obviously helps organizations to move faster. Second, platform teams are building developer platforms that help application teams to run Infrastructure as Code workflows with confidence.

This includes the creation of golden paths on top of Infrastructure as Code constructs, as well as the enforcement of proactive controls so that issues are caught before deployment. The newest trend on this slide is the rise in Gen-AI tooling, which makes it easier than ever to generate Infrastructure as Code and ramp up on Infrastructure as Code concepts. More developers than ever are generating Infrastructure as Code today.

[![Thumbnail 640](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/640.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=640)

Now that we've established that Infrastructure as Code is everyone's business,  and it is so fundamental to how our customers use the cloud, we know that any evolution in Infrastructure as Code can transform the entire cloud development experience for our customers. We strive to make Infrastructure as Code faster to build, easier to manage, and safer to govern. We'll talk about these themes through the session now.

[![Thumbnail 700](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/700.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=700)

### Accelerating Developer Workflows: New IDE Features and Pre-Deployment Error Validation

So on that note, Praneeta, can you share some of our innovations that help developers build faster with Infrastructure as Code? I was a developer before I was a product manager, and I was one of the lazy developers who wanted all the tooling set up correctly to help me move fast. I know we have lazy developers in this room. Remember the days before Infrastructure as Code when provisioning infrastructure  was days of waiting on tickets that you handed off to your platform teams? You never knew if you would get what you asked for. Now it is a single command that can spin up complete stacks of compute, networking, and databases.

You can set up isolated stacks to test your application code quickly, and no one is allowed to say "but it works on my machine" anymore. However, with Infrastructure as Code, there is a learning curve today, especially with AWS Infrastructure as Code, because there are many concepts for developers to know about before they can even start using it. We are trying to make this on-ramp easier for our developers.

[![Thumbnail 750](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/750.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=750)

[![Thumbnail 780](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/780.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=780)

[![Thumbnail 790](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/790.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=790)

Let's look at a typical developer workflow. If you are a CDK developer,  you have an application in mind and you are looking for patterns in the CDK constructs that are available online to compose them together into an application and make it work for what you need. You use the CDK CLI to take your application written in a higher-level programming language like TypeScript and turn that into CloudFormation templates and assets.  If you prefer to write declarative code to define your infrastructure, you start at this step, building your CloudFormation template.  Then you call the CloudFormation service to deploy and provision your infrastructure for you. This is the typical developer workflow today.

[![Thumbnail 810](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/810.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=810)

[![Thumbnail 820](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/820.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=820)

[![Thumbnail 850](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/850.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=850)

[![Thumbnail 860](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/860.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=860)

While this slide talks about CDK, I want to focus on developers that are building their CloudFormation templates by hand.  Then I will move on in the next part to talk about the provisioning and deployment improvements that we have made. Let's start with authoring.  If you are authoring CloudFormation by hand today, you think about the services you want to compose together into your template, and you look at multiple AWS documentation pages. You start with learning about S3 if you are using S3, and then you go into learning about all the properties that you can configure in S3. Then you look at the CloudFormation docs to make sure you know the syntax,  and you put in valid syntax in the property values. This is a lot of context-switching for developers. You are going back and forth between your IDE  and many tabs on your browser, which is why we are really excited to bring that experience to you within the IDE with the AWS Toolkit plugins.

[![Thumbnail 890](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/890.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=890)

Now, the Toolkit plugin supports a CloudFormation IDE experience today, and you can use that on Visual Studio, Visual Studio Code, and IntelliJ IDEA. The three main features of this plugin are autocomplete and hover features.  If you define a resource, you see documentation pop up, and you see properties that you would need to define for that resource. The plugin also automatically runs

[![Thumbnail 910](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/910.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=910)

[![Thumbnail 930](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/930.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=930)

 linting tools for you. It catches syntax validation errors in the IDE in real time, which is really helpful, and you can instantly fix them with helpful documentation on how to resolve the issue. The plugin also catches security best practices  being missed in the code and warns you about them. In this example, we're trying to assign a public IP address to a VPC. This makes the authoring experience much simpler for CloudFormation. Please let us know how this works out for you.

[![Thumbnail 950](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/950.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=950)

[![Thumbnail 960](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/960.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=960)

Let's move into deploying and provisioning Infrastructure as Code.  Now, your typical workflow looks something like this: you create your change set, execute it in CloudFormation, deployment starts, and possibly it finds errors, then it has to roll back to the previous safe state.  This is a really long feedback loop for the developer trying to get the job done. Every time the developer makes a change to their template, they need to package, deploy, and wait. Once an error is encountered, they need to redeploy the fix and repeat the process.

[![Thumbnail 1010](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1010.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1010)

[![Thumbnail 1030](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1030.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1030)

[![Thumbnail 1070](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1070.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1070)

The main problem is that many errors, like naming conflicts, property syntax errors,  and resource conflicts, are only discovered during deployment. For many organizations, this could also mean waiting for pipeline deployments to fail or having your platform engineer reach out to you about the failure.  We are excited to shift this error validation left so that you can detect many of these errors during change set creation time. We're supporting three main types of errors today: resource naming conflicts, invalid property values, and deletion of non-empty buckets.  We will be adding more types of errors over the next year. Before deployment even starts, you will have an alert from CloudFormation that tells you which possible resources will fail during deployment.

[![Thumbnail 1090](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1090.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1090)

You have a nice console experience as well, with a new tab called Validation Results.  This lists all the resources that are predicted to fail during deployment, along with a detailed description and the line of code where that error originated. Try this out today.

[![Thumbnail 1120](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1120.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1120)

### Managing Infrastructure at Scale: Introducing Drift-Aware Change Sets for CloudFormation

Thanks, Praneeta. The revision error loop has been long for Infrastructure as Code, and it's exciting to see that what took hours to detect in the past can now be done in minutes or seconds.  Developers can now move faster. This also means that the size of your cloud environment will continue to grow. As your cloud environment scales, you will need large teams, and often multiple teams, to evolve and maintain that infrastructure in parallel.

[![Thumbnail 1140](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1140.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1140)

How do you prevent an explosion of complexity in this world, and how do you avoid those dreaded outages from happening?  Infrastructure as Code is your shield against chaos at scale because it brings the best of DevOps to infrastructure change management. With Infrastructure as Code, you can review code before it's pushed out, you can version infrastructure changes as they happen, and you can deploy infrastructure changes through structured CI/CD pipelines and test environments. In order to access these critical security and safety benefits, you need to keep your Infrastructure as Code up to date and well architected. Let's talk about what gets in the way of that and how we can mitigate those pain points.

[![Thumbnail 1180](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1180.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1180)

[![Thumbnail 1200](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1200.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1200)

Let's first address Infrastructure as Code drift,  which our customers tell us is their biggest challenge with infrastructure management today. To understand drift, imagine that you are a developer, and you are familiar with our best practices and on top of things. When you want to provision a new resource in your environment, you do that through Infrastructure as Code. You define an Infrastructure as Code template and you deploy it.  But you have a second developer on your team who is not as familiar with best practices. They need to change your resource and they need to do it quickly.

[![Thumbnail 1220](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1220.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1220)

So they go to the AWS Management Console and click their way into resource changes. Now the actual state of your resource has drifted away from the template definition of your resource.  This is problematic because once drift enters your environment, you could see unexpected changes in future Infrastructure as Code deployments, including reversals of critical fixes that you made for production incidents. You could also find it difficult to reproduce your application for testing or disaster recovery, and you are exposed to violations of compliance policies.

[![Thumbnail 1270](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1270.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1270)

In fact, customers have shared with us that some teams have accumulated so much drift that they have completely given up on managing applications with Infrastructure as Code and lost all of the safety benefits that come with it. That is why I am very excited to announce that CloudFormation has launched a new capability called Drift-Aware Change Sets that can help you safely manage drift and keep your infrastructure in sync with your templates. The way this works at a high level is when you need to deploy an updated Infrastructure as Code template on top of a drifted resource, you create a Drift-Aware Change Set and CloudFormation will compare your template to the actual state of your resource. 

[![Thumbnail 1290](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1290.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1290)

[![Thumbnail 1300](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1300.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1300)

[![Thumbnail 1310](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1310.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1310)

You will get a three-way comparison of the actual resource state, your new template definition,  and your last deployed template definition. So you can detect overwrites of drift and fix unintended overwrites in your template.  When you refine your template to show your desired state, you can execute the change set to bring your drifted resource in line with the new template definition.  The net result is that you have safely reconciled drift for your resource and brought it to its desired state.

[![Thumbnail 1320](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1320.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1320)

Let us unpack this with an example. Let us say that you have a malfunctioning application  that you build with Infrastructure as Code. Ignore the Infrastructure as Code template on the left for a secondâ€”I know it appears complex. Look at the diagram on the right. You have a Lambda function reading from an S3 bucket. Objects in the bucket expire every day, and there is a CloudWatch alarm on the bucket which monitors the number of objects in that bucket. But because this application is not working and you do not exactly know what is wrong, you would go to the AWS console and try out some fixes for this application.

[![Thumbnail 1350](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1350.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1350)

Here is what you do.  You go to the console and first increase the expiration of objects in the bucket to 100 days so that you can observe what data is actually flowing into the bucket. But you know this is going to trigger your CloudWatch alarm, so you delete the alarm temporarily. Then over time, you discover that the issue is with the timeout of your Lambda function, and increasing the timeout to 20 seconds gets your application running. The good news is that you know the root cause of your issue. The challenge is that your application is left in a broken state.

[![Thumbnail 1390](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1390.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1390)

[![Thumbnail 1410](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1410.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1410)

So how do you get back from here to a production-ready state? Well, now it is super easy with Drift-Aware Change Sets.  All you need to do is make the changes to your Infrastructure as Code template that you want to persist in your environment. In our case, we now increase the timeout of the Lambda function to 20 seconds. After we make this change, we create a Drift-Aware Change Set with CloudFormation.  Now CloudFormation is doing all of the heavy lifting for you. It is detecting that your CloudWatch alarm was deleted out of band and needs to be recreated in the deployment. It is detecting that your Lambda function has been changed out of band, and the template definition of the function has been updated to incorporate this change.

[![Thumbnail 1450](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1450.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1450)

It is also detecting that the S3 bucket has been updated out of band and needs to be reset to its template definition. You can zoom into the property level view for each resource. For example, for the S3 bucket, you can see that the actual value of your expiration setting is 100, while the value in your new template is just one. You can also see that this actual value is coming from an out-of-band change.  You can expand this out-of-band change to see what the value was in your previous deployment. So now you have a full picture of the story of your deployment.

[![Thumbnail 1460](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1460.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1460)

[![Thumbnail 1480](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1480.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1480)

### Evolving Applications Without Breaking Them: CDK Refactor and the New Mixins Library

That is it.  You just execute the change set, and your application is now back in a healthy state and is also in sync with your template. So that is how easy it is now to manage drift with Drift-Aware Change Sets. Now, I will pass it back to you to share how you can keep Infrastructure as Code up to date with new business requirements.  I love that drift is yesterday's problem. So I guess, how many of you have built an application, pushed it to production, and never touched it again? It is just not a thing in our industry, right? Applications are ever-changing, constantly evolving.

[![Thumbnail 1530](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1530.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1530)

[![Thumbnail 1550](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1550.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1550)

New product managers, new security guidance, and new requirements come in constantly, and you have to keep revisiting and modifying them. This used to be really hard to do with CDK applications until a recent launch, and I want to talk about that right now. So you have a CDK application.  It's possibly using a monolithic Lambda function, but it works, so why not? It's talking to three tables, it's doing its job, your customers are fine with it, and you don't want to fix something that isn't broken. Now you know there's tech debt, and you realize that you want to scale these three Lambda functions independently of each other.  It's also part of well-architected principles to not have monolithic Lambda functions. While you do that, you might as well move the CDK application code from L1s to using an L2, so you can configure your Lambda function in one way, in one place, and use inheritance to spin up three other Lambda functions. All good ideas, and when you try to do that, what happens?

[![Thumbnail 1610](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1610.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1610)

What happens when you try to deploy a changed application in CloudFormation? You lose your data. It will delete and recreate your resources because it does not know what refactoring is. Until we made that change with CDK refactor and CloudFormation refactor.  What this helps with now is it makes infrastructure as code development closer to how we think of software development to be. You can move your constructs, rename your constructs, and move resources between stacks within your application. You can upgrade your L1s to L2s, L2s to L3s without risking losing persistent resources or data.

[![Thumbnail 1660](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1660.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1660)

[![Thumbnail 1680](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1680.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1680)

This is offered as a feature on the CDK CLI with a CDK refactor command. We pass in the unstable flag today because it's an experimental feature in preview. When you change your application to where you want it to be,  and you run the CDK refactor command, what it's really doing is mapping the constructs in your deployed application to the ones in your local application. It recognizes that things have moved instead of being a replace action. Once you confirm this,  it tells CloudFormation don't redeploy anything. I'm just remapping the logical IDs to the infrastructure, to the physical IDs. You don't risk losing data in this process.

[![Thumbnail 1700](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1700.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1700)

[![Thumbnail 1710](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1710.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1710)

So try CDK refactor. If you have old CDK applications that need a little love,  you can now do that with CDK refactor. Let's move on to the next section, which is simplifying and governing IaC workflows.  Simplification, to me, means that developers can move faster with fewer decisions per deployment by using patterns or guardrails available to them. Governance, to me, means that platform teams can still retain control and set standards and share best practices without getting in the developer's way or slowing them down.

[![Thumbnail 1740](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1740.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1740)

[![Thumbnail 1770](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1770.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1770)

CDK has a really cool construct system, which I think the CDK users here are familiar with, but it helps you do exactly that.  It helps platform teams define constructs or blessed patterns that can be used by their developers, knowing that it adheres to the organization's best practices and security practices and compliance needs. Now, while the construct system is working really well  for a lot of our customers, there is a problem. How many of you have wished for more coverage on CDK L2 constructs? The problem with that is L2 constructs are fully built, opaque abstractions that contain a lot of logic within them, but they're not composable building blocks. Let me tell you a little bit more about that. We build L2 constructs for every service or feature that our customers use to build applications with.

[![Thumbnail 1810](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1810.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1810)

[![Thumbnail 1820](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1820.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1820)

[![Thumbnail 1840](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1840.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1840)

 While we don't cover all of AWS, we cover a lot of popular patterns in AWS with L2 constructs.  Your organizations, your platform teams take that, and if they don't think that the L2 meets their security and compliance needs, they extend it by adding or removing features to meet their needs. We call that custom constructs.  Custom constructs could be at the L2 layer or they could be higher level constructs that match your use cases, like secure API or data pipeline.

[![Thumbnail 1860](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1860.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1860)

[![Thumbnail 1900](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1900.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1900)

The problem with this is that every time  there is a new feature or service announced by AWS, you need to wait for the AWS CDK team to support that within an L2 construct or build a new L2 construct for it, which then goes to your platform team for them to extend or modify it, and then becomes available for you to use. For fast-moving organizations, that could be too slow.  So we wanted to look into how we can decouple innovation velocity from abstraction maintenance.

[![Thumbnail 1960](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1960.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1960)

We look at this L2 construct, which we like to call a walled garden. It has beautiful features in it that cannot be used independently of it. An L2 bucket, for example, is a combination of L1 resources, which wrap around CloudFormation resources directly. So it wraps around an L1 bucket and KMS key in this particular example. There's a lot more going on in there, obviously, but let's look at just encryption for this one.  The encryption helper adds all the wiring logic between your bucket and your KMS key for you, and if you had to define it on your own by hand, it would be a lot more lines of code. This does that for you, which is why L2s are really well-loved.

[![Thumbnail 1980](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1980.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1980)

[![Thumbnail 1990](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/1990.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=1990)

[![Thumbnail 2000](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/2000.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=2000)

The problem, though, is that a lot of services need encryption. So now we are repeating implementation across each service's L2 construct, doing a similar thing, and every time there's a new service, we need to redefine this  because we work through inheritance and not composition. We wanted to switch that around. We wanted to take the helpers out of the L2s walled gardens  and make them available as reusable building blocks. Encryption is just one example,  but of course there are a lot of such cross-cutting features like logging, auto-delete, grants, metrics, and tagging.

[![Thumbnail 2040](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/2040.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=2040)

[![Thumbnail 2060](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/2060.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=2060)

So we are now launching a CDK Mixins library in Preview. These are composable, reusable abstractions that can apply to constructs of any level, so they are no longer exclusive to L2s, and you can mix and match them with L1s. You can apply them to your custom constructs and get a lot of these benefits for free.  An example here is using encryption at rest. In code, this is how it looks. We're using encryption at rest with a CloudFormation bucket, which is an L1 S3 bucket. 

### Empowering Platform Teams: Proactive Security with CloudFormation Hooks and Multi-Account Governance

How many of you here are part of a platform team or a cloud center of excellence that either manages abstractions or security controls or deployment pipelines in your organization? Great. As all of you know, the empowerment of application teams to move independently means that you, the platform engineers, are no longer the bottleneck for every change to the cloud, which is great because now your organization can move faster. But misconfigurations can create security risks, and all it takes is for a developer to forget a critical security setting.

[![Thumbnail 2110](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/2110.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=2110)

[![Thumbnail 2120](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/2120.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=2120)

So how can we help our platform engineers  sleep well at night without worrying about what their developers are doing in their environment? Today's security tools are often reactive.  What this means is that they look at a resource configuration after the resource has been provisioned, and these tools will generate alerts for the platform team or the security team to respond to. So the burden is still on the platform team to coordinate responses to incidents.

[![Thumbnail 2150](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/2150.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=2150)

The feedback is passed to developers who then have to redeploy applications all over again. This is a long feedback loop, and we've been talking about long feedback loops throughout this session.  In order to do better, CloudFormation launched a capability called Hooks. What Hooks can do is detect misconfigurations before deployment. You can set up Hooks to run custom code or enforce controls at various points in your CloudFormation deployment workflow.

[![Thumbnail 2170](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/2170.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=2170)

Some of the invocation points that we support  are right before resource provisioning starts during a deployment, at the very beginning of a deployment cycle. You can also shift left control enforcement to change set creation time, which is deployment preview time. Finally, we also support Hooks for Cloud Control API operations, which allows you to enforce consistent controls across IaC tools that your organization uses.

[![Thumbnail 2210](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/2210.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=2210)

[![Thumbnail 2220](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/2220.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=2220)

[![Thumbnail 2230](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/2230.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=2230)

While this is great, a common challenge that customers share with us is that it's difficult to maintain and define the controls that we want to enforce. If you are in that situation, I'm excited to share that CloudFormation just launched an integration of Hooks  with the AWS Controls Catalog. You can think of these as predefined security best practices that are directly available for you in the CloudFormation console.  You can go into the console and open up these predefined best practices, and you can see exactly which control objective and security framework each control maps to.  With just three clicks, you can enable a control for all CloudFormation deployments in your account. It's never been easier to keep your CloudFormation deployment secure.

[![Thumbnail 2250](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/2250.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=2250)

[![Thumbnail 2270](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/2270.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=2270)

Another key aspect of governance that our platform engineers rely on  is multi-account architectures, where platform teams want landing zones for application teams. You can think of them as accounts that are bootstrapped with critical infrastructure and guardrails, so that application teams can start building in those accounts. CloudFormation stack sets are an invaluable tool for account baselining.  What stack sets do is take an IaC template and repeat the template in multiple accounts or regions. One of the amazing parts about stack sets is that they integrate with AWS Organizations. When you add a new account to an organizational unit, your stack set can automatically deploy foundational infrastructure to that account.

[![Thumbnail 2300](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/2300.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=2300)

While this is great, we now see that platform teams want to take a step forward with their foundation infrastructure.  They want to split up their foundational infrastructure into multiple components that independent teams can manage. For example, you may want to split out your networking resources from your identity resources, and your identity resources from your application resources. The challenge with this approach is that there are implicit dependencies between the stacks. Identity needs to be in place before networking can function, and networking needs to be in place before your application can function.

[![Thumbnail 2340](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/2340.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=2340)

When you add a new account to an organizational unit, you need your stack sets to deploy in a certain order to avoid failures. I'm happy to share that stack sets now supports  a feature called dependencies. Now you can say that your networking stack set depends on your identity stack sets, and your application stack set depends on both your networking and your identity stack set. CloudFormation will handle deployment ordering on your behalf when a new account is added, and you will get the baseline infrastructure that your application teams need.

[![Thumbnail 2380](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/2380.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=2380)

This combination of enforcing proactive controls and creating landing zones gives you the defense in depth strategy that you need to keep your cloud environment secure, while also leaving room for your developers to innovate.  Let's take a deep breath and digest some of the material we covered today. First, we talked about how authoring and validation capabilities can help you multiply your deployment velocity. Second, we talked about how easy it is now for you to stay on top of drift and to keep your IaC up to date with evolving business requirements. Third, we spoke about how easy it is now for platform teams to decentralize infrastructure management with confidence.

[![Thumbnail 2420](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/2420.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=2420)

### The Future of Infrastructure Management: Bridging AI and Infrastructure as Code with AWS MCP Server

So let's ask ourselves, how is infrastructure management evolving? What are the next big trends in infrastructure management that you want to stay on top of? 

Well, AI is top of mind for organizations and leaders today. We all want the efficiency benefits of AI. And while the ability of AI to create cat videos and pirate costumes is exciting in itself, we really want AI to help with the hard stuff in our jobs. All of you know here that infrastructure management is hard because it demands context and it demands precision. But this conflicts with the probabilistic nature of AI. So how can we bring the efficiency benefits of AI to infrastructure management? Do we see a world where the two can come together?

[![Thumbnail 2460](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/2460.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=2460)

Well, we think that Infrastructure as Code will be the crucial bridge that brings AI benefits to infrastructure management because AI and Infrastructure as Code have complementary strengths. AI provides ease of use and speed. While Infrastructure as Code comes with built-in mechanisms for safety, reliability, and human oversight through features like deployment previews, rollbacks, and resource handlers that come with correctness guarantees. So as we think about the future of Infrastructure as Code, we're thinking about how we can bring AI into Infrastructure as Code workflows and create a whole new infrastructure management paradigm for our customers. 

Now, Praneeta, I'll hand it back to you to discuss how customers are trying to combine these concepts today and what challenges they run into.

[![Thumbnail 2520](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/2520.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=2520)

AI is amazing, isn't it? I use it a lot every day. I use it for this talk. But I want to talk about something important.  I feel like developers lose trust in AI, especially when generating infrastructure code, because the errors are so minor and invisible. It's almost right, but not quite. But in Infrastructure as Code, that can be catastrophic. It can bring down your environments. It can cause a lot of damage. And that's not a fun place to be. So before we start saying AI did this in place of dog ate my homework, how can we make our AI-driven development flows much more reliable? How can we make all the tools that we talked about earlier that were for our human development workflows available to AI as well so it can make better decisions? We talked about long feedback loops earlier.

[![Thumbnail 2570](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/2570.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=2570)

[![Thumbnail 2600](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/2600.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=2600)

It becomes even more challenging in AI-driven or agentic workflows, because an agent is now far removed from when the deployment failure happens.  And if it cannot get that context back in time for it to reason and fix the generated code, you lose all of the speed benefits. It's the same with a pipeline. The pipeline now just becomes an additional layer that the agent cannot go past. 

[![Thumbnail 2660](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/2660.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=2660)

So it's really critical we provide the agent that context while it is generating code. And how can we do this? One of the things that we have launched last week is the AWS MCP server. Now you've all been hearing a lot about MCPs. You will hear a lot about them this week. But mainly they are a way for AI systems to communicate with local tools and context predictably. So if you ask a CDK question, the agent is going to look for CDK-related tools to give you a better answer. And what we're doing with the AWS MCP server, which is available open source and on AWS Labs, is we are providing these as tools for your agent to use and improve the quality of the code generated so you don't run into challenges during deployment. 

[![Thumbnail 2710](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/2710.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=2710)

What these tools look like are knowledge tools. They're curated knowledge tools that cover AWS opinionated best practices, recommended best practices, CDK construct libraries, both in alpha and in GA, and CloudFormation context as well that we really recommend the agent to look at. And we have added troubleshooting tools, which could be server-side APIs called on CloudFormation, like the change set validation we talked about earlier. And validation tools are more of your local tools that do static code analysis and find syntax errors for you in your code. So all of these tools are available today. 

[![Thumbnail 2730](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e222f461c4c84b9d/2730.jpg)](https://www.youtube.com/watch?v=_4hvWns9ICY&t=2730)

I would love for you all to check out the AWS MCP server. It's available at this link. This link takes you through a workshop that helps you use AWS MCP servers in a guided path, and it helps you get comfortable with the whole idea. 

### Closing Remarks and Call to Action

So here we are, folks. My first breakout session, some of your first re:Invent sessions. I hope you're all feeling wonderful and you've all learned something today from this talk. We do have a survey link here. We use this data to make better decisions and prioritizations for 2026. So we would love for you to fill this up for us and let us know your candid feedback on our tools. But overall, I'm really excited that I got to speak to you all today. Thank you so much for your time, and we are also available to talk after the session if anyone has any more questions. But thank you, everyone, for your time.


----

; This article is entirely auto-generated using Amazon Bedrock.
