---
title: 'AWS re:Invent 2025 - Make agents remember with Amazon Bedrock AgentCore Memory (AIM331)'
published: true
description: 'In this video, Mani Khanuja, Principal Generative AI Specialist Solution Architect at AWS, along with Jay (Product Manager) and Imran Shah from Experian, demonstrate Amazon Bedrock AgentCore Memory and its role in agentic AI applications. The session explains how memory enables agents to retain context across interactions, distinguishing between short-term memory (raw conversation history lasting 7 days to 1 year) and long-term memory (persistent insights using summary, user preferences, and semantic strategies). A live demo compares a basic agent versus a memory-enabled agent building PowerPoint presentations, showing how the latter remembers styling preferences and content requirements without repeated instructions. Imran shares Experian''s journey from fragmented product-specific memory implementations to a unified architecture using AgentCore Memory, highlighting benefits including faster time-to-value, reduced operational complexity, and compliance with GDPR and CCPA. The presentation covers practical use cases like coding assistants and customer support agents, emphasizing how memory improves both accuracy and customer experience while reducing costs.'
tags: ''
cover_image: 'https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/0.jpg'
series: ''
canonical_url: null
id: 3086064
date: '2025-12-05T10:19:37Z'
---

**ðŸ¦„ Making great presentations more accessible.**
This project enhances multilingual accessibility and discoverability while preserving the original content. Detailed transcriptions and keyframes capture the nuances and technical insights that convey the full value of each session.

**Note**: A comprehensive list of re:Invent 2025 transcribed articles is available in this [Spreadsheet](https://docs.google.com/spreadsheets/d/13fihyGeDoSuheATs_lSmcluvnX3tnffdsh16NX0M2iA/edit?usp=sharing)!

# Overview


ðŸ“– **AWS re:Invent 2025 - Make agents remember with Amazon Bedrock AgentCore Memory (AIM331)**

> In this video, Mani Khanuja, Principal Generative AI Specialist Solution Architect at AWS, along with Jay (Product Manager) and Imran Shah from Experian, demonstrate Amazon Bedrock AgentCore Memory and its role in agentic AI applications. The session explains how memory enables agents to retain context across interactions, distinguishing between short-term memory (raw conversation history lasting 7 days to 1 year) and long-term memory (persistent insights using summary, user preferences, and semantic strategies). A live demo compares a basic agent versus a memory-enabled agent building PowerPoint presentations, showing how the latter remembers styling preferences and content requirements without repeated instructions. Imran shares Experian's journey from fragmented product-specific memory implementations to a unified architecture using AgentCore Memory, highlighting benefits including faster time-to-value, reduced operational complexity, and compliance with GDPR and CCPA. The presentation covers practical use cases like coding assistants and customer support agents, emphasizing how memory improves both accuracy and customer experience while reducing costs.

{% youtube https://www.youtube.com/watch?v=Sh0Ro00_rpA %}
; This article is entirely auto-generated while preserving the original presentation content as much as possible. Please note that there may be typos or inaccuracies.

# Main Part
[![Thumbnail 0](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/0.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=0)

### Introduction: Why Memory Matters in Agentic AI Applications

 Hello everyone. I welcome you all to our session on making agents remember using Amazon Bedrock AgentCore Memory. Before we begin our session, I'm Mani Khanuja, Principal Generative AI Specialist Solution Architect at AWS. I'm very excited to be here with you today. Before we begin, can I have a quick show of hands for people who are aware of the memory concept in the agentic AI world? Awesome, so we have many folks who are aware, and we also have a few folks who will be hearing about agent memory for the first time and what role it plays. Today I also have with me Jay, our Product Manager, and Imran from Experian, sharing the stage with us. He's the Senior VP and Head of Engineering from Experian Software Solutions, and he'll be sharing the journey of how Experian has been using AgentCore Memory for building their applications. I'm very excited to be here, and I hope you've all had your coffee so that you're all awake.

[![Thumbnail 80](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/80.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=80)

[![Thumbnail 110](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/110.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=110)

Let's get started then. The main thing about  memory when it comes to agentic AI applications is providing the right context to the agent at the right time. That's what we see agent applications without memory lack. By the end of this presentation, I promise that you will understand and see a good demo on how it can make the difference when you are building agentic AI applications. Let's talk about the context  first. What goes into the context of an agent and what really this agent is? When I think about an agent, it's literally a model that has access to some tools. It can take actions on your behalf based on the tools that you provide. Those tools could be some data APIs, real-time APIs that you want the agent to have access to, or it can be access to your knowledge store where you have your organization data.

It can also be instructions, and system prompt is super important because the system prompt is what makes the agent understand what it's supposed to do. There are so many things that go into the context of an agent, and that's where we have seen that memory is often overlooked. But imagine you're at a party. You've been talking to a few people, and suddenly after the conversation is over, you're like, "What's your name?" We don't want our agents to be in that situation, especially when they're interacting with your users. You also want to give a good user experience or customer experience in addition to providing relevant and accurate responses. That's where memory plays a big role, and it's literally bridging this gap.

[![Thumbnail 210](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/210.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=210)

### The Slide Deck Agent Example: Understanding User Preferences and Context Retention

Let's take an example. For  this presentation, we had to build our presentation deck, and when we were discussing, we thought, why not take this example and share how you can build slide decks? So we built a slide deck agent that can do a lot of things. I started with a very basic agent with no memory. It was good and able to do the work. If I provide a big prompt with all the instructions, it's able to generate the deck. I provided some tools, such as Python PPTX, and it did a good job, no doubt about that. But then I noticed that every time I had to mention, for technical presentations, use this style. I'm in AI, and responsible AI is close to my heart, so in all of my presentations, I want some angle about how people use AI responsibly. Those are my preferences, which I wanted the agent to remember, but with this basic agent, I always had to provide these instructions over and over again.

How do I overcome that? That's where I created another agent with memory. This agent could understand my preferences over time. When I was building a lot of slide decks, it learned my preferences, and then after a while, I just say, for tech presentation,

[![Thumbnail 340](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/340.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=340)

"Oh, for tech presentation on this topic," and it will just do the job. Not just that, because I know when we are talking about it, we make it sound very simple. So that's where we will show you this demo up and running. So stay tuned. It will be at the end, so you have to stay for that. And also, I want to make sure that you understand the fact that how memory bridges this gap when you are interacting with the agent. 

[![Thumbnail 370](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/370.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=370)

When the user is interacting with the agent, there is conversation, there is a lot of context that agents need to remember, so we have to make sure that we are providing that context to the agent so that they give responses in an accurate, reliable, and relevant way, and also give good customer experience.  You don't just want your agents to remember stuff, you also want them to be smart, and they can only be smart if they're able to retain that knowledge, if they have the full context of your application or the job that you are asking the agent to accomplish.

You want the user preferences or maybe the facts or maybe the summary of the previous sessions to be remembered and retained by this agent, or maybe the agent should be able to call those things. So those are the things which are very critical. For example, you had a long conversation with the agent, and then you come back and what you want to do is basically resume from that conversation. That's a very common use case. But imagine if you're storing the entire conversation history, it will grow so big, right?

[![Thumbnail 450](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/450.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=450)

You might want to summarize it, and maybe when your user comes back, the agent can say, "You know what, last time when we interacted, you talked about these topics. Do you want to continue with these topics or you want to start a new one?" So those are the things that you want your agent to remember, right? It would be so cool. So that's where you want your agent not just to remember but be smart about it, be able to recall those things, and that's where we are going to show you how you would do that. 

[![Thumbnail 460](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/460.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=460)

### Demo Architecture: Building Agents with Memory Hooks and Security

Now let's talk about this demo sneak peek that I talked about, right? So the first thing when you're building an agentic application, you need the interface. Your UI should be attractive and nice, but at the same time you need some kind of a framework to build your agent.  So in our application, I'm going to show you two agents: one, the agent without memory, and second, the agent with memory, and you will see the difference. We are going to give the same prompt to both of these agents, and I'm using Strands framework to build these agents.

[![Thumbnail 490](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/490.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=490)

Then of course the main layer we are talking about is memory. We want agents to remember, right?  So for this demo I have the memory hooks. So why memory hooks and what are these hooks, right? So within these frameworks when we are using to build agents, there are two ways. One, you can use memory as a tool or you can use memory as a hook.

So why we use memory as a hook? If we want to make sure that agent calls the memory at a specific time in their life cycle, for example, on every message added, I want my agent to add it to the short-term memory, and then there is a long-term memory which agent needs to retain the key specific facts, right? Maybe I can use that as a tool because whenever the agent needs it, it can retrieve from the long-term memory, right? So that's how you need the memory hooks, and sometimes memory as a tool, depending upon your application.

[![Thumbnail 600](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/600.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=600)

Memory hooks is a more deterministic way of making sure that every message added goes to the short-term memory. Then when you are using these frameworks, there is a session manager that you might need, and this will become more clear when we go through our presentation. Then there is a configuration like what gets extracted from the short-term memory and goes into the long-term memory, so you should have control over that, right? So in my demo I'm using the memory config where you can literally override the prompts, figure out what gets extracted, and we are using user preferences for this demo and all of this will become clear when we do a deeper dive on how agent core memory will help you out. 

And last but not the least, I want to mention what the services that we are using. So I'm using Amazon Bedrock, Anthropic Claude Sonnet 4.5.

I'm also using AgentCore Memory, and of course security is super important. With IAM permissions and integration with memory, I make sure that I'm only giving the permissions that the agent needs to do its job, nothing more than that. This helps me reduce my blast radius. One of the key principles of security is the principle of least privilege, and that's what this does.

[![Thumbnail 650](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/650.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=650)

### The Challenge of Building Memory Systems from Scratch

Now you have looked at the demo and have some idea about what it's going to look like. But now imagine you have to build all of this on your own.  Imagine you have to build the whole memory system. I'm not even talking about building and deploying the agent, just the memory system. What would you need?

Short-term memory should have everything as is, like raw messages and some storage, and you should be able to give, let's say, the last K turns to your agent so that it maintains your conversation history. Short-term memory is literally raw messages that I should be able to retain and call. So you need some kind of database or key-value system which can store these messages.

Long-term memory is different. The agent should remember, for example, user preferences across multiple sessions. I need a different type of data stored there. Why? Because based on the query, the agent should be able to semantically retrieve the information. When I say semantically, I mean based on the meaning of the question, it should be able to extract the right information. So I need maybe a vector store for that.

Now with these two storage systems, I have to make sure that I'm managing memory refresh all the time. My data is refreshed. I have an automatic pipeline. Whenever there is a duplicate user preference, it's consolidating and updating. It's not really adding new preferences without consolidation. Because imagine if I tell you that I'm a vegetarian and then I'm a non-vegetarian. What will you serve me? Nothing, because you are confused. But because I was a vegetarian earlier and now I'm a non-vegetarian, it makes sense for me to order non-vegetarian food or for the agent to give me recommendations of non-vegetarian food, for example. But if I give both those things, the agent will get confused about what it needs to do. So the consolidation logic becomes very important.

[![Thumbnail 660](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/660.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=660)

You have to do that on your own, and you have to do all of this in a very secure way. And not just that, imagine something happens while your user is interacting with the application and you need to troubleshoot or debug. You need to build and integrate observability into your system.  All of this becomes really a lot of work and heavy lifting.

[![Thumbnail 820](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/820.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=820)

That's where Amazon Bedrock AgentCore Memory comes in to help you out so that you can focus on doing what you do best: building applications for your customers. We take away all that heavy lifting from you, and you should be able to quickly integrate memory into your agentic applications.  Now to go deeper into this, I'll invite Jay, who is the product manager for AgentCore Memory and the best person to talk about it.

[![Thumbnail 880](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/880.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=880)

[![Thumbnail 890](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/890.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=890)

### How Amazon Bedrock AgentCore Memory Works: Short-Term and Long-Term Memory Strategies

I think in that case with the meal, I'd probably go vegetarian just to be safe. All right, so we built AgentCore Memory, as mentioned, to ensure that your agents have the right context at the right time. It's a fully managed service that addresses many of the traditional challenges  associated with agentic memory. Let's look at how it works.  So we're going to do another thought exercise here. I want you to think about a conversation that you've had in the last week or so. You probably remember that conversation pretty well, maybe even word for word.

Think about a conversation you had about a year ago. If you attended AWS re:Invent last year, think about a conversation or presentation you experienced there. If not, perhaps think back to last Thanksgiving or last Christmas. For that conversation or interaction, you probably don't remember it perfectly. Your brain remembers the most important details and generally what happened. You might have used that information to inform future conversations or interactions. That's how your brain works, and that's how we designed Agent Core Memory as well.

[![Thumbnail 950](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/950.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=950)

[![Thumbnail 1000](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/1000.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=1000)

It all starts with your memory resource.  That's the blue and slightly pink box. Within the memory resource that you set up in your AWS account, we have short-term memory and long-term memory. Short-term memory is your raw interaction historyâ€”word for wordâ€”that you remember more recently and that persists from seven days to up to one year based on your configuration settings. Long-term memory contains the important information and key insights that persist throughout, and your agent can retrieve both short-term and long-term memory to complete the job at hand. 

Let's start by looking at how short-term memory works. In short-term memory, your agent interactions are captured and sent to the memory resource in the form of events. Events contain an actor ID, which identifies who this is or who it is combined with what the agent is, and a session ID, which is generally your specific interaction. The actor ID and session ID can be used in conjunction with the events and that raw information for easy context tracking. Events can contain your conversation history, metadata, and blob payloads such as images or audio. This is most useful for hydrating your agent with recent conversation history and recent interaction history.

[![Thumbnail 1080](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/1080.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=1080)

This is the baseline at this point, and this is an example of having a conversation and then someone comes back and asks, "Who are you?" No one wants their agent to be a goldfish, as we say, and short-term memory is really good at preventing that.  Short-term memory has a few other uses as well. For that, I'd like to talk about a topic that is near and dear to me: convincing my family to get a golden retriever puppy. I've been unsuccessful so far, and I'm thinking about a new approach using the PowerPoint builder agent to create a presentation convincing my family to get the puppy.

[![Thumbnail 1150](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/1150.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=1150)

[![Thumbnail 1170](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/1170.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=1170)

[![Thumbnail 1180](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/1180.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=1180)

I'm going to tell it to include a bunch of cute pictures and some of the pros of getting a puppy or a dog in general, which include that it teaches responsibility and that statistically people who have dogs are shown to be happier. I'm also going to ask the agent to do a financial analysis to address some of my family's concerns that costs might be an issue. I've put in a lot of effort here, going back and forth with the agent, and the most annoying thing that can happen is the screen goes blank.  Let's say I quit by mistake. Now, it can be really painful to get back to that exact point. It can require a lot of effort. With Agent Core Memory, conversation history can be stored and interaction state can be stored as well.  What that means is that you can go back to the exact spot where you were, and hopefully, I'll keep you posted. Next year at re:Invent, we'll have a puppy. 

[![Thumbnail 1190](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/1190.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=1190)

[![Thumbnail 1200](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/1200.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=1200)

Agent Core Memory supports a few other advanced features for event organization with short-term memory.  One of which is branching.  Branching is useful for going back and editing messages or editing events. It's also useful for concurrent event streams. What that means is AgentCore can handle concurrent event streams.

[![Thumbnail 1240](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/1240.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=1240)

For example, if I put in effort for this presentation and wanted the agent to build multiple presentations simultaneouslyâ€”one on getting a golden retriever puppy, one on getting a Siberian husky puppy, and perhaps one on getting a German shepherd puppyâ€”AgentCore can do that with branching while maintaining logical separation. 

Now let's look at long-term memory. With long-term memory, your raw interactions from short-term memory are automatically transformed into structured and persistent insights. Unlike short-term memory, where full interactions are captured, long-term memory only pulls key insights that you'll need over time. It's a multi-step process to capture these interactions and write them to long-term memory, and we're using large language models for this.

[![Thumbnail 1290](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/1290.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=1290)

You may be wondering how we know what information to pull into long-term memory. The answer is by choosing a memory strategy. We have three built-in strategies: summary, user preferences, and semantic.  It's very simple to add theseâ€”you go into the AWS console or add them via API or programmatically, pick the strategy you want, add it, and information automatically starts flowing from short-term memory into long-term memory.

The strategies themselves are self-explanatory. Summary condenses down your conversation and saves that. User preferences captures the user's preferences. For the interaction we discussed, it might capture that the user prefers golden retrievers and Siberian huskies to German shepherds. Semantic captures facts about the interaction, such as the user has a family and the family wants a dog.

You may also want more control over what you send into long-term memory, and that's what the bottom two strategies are for. With the override strategy, you can choose which large language models to use and what prompts to use to send information into long-term memory. Self-managed gives you complete control over the extraction process. With that approach, we deliver the events to an S3 bucket and notify you of those. You can pick up those events, bring them through any processing you want, and write them to long-term memory as memory records via dedicated APIs.

All memory records created from these strategies can be retrieved semantically based on a query search. Memory strategies can also be combined. It makes a lot of sense to summarize your interactions and also capture facts about them. If you're creating an agent, summary and semantic might be the way to start, and then if you want more control over time, consider looking at override or self-managed.

[![Thumbnail 1450](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/1450.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=1450)

Let's put all of this together.  Starting on the left side, as we remember, interactions and conversations are captured and sent to the agent as short-term memory as events. Depending on the strategies you've configured, those events are sent into long-term memory as memory records. Both short-term memory and long-term memoryâ€”both events and memory recordsâ€”can be retrieved by the agent to complete whatever task it is completing.

You may have also noticed we now have agent 2 and agent 3 here. Multiple agents can write to and read from a single memory resource, so that's an option you can make. We can support multi-agent use cases or just one.

That's Agent Core Memory. It's a fully managed service with built-in observability and enterprise-grade security features. Now I'm going to pass things over to my friend Imran at Experian to talk a bit about his organization's experience with agentic memory.

[![Thumbnail 1560](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/1560.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=1560)

### Experian's Journey: From Fragmented Memory to Unified Architecture

Thanks, Jay. I'm Imran Shah. I'm here today from Experian to talk about what you've heard from Mani and Jay in terms of putting this into perspective with an organization and enterprise scale. I'm here to talk about Experian's journey of how we have moved from short-term memory  to a unified memory architecture, especially using Agent Core Memory to simplify our direction within Experian as all of you can experience today.

The whole AI across enterprise is a rapid evolution on a daily basis. It is changing, and that is how Experian was thinking before Agent Core. In terms of short-term memory, as Mani said, we talk about something, we introduce it with that name, and I forget who you were. That's short-term memory. We have actually pivoted our roadmap with this whole Agent Core long-term memory architecture, and we have adopted that in pilot mode with Experian. I'm going to take you through that journey today.

A little bit about Experian: as you know, we are a credit bureau across the globe. We are an innovative global data and technology business, and our main aim is to work towards financial health for all. We have around 1.5 billion plus consumers across the globe, and we serve both small, medium, and large businessesâ€”201 million plus businesses across the globe and across geographies. From a richness perspective, we serve 25,000 employees across 32 countries. From a domain perspective, you can name it: cable to credit, not only credit but also data solutions, automotive, and healthcare. We are delivering this all with 99.9% accuracy of data across multiple domains.

[![Thumbnail 1610](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/1610.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=1610)

Now let's talk about Experian's Agent Core journey. As you heard from Mani and Jay, we started our journey with short-term, very product-specific memory implementations. Very quickly we realized that's not the way to go, and we changed our approach to a unified approach with more conversational context and moving towards long-term memory.  What Agent Core has also brought us is rethinking our roadmaps in terms of how Amazon Bedrock Agent Core Memory works. We are actually moving to more time to value and simpler journeys, and pivoting our roadmap towards that. We'll talk in subsequent slides about how we are doing that in perspective.

[![Thumbnail 1670](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/1670.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=1670)

So as you can see in this diagram,  our current memory implementation is across products in two different ways. One is managed memory where you have assistants which are using tools like OpenAI, providing thread-level memory. On the right-hand side, we also have custom memory implementations which are some of the agents leveraging open-source frameworks, again providing thread-level memory. In contrast, as you can see, we have managed and we have custom, both coexisting, which creates a lot of user frustration and confusion across teams.

[![Thumbnail 1750](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/1750.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=1750)

From a short-term memory perspective, as you can see, it works, but it doesn't scale into the enterprise world. A very small company with even 500 employees or 200 customersâ€”even in that regard, short-term memory has some limitations. Starting with the first one, which is more around continuity and persisting long conversation histories. The second one is more around performance and cost, which is very important to all organizations at any scale levels. We also have cross-product recall issues, which leads to a lot of user frustration where no memory recall happens across the threads or products. 

[![Thumbnail 1820](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/1820.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=1820)

And last but not least is compliance and regulatory. Regulatory and compliance requirements present significant challenges, particularly when you need to maintain records going back two years and meet any retention requirements. This is very difficult to achieve with short-term memory alone. 

[![Thumbnail 1880](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/1880.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=1880)

Now let's move on to context orchestration and how unified memory has changed our entire implementation and roadmap. As you can see, there are two planes of context here. We have an authoritative context, which centers around knowledge bases and APIs, including databases and the things that comprise your knowledge ecosystems. We also have a conversational context, which includes short-term memory, long-term memory, and agent state. When you combine these two planes of context into a unified context workflow, it becomes very impactful for an organization that can scale from an enterprise perspective. Your LLM reporting can be much more efficient, and your user personas can provide the user context required by each user. 

[![Thumbnail 1930](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/1930.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=1930)

Before AgentCore, our planned architecture for unified memory looked like this. In a classic build scenario, you have a conversational manager that stores and retrieves all your conversations. You also have a memory manager that stores and retrieves memory records powered by a typical memory store or vector database, and your ETL pipeline kicks off periodically to feed this system. This model had significant operational complexity due to managing multiple custom components. 

[![Thumbnail 1990](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/1990.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=1990)

Now let's talk about what changed after we implemented AgentCore with long-term memory assumptions into our roadmap and architecture. As you can see, it is much more simplified both in direction and in terms of the architecture. With this, you have a fully managed conversational store, fully managed conversational APIs, and zero ETL overhead for your extraction of memory. What this brings to the table for enterprise-wide scale is faster time to value, improved operational efficiency, and significantly increased functionality. In this scenario, our engineers focus on building agents and do not need to worry about the infrastructure. This is how we have simplified our direction, and we are still in the process of improving toward better scale and a better roadmap for Experian. 

[![Thumbnail 2060](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/2060.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=2060)

Our core design principles underpinning all of this architecture that you have seen in the current state and the two-state leverage four pillars. First, we have evaluation and test frameworks, which continuously evaluate your memory extraction processes. We also focused on cross-agent memory interoperability so that we can enable agents to share memory across different agents. This allows them to orchestrate with each other and provide very informed opinions with context in mind. We also have shorter targeted context windows, which keep interactions very purposeful and concise. Finally, we have namespace-based isolation, which every enterprise needs to achieve multi-tenant architecture where you can serve multiple tenants with the same master shared architecture. These are some of our core design principles, which are not only met with this whole design but also which we keep in focus on a daily basis. 

A design for privacy, transparency, and control comes in through the memory governance service, which we have designed as a unified first way to manage long-term AI memory. What it allows is for a user to selectively delete their own memories if they do not need them. An administrator will have the ability to purge memories on a periodic basis when required, giving control to both users and administrators if they need to take action in terms of purging. This whole approach enhances user experience, builds trust, and most importantly, ensures compliance.

It ensures compliance with guidelines like GDPR and CCPA. These are very important because at the heart of Experian, we believe in security, compliance, and user experience all together. I think Agent Core Memory architecture is bringing all that to life for us. It's solving multiple problems and also giving us a way to scale at an enterprise AI-wide level. With that, I would also like to thank our partners who have helped us with this implementation: Tiger Analytics and the AWS team. At this time, I'm more than happy to hand it over to Mani to take us through a very impactful demo.

### Live Demo: Comparing Basic Agent vs. Memory-Enabled Agent Performance

Now that you have understood Agent Core Memoryâ€”Jay went deep into the constructs, the components, and how it worksâ€”I would especially like to thank Imran for sharing how Experian has been using it in their products and how it was able to simplify their implementation and also scale. It is so important to make sure that your agents and your applications can scale. When we are building Agent Core Memory, we are taking that into mind because that's what our customers like yourself have been asking for. With that, I know it's time for the demo that I promised you at the very beginning. Are you all ready for the demo?

[![Thumbnail 2220](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/2220.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=2220)

[![Thumbnail 2240](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/2240.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=2240)

[![Thumbnail 2250](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/2250.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=2250)

This is the demo that I built using Agent Core Memory. As promised, there are two agents: the basic agent, which has no memory,  and then the memory-enabled agent, with a comparison. As you can see, I have some slides that I've already built out using this. My agent should now remember my preferences, but let's see the basic agent first.  You can see there is no memory. I can build some prompts provided it's a fully running application. I have to provide the prompts. I have to mention that I like the blue theme, or if I don't mention anything, it will just use  the default.

[![Thumbnail 2270](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/2270.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=2270)

[![Thumbnail 2280](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/2280.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=2280)

[![Thumbnail 2290](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/2290.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=2290)

[![Thumbnail 2300](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/2300.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=2300)

But when I go to the memory-enabled system agent, then as you can see, it can remember my styling. For technical presentations, I like the purple theme and the technical font. Because I've already built out presentations using this agent, it's able to capture it in the long-term  memory and also some real-world use cases that it should include in all of my presentations.  It also shows my focus on AI, so it's capturing that the user likes to build AI presentations.  So it literally shows that I'm into it. And then you can literally create a smart presentation, and now I don't have to specify my preferences over and over again. But who am I to say that? Let's see  it in action.

[![Thumbnail 2310](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/2310.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=2310)

[![Thumbnail 2330](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/2330.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=2330)

[![Thumbnail 2340](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/2340.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=2340)

[![Thumbnail 2350](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/2350.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=2350)

[![Thumbnail 2370](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/2370.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=2370)

[![Thumbnail 2380](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/2380.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=2380)

[![Thumbnail 2400](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/2400.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=2400)

With this agent comparison, I'm going to give the exact same prompt to both of these agents at the same time.  As you can see, I'm not going to provide my preferences. Let's remove that and just make it simpleâ€”what type of presentation I want and the key components. So now, behind the scenes, here's what's happening.  You can see my prompt. Behind the scenes, it's calling the basic agent first and gave the whole prompt. After this, now you will see that it is also calling the memory agent.  Let's take a closer look. The topic and such so that it can search the long-term memory behind the scenes.  And find the relevant preferences related to the content. But I also need preferences related to the styling. So then it's again making a call for my styling preferences and finding, searching, and retrieving  the right memory, which might be relevant to build this presentation. And then it is applying those things,  as you can see in the backend, to build my presentation. So it's all done. Now let's take a look and get back to our UI. So there are two comparisons, and it's also giving a good understanding and summary of what these two agents  have done based on the styling and based on the preferences.

[![Thumbnail 2410](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/2410.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=2410)

[![Thumbnail 2420](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/2420.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=2420)

[![Thumbnail 2430](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/2430.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=2430)

[![Thumbnail 2440](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/2440.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=2440)

With the basic agent, it uses blue because that's the default  theme that I've provided. However, for the styling applied to the memory agent, I've used the purple theme. I'm obsessed with the purple color.  Now let's take a look again at those preferences because I want you to remember them. When you see the actual slides, you'll be able to correlate them.  This purple theme with tech font and AI ethicsâ€”I'm obsessed with AI. It shows everything, so my agent knows me, right? That's the main idea behind it. 

[![Thumbnail 2450](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/2450.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=2450)

[![Thumbnail 2460](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/2460.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=2460)

[![Thumbnail 2470](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/2470.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=2470)

[![Thumbnail 2480](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/2480.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=2480)

Now let's look into the deck. You can see there is AI ethics tech added to it. Let's look at the basic one with the blue theme.  It's the default one because I never provided what I want in terms of styling preferences. It's still doing a really good job, as I explained to you earlier. It's giving the slide the format and everything.  Now let's look at the memory agent. Look at my styleâ€”purple color, tech font.  This is basically the font that you see when you're coding in one of the IDEs, so I like that. Now you can see those concepts incorporated into the presentation. 

[![Thumbnail 2520](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/2520.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=2520)

It's not just about my style and preferences, but if you look closely at the content, you'll realize that it has incorporated those thingsâ€”the content that I prefer in my deck. Obviously, this is 25 slides, and I couldn't go through all of them, but I'm showing you some of those ideas. If you're interested, this demo is actually in our GitHub repository. If you search for "agent core samples" on GitHub under memory, you'll see the full demo code, and you can try and play with it yourself. 

[![Thumbnail 2550](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/2550.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=2550)

### Real-World Use Cases and Next Steps for Building with AgentCore Memory

Now that we've seen this demo using AgentCore Memory, I was simply able to integrate it based on the APIs with my existing agent. I started with the first basic agent and then integrated it with the memory. I literally called some of the APIs. It took me a few minutes to do that. However, there are a lot of other use cases as well.  The example I gave you is literally related to the content creation example that you have on the slide. But there are way more use cases than these six that I'm showing you on the slide deck. Obviously, there isn't much space and not much time to talk about all the use cases in this hour.

Let me take an example of some of the other use cases that might be relevant to you. A quick show of handsâ€”have you used a coding assistant to build your code, like with white coding? I see a lot of hands on the left side, center, and right, so you're aware. Have you noticed this when you're using the coding assistant? You provide all the instructions, it generates the code, then you run the code, and there might be some issues, right? Then you give some additional instructions. There's one instruction specifically that at least I give when I use white codingâ€”make changes using minimal lines of code. Do not create any new files if they're not needed.

Agents usually create a bunch of test files when you ask them to fix anything. So that's something you have to type every time. If your coding assistant doesn't have memory, you have to repeat these instructions. Have you noticed that, or is it just me? I do see some nodding heads. Absolutely. So that's an indication to integrate your coding assistants with AgentCore Memory. It will make your job easier. You won't have to type these instructions over and over again. Whenever you're making an edit, you're just saying, "Edit this file." How cool will that be?

That's one use case for how you can build a really smart coding assistant that can literally remember your preferences and your style. Maybe you love coding in Python, so it shouldn't generate code in Java, or it shouldn't continuously ask you which language, for example, right? It's personal to you. Understanding your experience and giving you a better experienceâ€”and this is exactly what you want for your customers.

Now, let's talk about a customer support agent. With a customer support agent, you would call customer support for a specific issueâ€”for example, discussing a refund, requesting a replacement if you don't like the product, or complaining that the product took too long to arrive. These are typical queries for customer support in e-commerce, which we all experience through online shopping. I thought this would be a relatable example to use.

What you want from this customer support agent is for it to remember past issues. Why is this important? Because you want to understand your users better. Is this customer experiencing the same issue repeatedly? If so, what's happening? Maybe it's time to update something. Or perhaps the agent on the other side can quickly review the history and say, "This is how we fixed this issue in the past. Let's do the same thing again."

This type of information becomes critical to providing a good experience both to your customers and to the agent who is interacting with them and providing better support. Memory becomes important because it demonstrates how much you care about your customers. You're not just giving them accurate and reliable help; you're also remembering them. That's what you want to deliver to your customers.

When you're building an agentic application, I want to make sure you think about not just accuracy and relevancyâ€”those are absolutely essentialâ€”but also think about customer experience. Consider how you can minimize the number of calls the agent has to make, because that will save you costs as well. Providing the right context to the agent at the right time is crucial. AgentCore Memory is one of the components that will help you without requiring too much heavy lifting on your part, because we're taking care of that on your behalf.

[![Thumbnail 2860](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/e869a3e1af26c495/2860.jpg)](https://www.youtube.com/watch?v=Sh0Ro00_rpA&t=2860)

With that said, there is a next step I really want you to take. What we have presented today is actually just the beginning.  It's not the end of the presentation. There is more to come and more to be seen and heard at this re:Invent. I invite you to join a session by Doctor Swami, who will be talking about the new features we'll be launching across our AgentCore line of products and services.

I also want to invite you to build one of these use cases. Connect with us either on LinkedIn, shoot us an email, or reach out to your account teams, and they can connect you with us. I'm so excited to hear your stories and understand what you are building next. Thank you so much for your time today, especially this early morning. I know it's difficult to get up, but you are here. Thank you, thank you, and thank you for that.


----

; This article is entirely auto-generated using Amazon Bedrock.
