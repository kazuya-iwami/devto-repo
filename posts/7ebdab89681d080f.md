---
title: 'AWS re:Invent 2025 - kro: Simplifying Kubernetes Resource Orchestration (OPN308)'
published: true
description: 'In this video, Shani Adadi Kazaz and Petro Kashlikov demonstrate how kro, an open-source Kubernetes project, solves infrastructure deployment challenges. They explain how traditional pipeline-based deployments can take a full business day due to issues with composability, self-healing, and state management. Using a voting app with five components as an example, they introduce ACK (AWS Controllers for Kubernetes) and kro, which enables composable resource orchestration through ResourceGraphDefinition. kro automatically creates directed acyclic graphs, uses CEL for logic operations, and provides self-healing reconciliation. Notably, AWS, Google, and Microsoft all joined as contributors, and kro moved to Kubernetes SIG in September 2024, positioning it to become a core Kubernetes feature.'
tags: ''
series: ''
canonical_url: null
id: 3085115
date: '2025-12-05T03:11:11Z'
---

**ðŸ¦„ Making great presentations more accessible.**
This project enhances multilingual accessibility and discoverability while preserving the original content. Detailed transcriptions and keyframes capture the nuances and technical insights that convey the full value of each session.

**Note**: A comprehensive list of re:Invent 2025 transcribed articles is available in this [Spreadsheet](https://docs.google.com/spreadsheets/d/13fihyGeDoSuheATs_lSmcluvnX3tnffdsh16NX0M2iA/edit?usp=sharing)!

# Overview


ðŸ“– **AWS re:Invent 2025 - kro: Simplifying Kubernetes Resource Orchestration (OPN308)**

> In this video, Shani Adadi Kazaz and Petro Kashlikov demonstrate how kro, an open-source Kubernetes project, solves infrastructure deployment challenges. They explain how traditional pipeline-based deployments can take a full business day due to issues with composability, self-healing, and state management. Using a voting app with five components as an example, they introduce ACK (AWS Controllers for Kubernetes) and kro, which enables composable resource orchestration through ResourceGraphDefinition. kro automatically creates directed acyclic graphs, uses CEL for logic operations, and provides self-healing reconciliation. Notably, AWS, Google, and Microsoft all joined as contributors, and kro moved to Kubernetes SIG in September 2024, positioning it to become a core Kubernetes feature.

{% youtube https://www.youtube.com/watch?v=95xCRSsevaY %}
; This article is entirely auto-generated while preserving the original presentation content as much as possible. Please note that there may be typos or inaccuracies.

# Main Part
[![Thumbnail 0](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/0.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=0)

[![Thumbnail 10](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/10.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=10)

### The Challenge: Why Deploying Cloud Infrastructure Takes a Full Business Day

 Hello everyone, thanks for joining us today. My name is Shani Adadi Kazaz.  I'm a go-to-market specialist for containers based in Madrid, and with me is Petro. Hi, my name is Petro Kashlikov. I am a senior solutions architect based in the New York area. Thank you for coming to our session.

[![Thumbnail 40](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/40.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=40)

So now you are going to help us solve one of the most ancient debates out there. Are you ready? I like dogs, Petro likes cats. Who is better?  You probably think that I'm going to ask you to raise your hands, but no worries, I'm not. We are going to do it in a proper way using a voting app.

[![Thumbnail 60](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/60.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=60)

[![Thumbnail 70](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/70.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=70)

[![Thumbnail 90](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/90.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=90)

 Our voting app has five components: three different microservices, one database, and a cache.  We are going to deploy the microservices using Kubernetes. The database and the caching will be deployed using a different tool. How much time do you think it takes to deploy this app with those five different components?  With Kubernetes, it's going to be probably a few minutes using a Helm chart. But what about the database and the cache? How much time will it take us to deploy those components?

[![Thumbnail 100](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/100.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=100)

[![Thumbnail 110](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/110.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=110)

[![Thumbnail 120](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/120.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=120)

 Let's break it down. If I'm working in a big company and I need to deploy those components, I will probably need to use some pipelines.  I will probably need to go first to the networking team to use the networking pipeline to get things like the VPC, the subnets, and maybe an IP address.  Then I will take those outputs from the pipeline and put them into the infra pipeline to get my database. If I'm lucky enough, I will get the endpoint and the credentials in the same pipeline, but if not, I will probably need to use different ones.

[![Thumbnail 130](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/130.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=130)

[![Thumbnail 140](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/140.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=140)

 Then with those outputs, I will need to put them into the pipeline that the platform team created for me to use the EKS.  Now, if I'm lucky enough, everything worked smoothly the first time. But as you know, when you are using tools such as Terraform, they sometimes fail without any good reason, and they need to do everything all over again. This process can take a full business day. Kubernetes has just turned eleven and we still need to deploy those components, probably a full business day.

[![Thumbnail 160](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/160.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=160)

What the developer does during this full business day is probably just wait. They need to wait for every pipeline.  Now let's assume that everything worked perfectly and everything is good. Some companies also have a compliance pipeline, which makes sure that everything is compliant with the organization standards. What if the pipeline runs and decides that my RDS is not compliant? It will probably delete this RDS. If I'm lucky enough, I will know about it, but if not, I will just get some errors and I will need to figure out what happened.

[![Thumbnail 240](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/240.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=240)

[![Thumbnail 250](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/250.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=250)

[![Thumbnail 260](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/260.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=260)

So now we can understand why it can take on average a full business day.  If we summarize it, pipelines are not composable. I need to connect between the different components.  They are not self-healing. Once the compliance pipeline deleted my RDS, nothing will launch it again. I need to do it by myself.  They are not keeping the state. Where is the state? Is it in the infrastructure as code? But in the infrastructure as code I have a database, but the compliance pipeline deleted it. So maybe it's in the execution files, but which one? The infra pipeline went smoothly and launched my RDS, but then the compliance pipeline deleted it. So where is the state?

[![Thumbnail 290](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/290.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=290)

[![Thumbnail 300](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/300.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=300)

 If you're thinking that Gen AI is going to solve your problems, garbage in, garbage out. If you feed the Gen AI with a lot of mess, it will probably create much more mess. 

[![Thumbnail 310](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/310.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=310)

[![Thumbnail 320](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/320.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=320)

That leads me to think: are pipelines the right tool right now? They are not composable, they are not self-healing,  and I don't know where the state is of the whole system. Let's think about a different tool or concept that we can use.  Let's try to think about APIs. The whole internet runs with APIs, so why not deploy our infrastructure using APIs?

[![Thumbnail 340](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/340.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=340)

### The Solution: From Pipelines to APIs with ACK and kro

I want on one hand for the different teams to create the infrastructure as code separately, with everyone working independently, and I wanted to go through one placeâ€”let's call this place a Git repository.  On the other hand, I want developers to consume those capabilities that the different teams create in one place using APIs. If I'm thinking about a technology that allows me to create APIs, Kubernetes is a really powerful mechanism to do it. I can create different APIs and I can do it using controllers.

[![Thumbnail 380](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/380.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=380)

[![Thumbnail 410](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/410.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=410)

Controllers are the basis of Kubernetes.  In Kubernetes, I'm declaring what I wantâ€”the desired state will be. I'm not saying how Kubernetes will do it; it just does it. I'm just stating what I want it to be, and the controllers do the magic behind the scenes. They are making sure that the current state and the desired state are the same. If they are not the same, they will act upon it and will change the infrastructure. Since version 1.16, I can now create my own APIs and my own custom controllers.  So I can actually build anything. Today, there are also controllers to order pizza, so why not control my cloud resources?

[![Thumbnail 440](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/440.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=440)

But the question I have is: if I can write a controller, should I? Well, I need to write it, I need to maintain it, I need to update it. So let me introduce you to ACK.  ACK is an open source project developed and maintained by AWS, and it basically allows me to deploy and manage my cloud resources from my Kubernetes control plane, just like other Kubernetes objects. Now I can deploy my Kubernetes resources with my cloud resources in minutes, so we solved the problem, right?

[![Thumbnail 460](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/460.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=460)

[![Thumbnail 470](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/470.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=470)

But I do have one question now.  I need to have a lot of control and a lot of controllers.  How many controllers do we need? We need a controller for EKS, we need a controller for IAM, we need a controller for VPC, we need controllers for everything, and also the Kubernetes controllers. So how many controllers do you think we need to have?

[![Thumbnail 490](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/490.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=490)

[![Thumbnail 510](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/510.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=510)

I think in reality it looks more like this.  Multi-region, multi-environments like development, testing, and production, so you have a lot of stuff. And this saga continues, so you have organization scale with more tools and more resources.  Hundreds of clusters and it's not specifically with ACK toolsâ€”like with Terraform, you can reuse modelsâ€”but as we scale, it becomes harder to manage different pipelines and distinct state stores. It does not offer a central view, so this problem becomes more evident.

[![Thumbnail 540](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/540.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=540)

[![Thumbnail 570](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/570.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=570)

[![Thumbnail 590](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/590.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=590)

It's not only AWS or cloud resources infrastructure.  What about third parties like telemetry connections and various other things? There is much more even to this. And in the beginning we promised something simpler, right? You know, it doesn't look that simple. This is where kro comes in.  This is a new open source project, and I like to think about this as an all-purpose glue for Kubernetes resources. A short timeline: AWS open sourced kro in November 2024 at the conference,  and shortly after, in about two months, Google and Microsoft joined the project, becoming steering committee members and main contributors.

This is honestly the first open source project where all three major cloud providers become involved from the beginning of the project, and it progresses quite fast. So if that is not exciting enough, in September, Roy actually moved to Kubernetes SIG for open source, essentially paving the way to become a core feature of Kubernetes, not just another open source project, but a core feature of Kubernetes.

[![Thumbnail 640](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/640.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=640)

[![Thumbnail 650](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/650.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=650)

As Shani mentioned, before kro, for example, you have each controller standalone controlling different aspects.  With kro, we can rely on  Kubernetes API management and essentially create composable abstractions and group different resources together. Kubernetes cloud, third-party resources, you name it, any resources, and kro enables us to reuse outputs from one component before creating others.

[![Thumbnail 680](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/680.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=680)

[![Thumbnail 690](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/690.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=690)

So what Shani mentioned, the problem of retrieving the database ID or secret or VPC IP addresses, we can now do this everything  automatically with kro. Let me tell you about some core features which make kro special.  At heart, there are three core capabilities. First of all, kro provides a really human-friendly and straightforward way to define your CRD, your API. Under the hood, it uses Simple Schema. This schema automatically generates OpenAPI3 schemas, but for you as end users, Simple Schema is much easier. If you have experience with OpenAPI3 schemas, you know it is far from human-friendly to read.

Another one is that kro incorporates CEL, the Common Expression Language, for defining logical operations, and this is the same expression language that Kubernetes itself uses, for example, for webhooks. It is very simple and has advanced features like runtime cost budgeting and type checking. With this, you can define your dependencies and pass values from one resource to another. Another capability is that kro automatically constructs a directed acyclic graph for composable orchestrated resources and figures out the way in which resources should be provisioned, so you do not need to take care of this separately.

[![Thumbnail 780](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/780.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=780)

[![Thumbnail 820](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/820.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=820)

When you install the kro controller  in your cluster, it installs a custom resource definition called ResourceGraphDefinition. Then, like platform, security, and database teams, they can collaborate and create essentially this custom API, composable. It will then be instantiated by developers and reused in the cluster. kro uses the standard Kubernetes reconciliation pattern. The controller observes if there are new resources of this type or if there are changes to resources, then  it compares the actual state to the desired state and creates, updates, or deletes if necessary. This ensures constant reconciliation, what Shani was talking about like self-healing, so if somebody changed something, it will reconciliate this.

[![Thumbnail 840](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/840.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=840)

### How kro Works: Simplifying Resource Orchestration with ResourceGraphDefinition

 This is how it looks. This is a ResourceGraphDefinition, and it is very familiar for all Kubernetes people. Any resource has three main parts: metadata, spec, and status. The spec itself consists of two main parts: schema. This is where you define your API, and as you can see here, in the schema specs, these are fields which end users will be able to configure. You define the status, which is what kro will populate. This is for passing these values between other resources. So when, for example, the database endpoint is ready and it is reflected in the status, you define what fields users can configure, default values, and validation rules. For example, you can set port ranges to only be in a certain range, so if they try to define something else that is not compatible, it will not work.

In the Resources section, you specify your resources with variables and default values. As mentioned, these combinations can be directly Kubernetes resources like Pod, Deployment, and Ingress, or they can be cloud or third-party resources.

[![Thumbnail 930](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/930.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=930)

[![Thumbnail 940](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/940.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=940)

So what it gives us at the end, right?  From going from this, developers can go from this to this.  This is not an RGI, right? This is the final what developers are now instantiating as an instance. So this is very simple. You just give a name, and remember that conditions are supported. For example, here it says res enabled true. So if we say this, the application is exposed to the world using a load balancer. You can say false, and it will be just an internal service, right? But all other structural components and architecture remain the same.

[![Thumbnail 1000](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/1000.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=1000)

Same for cache, you can say enable true, or you don't want cache in this case, disable it. You don't need to change anything else in the template. So this simplifies things a lot. And as we already built it, we mentioned that yes, we will not ask you to raise your hands, but we still want to solve the debate, right? So I would like to ask you guys if you have phones, if you can go ahead and vote.  Help us solve and figure out what that was originally, right? So we still need to solve the debate. Despite explaining how we solved it, we would like to solve it. We also would like to share some extra resources with you, right?

[![Thumbnail 1030](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/1030.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=1030)

So if everybody voted, okay, so we have a few more. This is actually Kro.  Website, like where the documentation is, so we will encourage you to go check it. It's open source, you know, we are open source, so you are welcome to contribute as well. Contributions are accepted, and everything, so this is a very dynamically involved project, but you really can be involved here and help shape the future of Kubernetes resource orchestration.

[![Thumbnail 1060](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/1060.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=1060)

[![Thumbnail 1100](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/1100.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=1100)

From AWS side, we have also a lot. We have Skill Builder, there is a lot of free content, and even if you don't have a paid AWS account, there are many free courses.  This QR code leads specifically to container-focused topics, so you might find it interesting as well. And let's see who won, Petro or me. And by the way, in the meanwhile,  please use your app and vote and do the survey for this session. This is really important for us and it will be super helpful.

[![Thumbnail 1110](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/1110.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=1110)

[![Thumbnail 1130](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/7ebdab89681d080f/1130.jpg)](https://www.youtube.com/watch?v=95xCRSsevaY&t=1130)

Okay,  21 votes. Cats are better. Well, next time you will choose the right answer. Thank you very much for attending our session.  And we all, no, it's what we do in AWS always. We work backwards from customers, so your feedback is crucial. So we would really ask you if you can spare a few moments to complete the session survey in the app. This really helps us and helps us to create content like this and other content. We see how we can improve. We take feedback seriously, so we would really appreciate it if you can spend time on this. Thank you so much.


----

; This article is entirely auto-generated using Amazon Bedrock.
