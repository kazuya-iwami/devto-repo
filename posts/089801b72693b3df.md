---
title: 'AWS re:Invent 2025-Unlock the power of Kiro steering: Your blueprint for scalable development-DVT340'
published: true
description: 'In this video, Allie Fortman and Matt Laver from AWS explain Kiro steering, a critical feature for maximizing value from Kiro IDE. They describe how steering documents provide LLMs with essential contextâ€”addressing challenges like limited control and perceived poor code quality. The session covers foundational steering files (product, tech stack, structure) that Kiro auto-generates, plus custom steering files for domain-specific knowledge like logging standards and security policies. Best practices include organizing documents by domain, using 3-5 documents per task, treating steering files as code with version control, and leveraging MCP for centralized documentation. Chandra Sreeraman from Nielsen Sports shares their success using steering documents to enforce test coverage, documentation standards, and logging policies across applications. The newly announced Kiro Powers feature enables one-click installation of prepackaged steering files, MCP servers, and hooks from partners like Figma and Stripe.'
tags: ''
cover_image: 'https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/0.jpg'
series: ''
canonical_url: null
id: 3093146
date: '2025-12-08T20:44:17Z'
---

**ðŸ¦„ Making great presentations more accessible.**
This project enhances multilingual accessibility and discoverability while preserving the original content. Detailed transcriptions and keyframes capture the nuances and technical insights that convey the full value of each session.

**Note**: A comprehensive list of re:Invent 2025 transcribed articles is available in this [Spreadsheet](https://docs.google.com/spreadsheets/d/13fihyGeDoSuheATs_lSmcluvnX3tnffdsh16NX0M2iA/edit?usp=sharing)!

# Overview


ðŸ“– **AWS re:Invent 2025-Unlock the power of Kiro steering: Your blueprint for scalable development-DVT340**

> In this video, Allie Fortman and Matt Laver from AWS explain Kiro steering, a critical feature for maximizing value from Kiro IDE. They describe how steering documents provide LLMs with essential contextâ€”addressing challenges like limited control and perceived poor code quality. The session covers foundational steering files (product, tech stack, structure) that Kiro auto-generates, plus custom steering files for domain-specific knowledge like logging standards and security policies. Best practices include organizing documents by domain, using 3-5 documents per task, treating steering files as code with version control, and leveraging MCP for centralized documentation. Chandra Sreeraman from Nielsen Sports shares their success using steering documents to enforce test coverage, documentation standards, and logging policies across applications. The newly announced Kiro Powers feature enables one-click installation of prepackaged steering files, MCP servers, and hooks from partners like Figma and Stripe.

{% youtube https://www.youtube.com/watch?v=Ap0tXXvyn3k %}
; This article is entirely auto-generated while preserving the original presentation content as much as possible. Please note that there may be typos or inaccuracies.

# Main Part
[![Thumbnail 0](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/0.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=0)

### Introduction to Kiro Steering: The Evolution of AI-Powered Development

 Good morning everyone. You're on day four. You've almost got this. Put your headphones on. Day four, we're almost there. I am so ridiculously excited not just to speak to you, because that's exciting too, but I'm excited to actually talk about Kiro steering because I think this is single-handedly the most important concept for you to know to get the most value out of Kiro. I'm Allie Fortman. I'm a go-to-market specialist here at AWS focused in the Next Generation Developer Experience, which is a very long way of saying I speak to customers all day about Kiro.

[![Thumbnail 80](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/80.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=80)

So, show of hands, you guys know what Kiro is. I would hope, I mean there's a big haunted house in the expo that you might have walked by a few times. So this is our artificial intelligence powered IDE. Steering is part of this and that's why we're going to focus really primarily on steering in Kiro today.  So you might have seen this if you've been to a few different Kiro slides. We've kind of kept this in all of the slide decks because it's important to understand where we came from and where we're going.

In 2023, it was really the advent of AI into IDEs as an inline code completion. So really that was helping the developers finish their line of code, maybe write a couple lines of code, move forward. In 2024 at re:Invent last year, we had announced many agents within Q Developer that were more, could do a task really well. So like slash test could look at your code base and figure out what unit tests you needed to have in there, and it could do that really well. So I kind of call them single serving agents, but they were the assistants in those limited scope tasks.

Early in 2025, we released into AWS's hands the CLI and we sandboxed this. We did a little dog fooding of our own before we released it out to anyone who's been playing with the Q and now Kiro CLI. And this was really to get an idea of how developers want to work with an agent in more of a pair programming vibe coding kind of methodology. So that's where we have seen 2025 headed, is more about how are you working hand in hand with an agent for complex big tasks.

[![Thumbnail 170](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/170.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=170)

[![Thumbnail 190](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/190.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=190)

### The Promises and Challenges of Agentic Development

 So there's some promises we talk about with agentic development.  The first, autonomy. You as a developer can work with an agent. That agent can go ahead, start doing the work, and you can go do the stuff that builds value for your organization, so you can trust that the agent can work completely autonomously. True collaboration in this pair programming vibe coding methodology. We expect that you as developers can sit with the agent, get involved when we need to, really have that true pair programming feeling like you're actually working with another human being.

[![Thumbnail 210](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/210.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=210)

[![Thumbnail 230](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/230.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=230)

 Finally, all of these LLMs have been trained on huge amounts of data, so you expect higher quality from the LLMs. They know how to write a Python function. They know React. They know Java, so you expect the quality to be high when you're working with these LLMs.  So how do you feel about working with an LLM? How many of you have had this happen where you're just like, what is it doing? Show of hands. There we go, yes. So those promises came with challenges and I talk with customers a lot every day.

[![Thumbnail 250](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/250.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=250)

[![Thumbnail 280](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/280.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=280)

 The first one is the scaling AI development one. The LLMs do these really small tasks really well, but when you add complexity of what you're trying to get done in your project that day, or your code repository is really, really big, these LLMs seem to fail at these highly complex tasks.  Limited control. Now, I'm a recovering product manager, so when I vibe code it's a disaster anyway, but you know what is really irritating? When I start vibe coding and it starts going through unit testing, it keeps failing unit tests and then it keeps trying to fix it, then it runs it, it fails, and all of a sudden I have lost complete control of the agent and I have to then control C out of it.

[![Thumbnail 310](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/310.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=310)

In some ways, this promise that we had has actually made it less controllable  by us as the developer community. The code quality, and this is a perception thing, and this is why I think steering is the most important part of Kiro, the code quality that is then produced from the LLM seems like it's not at the bar that you expected it to be, and then you think this AI assistant agent is just garbage. That is because it's not getting the context it needs.

[![Thumbnail 340](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/340.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=340)

[![Thumbnail 350](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/350.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=350)

### Why Steering Matters: Understanding LLM Limitations

So why does steering matter? Think about steering as having two hands  on the wheel of a car in between your lanes. When you take your hands off of that steering wheel, that car is going to go where it wanted to go,  right? It's going to do its own thing. So steering, that concept of being able to steer your vehicle, is the exact same concept in Kiro of steering the agent for what you need it to do.

[![Thumbnail 370](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/370.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=370)

So let's talk about why the perception of code quality is bad and limited control and everything we talked about with those challenges.  LLMs are stateless. What they may have is your prompt, your code, like a prompt that you've asked, probably a subset of code you've pushed into the prompt, and whatever context of the chat history that has not been compacted at that time. So there is no memory. The LLM really has no memory at any given time, right?

[![Thumbnail 410](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/410.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=410)

We as humans are very good at ambiguity resolution when we're talking to each other. So when we say things like fix this bug and we're talking to each other, we can figure out which bug we're talking about.  But when you go to the LLM and you say fix this bug, the LLM may not ask you which bug. It's just going to go start looking at your code and trying to figure out where the bug is and start fixing things because it really wants to be your friend, and it's like a toddler who just really, really wants to please you. So ambiguity, it doesn't do great with. And then finally, this is big, it doesn't have the domain knowledge of your organization, so it only has the generalist idea of what it should be doing, but it doesn't know what your coding, testing, security guidelines, or logging standards are, so it's missing that domain context.

[![Thumbnail 460](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/460.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=460)

### Two Types of Steering Files: Foundational and Custom Documentation

So how do I steer an agent?  We have in Kiro two ways that we talk about implementing steering. The first is foundational, and these are documents that Kiro can create with a push of a button based on the code repository you have loaded into that IDE at the time. Then we have custom steering files, and I'm going to go into this, but these custom steering files should be the ones that have your domain knowledge, your organization-specific information.

[![Thumbnail 490](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/490.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=490)

So for the foundational steering,  when you press that button in Kiro, you're going to get three files. It's going to create a product file, which I liken to like a PRD or a product requirements document. This document has what this thing does, what this project does, who the target users are if it can figure it out, more of that high-level business objective of what this project is. Then it's going to go into the technology stacks, so it's going to be able to look at the code base and say, okay, these are the frameworks that are being used, these are the libraries, the tooling that this project, this repo is using, and it's going to create a tech markdown that has all of that. And then it has the structure, and the structure is going to be your file organization, your naming conventions, the stuff it can really take out of the existing code base.

[![Thumbnail 540](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/540.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=540)

But custom steering files are just as important, and you can use Kiro  and its MCP capabilities to point to where you may have centralized documentation that explains what your testing frameworks are, what your logging requirements are, and you should be using Kiro and the MCP capabilities to then build out these custom steering documents that have now your domain-specific information.

[![Thumbnail 570](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/570.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=570)

So what does that then look like now  when you have a prompt with the code snippet and the chat history? It's also looking at the steering documents that both you've created foundationally and the custom steering documents. It now has all of this memory of previous conversations because these are stored now in markdowns, and it can then provide a more relevant response. And this is where I get back to, I think it's more a perception that the code quality is bad because we have not learned how to actually provide context well.

[![Thumbnail 610](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/610.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=610)

So what does this mean for the long run? You're  going to have consistent code generation. Before, if you're not using steering docs, when you ask a question of the LLM based on what day it is and what you might have been talking about, and you ask that same question the next day, you might not get a consistent response from the LLM. Steering docs provide you a better consistent experience. Reduced repetition. You don't have to keep repeating yourself when you're talking to the LLM because it now has the context of the stuff that really matters, and you don't have to keep reminding it, well this is my naming convention, can you still do this please?

Team alignment, and we're going to get into this later on, how important it is to look at steering files as code and be using that across your team so all of the team is using the same steering files and the same repos, and they're not getting inconsistent code responses throughout. And then scalable project knowledge. Very important, steering documents are not static, they are living breathing documents just like your code. So it's going to start growing as you are working on your code base as well and everyone in your team is working on your code base. So thank you. I'm going to hand it over to Matt to get into some of the details.

### Getting Started with Foundational Steering Files: A Demo and Best Practices

Hi. Well, you've heard from Allie about why steering matters, what the value proposition is, why we should be using it. I want to dig a bit deeper now into a demo of how we can start getting going with this, but also start talking about some best practices for steering documents as well. My name's Matt Laver. I'm a senior specialist architect based in London, and my role really is to help customers get the most out of using agentic AI tools across the whole SDLC.

[![Thumbnail 730](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/730.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=730)

[![Thumbnail 740](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/740.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=740)

[![Thumbnail 750](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/750.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=750)

[![Thumbnail 760](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/760.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=760)

So Allie mentioned foundational files. So when should we use these? What these are really great for is if you've got an existing codebase.  You can open Kiro, open your file, open your project, and then you can get going with the foundational steering files to actually start documenting your existing codebase.  So how does this work? Well, to get started it's really simple. We just connect to the Kiro menu here and then hit generate steering docs. What this will  do is this is a system prompt that we have within Kiro, so it's a function of Kiro, and it will start documenting your code, start reading the files.  So this could be your code files, it could be any documentation you have there, going through it, and very quickly it will start to generate the steering files for your system.

[![Thumbnail 780](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/780.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=780)

[![Thumbnail 800](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/800.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=800)

[![Thumbnail 810](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/810.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=810)

And it'll start with the product file. So this is really the what and why of your application. What does it do? What's the business case, the justification for it?  So when we start adding new features, if they don't align with what's in this product document, then this could be an alarm that starts to get rung. Then we've got the tech stack. These are like the building blocks of how we build our application, our tech stack, the programming languages we're using, the SDKs, the libraries that we're using. So again, when we start building more features within our application,  Kiro is going to know, oh well this is the tech stack that we're using. I'm not going to bring in another library that does the same thing because we've already got that here.  We're using a specific version, so there's idioms within those languages, there's versions, so we'll know.

[![Thumbnail 820](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/820.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=820)

And then finally, the structure, the recipe, how do we build our application.  It kind of ties the product, the business requirements with the tech together, and then actually gives us some documentation about how our application works. This is what I do when I work with a new code base that I don't really understand how it works. It's great, it gives me a sort of high level. It's not so deep that it's going to take me a long time to read, but it gives me enough information to get a good grasp of what I'm working on, the projects I'm working with.

[![Thumbnail 850](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/850.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=850)

It's kind of like a memory bank that I've created here. I've started to build it, this is like the  memory bank of my application. How do things work, the product description, the technology, the recipe for building it, the project structure, where the files fit together, what design patterns I'm using, the architectural idioms. So by default it's located in the project structure. But it doesn't have to be. What if I wanted to build a series of microservices or products that have the same sort of bake, the same sort of patterns? Well I could create these globally as well. So that I've created it once with my, maybe my exemplar application, which is what good looks like. I could create global steering docs and then I could use these docs to actually create further blueprints or further projects based upon these steering docs to replicate some of the good behavior, the knowledge, the tech stack that I'm using that I know that works. So these can be chosen, these can be either locally in your project directory or globally in the dot Kiro steering within your user directory.

[![Thumbnail 910](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/910.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=910)

So we'll talk about when should you use one over  the other and dive into a few best practices now. Some of these are lessons we've learned from the field, but also from using Kiro internally within Amazon ourselves. We've got quite a lot of knowledge that we've learned from actually using Kiro and steering docs over this time.

[![Thumbnail 930](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/930.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=930)

### Best Practices for Workspace and Global Steering Documents

So let's start with workspace documents. When should you use them?  Well, if we're working on a specific project, there's a number of reasons why we might want to use guidance specific to our project. Maybe there are things that are specific to this project that are different to other projects. It might be specific domain knowledge about it. Maybe we're using a specific library for a reason, or the way we've made design decisions, there's a reason behind it, so we want to actually tie that to the project we're working on. Maybe the team that we're working on works very differently to another team in the organization, and we have our ways of working, you know, norms that we like to use, the libraries, the ways we work, the way we log. So that might be specific for us. Maybe we deploy slightly differently, maybe we use a different methodology for deploy. Maybe we target cloud or we have a different, we work in containers instead of servers. So we might have specific ways of working that are specific to this project.

[![Thumbnail 1000](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/1000.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=1000)

So this is a great way, if you're thinking about should this be global, should this be project specific? Well, have a think about where does this knowledge belong, does it belong with the code? Or is it something more general? Because if it's something more general, then maybe we should think  about using global steering docs. So these could be like maybe you're an architect and you want to put some global standards across your code base. Across the teams, these are our security standards. There's standards about how we design architecture, how we build, maybe we've got some kind of design guidelines on how the software fits together, and we want to roll it across our teams. Or maybe this is a good fit for a global steering doc, so all the code that we're going to write, all the projects we're going to work on are going to adhere to these standards globally.

What about general best practices? Do we want to be TDD? Do we want to be BDD? Do we want to actually adhere to any of these sort of programming paradigms that we want? Are we event driven? When we're building new applications, is there a blueprint for how within our organization we want to start building? Well, again, this is a good case for a global steering document where you can actually define guidance across all of your teams. So when you're operating with Kiro and LLM, you can actually apply that goodness across the teams.

[![Thumbnail 1070](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/1070.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=1070)

But what should we put in these documents?  How should we do this? Well, we've got the foundational documents which we use, which are working on an existing codebase, so that's great. But what about if we've got specific requirements as well that we want? So this is where custom steering comes in. We can define our own custom steering, we can define as many of these as we like, but how should we organize them? Well, try to think about organizing them per domain, break them down. It's a bit of an anti-pattern to have one large custom steering document that contains all the things we need to know about our application. Why is that? Well, it's really hard to maintain. Remember, these are for you as an individual to read, your team needs to read them. This is documentation for how you work as an organization, as a development team, not just for the LLM.

Break them down into domains. A really good example here is logging standards. Now I've worked as a software developer for twenty plus years, and I can tell you this, that when I've worked in many of these places, the logging standards have been different from service to service, team to team. You know, the way we log the date times, is it UTC or something else? Do we have correlation IDs? What about the metadata? Are we using structured logging? These tend to vary and it causes a lot of headaches. So what if we could define our logging standards in a file and we could work on that with our architects, our teams, our best practices. This is how we want to work. And then we can share these logging standards amongst our teams to roll out this good practice. This is how we want to log everything within our organization because it makes sense, we can tie all the data together centrally. So keep them focused.

[![Thumbnail 1170](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/1170.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=1170)

What about, what's another good way of actually defining logic within our steering docs?  We'll provide examples. If you're talking to a colleague about, oh, how do I solve this problem? You can explain it to them, but you can also give them an example. Yeah, this is how you do it. This is how we think the code should look like. This is what we think is good. Now one of the questions I get all the time is, well, the LLM, you know, I'm asking it to solve some code within our organization, and it's coming back with code that I don't like, it's not how I want it to be implemented. Well, have you provided the LLM with the context so it knows what good looks like and what to avoid? Because if you haven't,

LLMs are really good with ambiguity, but they don't know what's inside your head. In order to address that, start adding examples to your documents so that the LLM knows what you expect. Reduce the ambiguity with concrete examples. You don't need to boil the ocean here. Start small and keep adding to them. These documents are going to evolve along with your codebase. As soon as you start getting results where you think it's a hallucination or it's done something that you didn't like, correct it, put it in the steering document, and then hopefully the next time you'll get the right results.

[![Thumbnail 1240](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/1240.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=1240)

[![Thumbnail 1250](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/1250.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=1250)

 Use good examples and use what to avoid, so good and bad. Make sure that's clear in the documentation.  But how much should we put in here? Well, remember you're working with LLMs. Context is really critical here. We don't want to fill up our context with lots of guidance and steering and then have no room for our actual development space. So what could we do? Well, we could work with a model with a bigger context window, right? But surely that's just kicking the can down the road.

Let's think about managing our context better and let's index on quality rather than quantity. The reason is, if you feed too much into the context, too much into the window, and then you start asking the LLM to solve problems for you, write code, well, it's got a lot of information there. How does it know what's good, what's bad? What if you've got contradictory information in that context window? So really try and slim that down as much as possible.

I talked to people about this and some of the problems they have where the context window is flooded. Well, if you're working on a task, maybe group the context or the steering files that you need for that task. So for example, if I'm working on a full stack application, I've got a React front end, I've got a Golang back end, I've got infrastructure as code in the repository using Terraform. If I've got steering documents that show me how to write good React files, good Go files, good Terraform, and I'm actually working on the DevOps part, I'm working on the infrastructure as code, well, what value is there in putting the React steering docs in with the Terraform when I'm actually working on the Terraform?

So try and decide how you use the steering docs and when to use them. A good rule of thumb, if I'm sticking my neck out here, is three to five documents when you're working on a particular task. But rotate them. Within your software development, you've probably got a whole set of these guidance documents, and you can just bring in the ones that make sense for the task you're working on at that point in time.

[![Thumbnail 1370](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/1370.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=1370)

Who here's from the UK? We got anybody from the UK? Yeah, like me?  I can see a few hands up here. There's a phrase in the UK called don't teach grandma to suck eggs, as some of you might know this phrase. This can actually apply to LLMs as well. So when we're writing our steering documents, don't tell the LLM what it already knows. It knows how to write Golang code. It knows how to write Python. It knows how to write React. It knows basic syntax explanations. It knows what REST is.

Don't explain things to the LLM that it already knows. It's knowledge rich. It already knows that a modern LLM will be able to write code better than I can. So I don't need to teach it the basics, but what it doesn't have is domain knowledge, domain specific knowledge about the way I work, about my business, about my organization and my projects. It doesn't know about the way my design patterns I've chosen in my application are there. They might go against the norms of common convention, but that's because we've decided to do it that way.

[![Thumbnail 1440](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/1440.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=1440)

So don't put standard libraries, don't tell it how your logging library works, it knows. But what should we put in there? Well, think about business specific logic.  You've made design decisions as an organization, as a team. Put the justification for why you build software the way you do it in there. If you've got custom APIs, like how do you use your APIs, what are your conventions within your organization? Do you put correlation IDs in there? What about the ways you actually format the data? Should they be specific, because the LLM won't know unless you tell it.

This is domain specific information that you need to pass in. And actually use examples. Code examples are really key here. This really helps the LLM with an actual concrete example. So these are things it doesn't know. And this is why sometimes you get outputs from an LLM that you weren't expecting, that you don't agree with. Well, probably it didn't know. It was using its general knowledge. It wasn't using specific knowledge, so you need to provide specific knowledge on how to work.

[![Thumbnail 1490](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/1490.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=1490)

 Ali mentioned this earlier, this is critical. Your steering documents are just as important as your code. This is your guidance for how you're building your applications. So don't let them rot, don't write them once.

Treat them with the same care that you do with your code. Get your colleagues to review them as a pull request. They're critical that these are right because you're going to be using these when you build your software, fixing your bugs, and developing new software. They're super critical.

[![Thumbnail 1530](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/1530.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=1530)

### Advanced Steering Techniques: MCP Integration, Inclusion Modes, and Kiro Powers

So what about  if we want, we've got information that's not local, and we want to actually centralize it? Because some of the problems with steering documents could be, well, we've written our architectural guidelines and we've stored this locally in our project directory, but they're being updated all the time. How do we keep the single source of truth and bring that into our projects when we're working with them? Well, there's a number of ways that we can do here.

How many of you are working with MCP at the moment? I mean, I think it's fairly widespread as a software developer. You've probably already played around with MCP, if not, you're using it already. MCP is like the USB of AI agentic development. You can just plug and play data sources into your development environment and bring in data sources, be that from a wiki, from a project management system, from source control, like your git control system.

So what if you have a centralized cloud center of excellence or architectural guidance, or your team has a centralized repository where you keep good standards? Like these are the logging libraries we use, this is how we log, this is how we architect, this is how we build our CICD pipelines and how we test and what the guidelines are, what the test coverage should be. Well, why don't you put those in a git repository and then you can use MCP to actually bring them into your steering documents dynamically, so you can dynamically get the latest information that you can pass in to the context.

[![Thumbnail 1620](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/1620.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=1620)

So how do we do that? Well, we can actually reference  that within our steering documents itself. So we can actually put guidance so that the LLM knows how to call the MCPs, the actual tools within the servers. So the way this works is that you can load it already and then you can put guidance here. So for example, you're working with a shared library that maybe another team has developed internally. So you can reference it from the git repository and say, yep, this is for when I'm working in this area, this sort of domain, then I need you to reference this tool and this server.

[![Thumbnail 1660](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/1660.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=1660)

It's not the only way. There is a simpler way as well. You don't need to use MCP.  What if you're working with another library? Maybe it's internal as well, so it's not in the public domain. You could check it out in a directory adjacent to your project, and then you can use a relative file path reference to reference it. So you can bring context directly in via a steering document. This is a library we use internally for solving problems internally. We've built our own one because it's unique to our business, our own domain. I'm going to check it in. It's in the file folder within my projects directory, and I can reference it here, and then I can bring in centralized knowledge into my project that I'm working on based on this, using a file reference.

This is super useful because often, you know, if you're like Amazon, we have projects that we have and we have reusable libraries that we share amongst our teams, and we can just reference those this way. And so we can bring that knowledge and that domain knowledge and pass it into Kiro so it understands how our systems work.

[![Thumbnail 1720](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/1720.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=1720)

Probably if you're like me, you find writing  documents quite challenging, quite tricky. It's really hard. We're not all technical authors. Writing a document is tough. Writing a good document is tough. So why don't you use Kiro to write it, the LLM to write it? How do you get started with these documents? Don't let that be a barrier that stops you. Start with something small.

I need to start writing some error handling documents, guidance for my team. I'm going to get Kiro to look at what we've got so far and get Kiro to write the document for me. Then I'm going to edit it. I'm great at editing, but I'm terrible at writing from scratch. So why not describe the behavior that you want and get Kiro to write it for you? It knows how to write it better than you do probably because it's going to know how to work with the LLM as well. So get it to start writing it and start small.

Don't document everything. Remember quality over quantity. Make sure you make that clear when you're writing these. But document the pain points, the domain knowledge, the information that you want to use when you think about how you're going to write your software, solve your tasks, so that the LLM knows this is the information that's critical to how I build this.

[![Thumbnail 1790](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/1790.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=1790)

[![Thumbnail 1800](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/1800.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=1800)

Okay, so we've got a few more best practices here.  So within Kiro as well, within the steering documents, we have something called inclusion modes. 

By default, when you create a custom steering document, it's included in all your interactions with the chat. This is really great for project-wide standards within your project, architectural principles, or anything that when you're operating with the chat window asking it to solve something, you want the steering to be included. The default inclusion is always there. You can explicitly say it's always included, or by default it's there anyway. So just think about when you're adding these documents, what the scope should be, because sometimes you might want to match it to a specific file.

[![Thumbnail 1840](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/1840.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=1840)

It's  very common for you to have multiple different file types within your project. For example, this one's wildcarded on Rust files. The way we write Rust code and design Rust is very different to how we might design our TypeScript or our back end, our Terraform, or maybe our SQL schemas. So why would we use the same context for that? It's a waste of our context window, so let's scope it to the task at hand so we're actually really focused on giving the context that the LLM needs for the project and the task that we're asking it to do.

[![Thumbnail 1890](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/1890.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=1890)

So file-specific rules, domain-specific standards. I'm working on a document, I'm going to wildcard this on Markdown or Mermaid or something like that. I don't actually need the context of how to write code in other languages or other parts of it while I'm working on this particular task. So this is situational.  There is another, a third option. Probably, like me, you'll be working on projects where you have incidents or situations where you have to do a bit of occasional work where you're maybe debugging something or you're doing something specialized, or maybe you're doing a bit of data transformation. I need to transform some files from CSV into JSON, or I need to convert something.

This is quite a useful task. I'm going to do it seldomly, but my teammates might want to do it as well and it's related to the project, so I'm going to put this knowledge and this guidance in the project so that it's useful for them. So kind of like a runbook or something like that. I can include it as manual. So if I put the manual inclusion there, I can still keep this guidance as documentation within my project, but then it's there available for anybody in the team who needs to perform these tasks and can use them, and they can bring them into the context when they're actually working on it. So this is really, really useful.

[![Thumbnail 1960](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/1960.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=1960)

Now, we had something announced yesterday as well related to steering. Who's heard of Kiro Powers? Did you read the announcement about this?  So Kiro Powers was announced yesterday morning. If you update your Kiro instance, you'll have this availability here. What this is, is a prepackaged bit of knowledge that you can build into Kiro to actually expand the capabilities. And what this includes are really three aspects at the moment: MCP servers, steering files, and hooks. So you can one-click download these into them, and we've got a lot of partners that have already released these already, so you can one-click install them.

So for example, if you work with Figma or Stripe or DataDog, you can bring the power that gives the guidance from the partner, how they intend this to be used with an integration, so you can connect to their services as well and get additional knowledge. You can also build your own. So for example, within your organization, you can build these self-contained packages which give you, maybe you've got your own MCP servers that you think are valuable to your teams, and you can just allow, you can build this with the steering files and the hooks to actually in a centralized single package that you can use and distribute within your teams, and so you can one-click install them. So I recommend you have a look at this and explore this as this is a super useful facility within Kiro.

[![Thumbnail 2070](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/2070.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=2070)

### Nielsen Sports' Journey: Implementing Kiro Steering for Enterprise Development

With that, I want to introduce Chandra from Nielsen Sports to talk a little bit about his journey with Kiro and how he's used it within his organization. Thank you. Thanks, Matt. It was great. Hope everyone can hear me. Yup, thanks. So  back when I was a pup getting my journey started in the tech world, one of the first assignments I had was to build some applications for a mainframe. And back then, what we had to do was to get out this graph paper, lay out the fields and the labels, get the XY coordinates, and put it into the system, and then start coding basically.

Not knowing the status quo, I felt this was really a waste of time. So I developed a bunch of scripts that helped developers automate this process.

Automating this process freed me from doing what I do best, which was generating a bunch of bugs, basically. Thankfully, 40 years later, we don't have this kind of problem. But today, enterprise development has its own challenges.

[![Thumbnail 2130](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/2130.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=2130)

Hello, I'm Chandra Sreeraman. I'm from Nielsen Sports.  Our team runs the client-facing applications. Nielsen combines its media research and technology expertise to provide strategic guidance to sports, esports, and entertainment properties. So if you think of an example, if you see or watch a basketball game, it's broadcast in multiple markets. NBA owns the content, and we have logos appearing during the content, so brands advertise on the court as well as on the apparel and stuff like that.

[![Thumbnail 2200](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/2200.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=2200)

What we do is we process this information, extract the logos using sophisticated machine learning strategies, combine it with audience data, and then provide some valuable insights to the leagues, to the teams, brands, and agencies. As you can see, it's quite a lot of data. We process  half a billion social media posts. We help with almost 100,000 to 200,000 sponsorship deals in extensive markets, over 50 markets, including Europe, US, Latin America, and so on.

[![Thumbnail 2240](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/2240.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=2240)

So we have unrivaled access to the industry data, and we are trusted by some of the biggest brands as well as leagues in the world. And what this means is that we get quite a lot of data, and a lot of data means a lot of applications that go with it. And as you might be aware,  managing these applications, maintaining these applications, or expanding these applications is not just about coding.

[![Thumbnail 2300](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/2300.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=2300)

In the modern enterprise, we need to take care of standards, security, policies, and test coverage, logging, telemetry, all that kind of stuff. And at Nielsen, we have a very mature operating model for all these. But then managing it across all our applications is still a challenge. So to that end, what we did was we wanted to revisit this, and to maintain this ecosystem of diverse and complex applications, we felt we needed a paradigm shift, not just with coding, but all the associated stuff, especially with agentic AI in the works. 

And that's why we were eager to get our hands on Kiro. We were given early access to Kiro, and when I first started with Kiro, the developer in me came out. I was just thinking about all the pet projects that I had in the back of my mind. I was just vibing, I was specking, I was doing MCPs, building useless agents to annoy my colleagues, all that kind of stuff. And to be honest, at that point in time, I didn't pay much attention to the steering documents, just building everything.

[![Thumbnail 2370](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/2370.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=2370)

But then we realized that Kiro had more to offer than just writing code. Kiro has been built from the ground up to take care of enterprise developments like ours, including all the stuff I talked about. And the steering documents seemed to be the perfect way to encode our strategies, our policies, our coverages, and so on. And so to this end, what we did was we  took a sample project. We wanted to analyze the sample project, encode our strategies, and check out how the agents worked out.

So some of our brilliant developers here encoded all this, and it was a very simple ask that we had. We wanted to ensure that it has proper test coverage, document fidelity, as well as proper logging, extensive logging. So we used the steering documents to encode this strategy.

[![Thumbnail 2440](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/2440.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=2440)

[![Thumbnail 2450](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/2450.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=2450)

For example, we wanted to tag all tests together. This particular project had test coverage, but the tests were scattered, and some of them didn't have proper tagging. We wanted to group all the tests together and then run them as a group. We also wanted to improve the documentation and logging standards on this, so we encoded it. We let the agents run, and as you can see,  the results have been pretty positive. We've seen some really great results in terms of test coverage, documentation, logging,  and policies.

Our developers have embraced Kiro passionately. They've been using Kiro to develop a lot of functionality. Our hope is that by focusing on building better steering documents, we build better specs, and this will help the agents generate code that is compliant, secure, and testable by default. In addition to this, AWS has been a great partner. They've been helping us in our agentic journey every step of the way, not just for the developers. We are bringing in product teams, data teams, as well as DevOps teams into this mix.

We feel that Kiro is the foundational step towards a fully automated governance plane with the steering documents. Looping back to what I mentioned at the beginning, we feel that the steering documents are the script that would help our developers reach their flow state without sacrificing any of the aspects of policy management or documentation. In fact, the steering documents help us enhance these aspects of the development process. Our journey ahead is about scaling the success, and the next step is to expand it to our other products in our portfolio. We want to develop a proper etiquette and grammar included that everybody follows the same etiquette.

At Nielsen Sports, we empower the sports industry with data-driven strategies that fuel growth and success for our clients. Together with AWS and Kiro, we feel that we are in a great place to continue this journey of excellence. Thank you all for attending this session. Allie will give you a few pointers on the next steps. Thanks, Allie.

[![Thumbnail 2590](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/2590.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=2590)

### Next Steps and Closing Remarks

Yeah, thank you, Chandra. I have enjoyed getting to know Chandra and this journey at Nielsen Sports, and it's just been great to hear the success they've had with Kiro there. So you're on day four.  There's not a lot of opportunities left at re:Invent, but you still can go to the House of Kiro that's at the Venetian. There's the kiosk in the AWS Village that's in the Expo at the Venetian. Today at 4:30 in the Builder's Loft, which I think is right over there, you could do a Kiro whiteboarding session if you want to continue your learning at re:Invent.

[![Thumbnail 2620](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/2620.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=2620)

[![Thumbnail 2640](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/089801b72693b3df/2640.jpg)](https://www.youtube.com/watch?v=Ap0tXXvyn3k&t=2640)

However, if you already have plans and you need to do something else at re:Invent, you  can continue your self-guided learning with Skill Builder. There's plenty of Kiro learning paths out there, so take a snap of that. Okay, I'm just kind of seeing if anyone else is. Okay. And then  Matt, Chandra, and I thank you all for taking the time out this morning to come see us. It was, again, I think it's the coolest part of Kiro, and I think it's the most important part. So thank you.


----

; This article is entirely auto-generated using Amazon Bedrock.
