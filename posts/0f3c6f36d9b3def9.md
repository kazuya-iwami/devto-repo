---
title: 'AWS re:Invent 2025 - Introducing Nitro Isolation Engine: Transparency through Mathematics (CMP359)'
published: true
description: 'In this video, AWS introduces the Nitro Isolation Engine, a formally verified enhancement to the Nitro System that provides mathematical certainty of customer workload isolation. J.D. Bean explains the evolution from Xen-based virtualization to the current Nitro System, highlighting its security features including no operator access to customer instances. Karimallah Raslan details how the Nitro Isolation Engine compartmentalizes isolation functions into a separate code base built in Rust, operating at a lower exception level while demoting the Nitro Hypervisor. Nathan Chong demonstrates the automated reasoning approach using Isabelle proof assistant, proving memory safety, absence of runtime errors, functional correctness, and confidentiality across all possible system states. The solution is available in preview on Graviton 5 instances.'
tags: ''
cover_image: 'https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/0.jpg'
series: ''
canonical_url: null
id: 3093181
date: '2025-12-08T21:14:44Z'
---

**ðŸ¦„ Making great presentations more accessible.**
This project aims to enhances multilingual accessibility and discoverability while maintaining the integrity of original content. Detailed transcriptions and keyframes preserve the nuances and technical insights that make each session compelling.

# Overview


ðŸ“– **AWS re:Invent 2025 - Introducing Nitro Isolation Engine: Transparency through Mathematics (CMP359)**

> In this video, AWS introduces the Nitro Isolation Engine, a formally verified enhancement to the Nitro System that provides mathematical certainty of customer workload isolation. J.D. Bean explains the evolution from Xen-based virtualization to the current Nitro System, highlighting its security features including no operator access to customer instances. Karimallah Raslan details how the Nitro Isolation Engine compartmentalizes isolation functions into a separate code base built in Rust, operating at a lower exception level while demoting the Nitro Hypervisor. Nathan Chong demonstrates the automated reasoning approach using Isabelle proof assistant, proving memory safety, absence of runtime errors, functional correctness, and confidentiality across all possible system states. The solution is available in preview on Graviton 5 instances.

{% youtube https://www.youtube.com/watch?v=b0P55gHhG4g %}
; This article is entirely auto-generated while preserving the original presentation content as much as possible. Please note that there may be typos or inaccuracies.

# Main Part
[![Thumbnail 0](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/0.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=0)

### Introduction to CMP 359: The Nitro Isolation Engine and the AWS Nitro System

 Hello, and welcome to CMP 359, Introducing the Nitro Isolation Engine: Transparency through Mathematics. We appreciate you all coming to join us here this morning, and we're very excited to talk with you about the Nitro Isolation Engine. My name is J.D. Bean. I'm a Principal Architect in our Compute and ML Services organization. I'll be joined today by Karimallah Raslan, a Senior Principal Engineer in our Nitro Hypervisor organization, as well as Nathan Chong, a Principal Applied Scientist in our Automated Reasoning group.

The Nitro Isolation Engine represents one of the most significant changes and new developments to the Nitro System design since we first introduced it. Before we get to speaking about what the Nitro Isolation Engine is and what it changes in our design, I want to spend a few moments talking about the Nitro System so that we can understand the story in context before we reach this new chapter.

[![Thumbnail 70](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/70.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=70)

 So what is the AWS Nitro System? Many of our AWS customers have heard of this term and have some familiarity with it. The Nitro System is how we run virtualization at AWS. It's the underlying platform that powers all of the virtualization servers that we've released since 2018 and onward. We launched the Nitro System to the world in 2017, but it had been the result of a sustained development process that began in 2012. The Nitro System is based on purpose-built custom hardware, software, and associated firmware. It features a hypervisor based on KVM that's been custom built for our specific cloud needs and is powered now by its sixth generation of custom Nitro silicon.

### Evolution from Xen to Nitro: Reimagining Virtualization at AWS

The image you see on the screen now represents the previous version of EC2. You'd have to go back quite a while to find an EC2 instance that we released that looked like this at a high logical level. Initially, we used the Xen hypervisor to perform hypervisor functions, and in the Xen model, as you may be familiar, it relies upon another component called Dom0, which is a copy of a general purpose operating system that enables the hypervisor to provide the useful things you need from a virtualization system, things like input/output orchestration, security, monitoring, all these types of features.

We built our business and established relationships with our customers using the Xen system, and we had fundamentally pushed it to its limits. We wanted to reinvent and reimagine the way we performed virtualization to enhance the security, the performance, cost efficiency, and the rate of innovation that we could deliver to our customers in EC2. We began that process by looking at what we could do to remove some of the components that AWS needed to run on our system mainboards and move them into a new, highly separate accelerated hardware domain.

Powered by these underlying Nitro devices, we began with our VPC networking. Previously, the VPC networking was a function provided by Dom0. We moved this over into an accelerator card so that we were no longer running the features of translating between physical hardware devices and software-defined networks that power the underlying AWS infrastructure and then translating those into interfaces that provided the VPC networking experiences to our customer EC2 instances. So we moved that over as the first step in our Nitro System journey, and it was a smashing success.

[![Thumbnail 250](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/250.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=250)

 Soon after, we continued our work to move on and actually bring the same sort of experience and translation to our EBS remote block storage service. Again, we had great success and great wins from this. Our customers benefited from it, and our systems and operational excellence similarly benefited.

[![Thumbnail 270](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/270.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=270)

 So we moved along to local storage. These are the hard drives that are physically connected and locally resident for some of our EC2 instances.

[![Thumbnail 290](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/290.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=290)

 At this stage, we looked and we saw that really the only purpose we were using Dom0 for was to provide just this management, security, monitoring, orchestration, the thing that makes an EC2 server part of an overall service and not just a virtualization system. So we moved that over now to these new Nitro cards, this new offload hardware. We looked at our system and realized that the Dom0 no longer played a role. So the Nitro System was born in this final step, in this final evolution. We replaced the Xen hypervisor and introduced the Nitro Hypervisor based on KVM,

[![Thumbnail 310](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/310.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=310)

[![Thumbnail 320](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/320.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=320)

 especially minimized and customized for our needs and high security bar.  The Nitro System today is the foundation of AWS. When you ask yourself and picture in your head what is the cloud made up of, it is made up of Nitro. As I mentioned earlier, all EC2 instance types that we've released since 2018 are powered by the Nitro System.

### Security Features and Transparency Commitments of the Nitro System

We feature in our system a secure boot process that is based on a hardware root of trust, ensuring that we have high visibility and confidence in the specific code that runs on every single component in every single one of our servers, in every one of our regions, all over the world, all at once. We're able to live update all of the critical elements of the system so that we're able to keep our systems patched and updated without impacting customer performance. We're also able to provide things like transparent encryption of storage, networking, and memory for our customers' instances.

[![Thumbnail 380](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/380.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=380)

The most revolutionary security feature of the Nitro System is that it was built from day one  to provide absolutely no mechanism for an AWS operator to access a customer's EC2 instance memory, their encrypted storage volumes, or any of the encrypted traffic that comes in and out of their instance. This was a dramatic shift in how you run a cloud virtualization system at the scale that we do. There is no SSHing into an underlying EC2 virtualization server based on Nitro. Any type of external interaction is conducted through pre-validated, safe APIs that are authorized, authenticated, logged, and monitored. Critically, each one of these APIs is pre-validated to ensure that it is not possible for that API to provide access to customer instance memory.

[![Thumbnail 470](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/470.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=470)

I've had the absolute pleasure of sitting face to face with hundreds of customers, partners, and regulators and seeing firsthand just how impactful this design decision has proven to be for our customers. In the last few years we've invested even further in providing transparency and assurance around this design so that our customers can proceed forth with the confidence in how we have built this system. One of our first steps was a deep dive white paper which goes into much, much greater depth than we're speaking about today, about the overall design of the system  and how the components fit together to ultimately deliver the outcomes that we're looking for.

We also engaged a third party security firm, the NCC Group, to provide a third party validation which affirms our security claims about the Nitro System. Lastly, we've made a contractual commitment in our service terms for each and every one of our AWS customers about this no operator access posture in the Nitro System. But we're not done yet. I want to turn our attention and focus in, zoom in on the Nitro Hypervisor specifically.

[![Thumbnail 510](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/510.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=510)

[![Thumbnail 530](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/530.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=530)

### The Minimized Nitro Hypervisor and Secret Hiding Architecture

 I mentioned this hypervisor is based on KVM. It's been deliberately minimized and customized for our use case. It is designed in such a way that it primarily executes only on behalf of a specific request of an instance, and then ultimately steps back, allowing us to deliver near bare metal performance in a virtualized system.  So what does minimalization mean? It's a bit hard to capture in one slide, but I like to think of really focusing on what some of the features that a hypervisor doesn't have that you might picture or assume a piece of software to have.

[![Thumbnail 570](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/570.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=570)

It doesn't have a networking stack. It doesn't have a general purpose file system implementation, peripheral driver support, certainly not an SSH server or even a shell. Really, when you look at the Nitro Hypervisor, it functions far more like firmware than it does like software. The hypervisor's primary functions amount to receiving management  instructions from the Nitro controller card, which orchestrates the overall system, partitioning up memory and CPU resources to follow through on those requests to do things like to start or to stop an instance, assigning PCIe devices, things like connections to our Nitro cards or accelerators, and then ultimately stepping back out of the way.

[![Thumbnail 600](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/600.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=600)

So with our Nitro System and our Nitro Hypervisor, one of its primary responsibilities is assuring  the isolation between co-tenants that share a physical piece of hardware. This is one of our core responsibilities at AWS.

[![Thumbnail 610](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/610.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=610)

[![Thumbnail 620](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/620.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=620)

 The Nitro Hypervisor is ultimately responsible for providing that isolation through careful scheduling and separation.  Recently, we've also published a blog post that goes into some depth about a particular choice we made in how we implemented the Nitro Hypervisor. This is called secret hiding. We won't speak about this in depth today, but I have provided a link to the blog post if you're interested to learn more.

At a high level, what this blog post discusses is the difference between a traditional hypervisor, which has a hierarchical memory model where each level of privilege is granted access to all lower memory. That means that something like the hypervisor has access to all of the memory of all of the VMs that run underneath it. With the Nitro System, we take a different approach. We make sure that the Nitro Hypervisor isn't able to access guest data because it's not present in the hypervisor's virtual address space. The Nitro Hypervisor retains access only to its own data, but the guest data remains isolated and inaccessible.

[![Thumbnail 700](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/700.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=700)

At a high level, what that means is that the Nitro Hypervisor isn't just responsible for providing isolation between customers' EC2 instances, but also for providing isolation between the Nitro Hypervisor itself and the EC2 instances that run beneath it. So that brings us to today and the release and announcement of the AWS Nitro Isolation Engine. This is an enhancement to the Nitro System  that harnesses formal verification to provide mathematical certainty that customer workloads are isolated from each other and AWS operators. We'll spend the rest of this morning discussing what that means and how that's implemented.

[![Thumbnail 720](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/720.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=720)

[![Thumbnail 740](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/740.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=740)

[![Thumbnail 760](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/760.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=760)

### Announcing the Nitro Isolation Engine: Compartmentalization, Formal Verification, and Transparency

 The Nitro Isolation Engine compartmentalizes all of the features of the Nitro Hypervisor that are relevant to isolation and confidentiality of customer EC2 instances. It breaks it off into a whole separate code base.  Then it takes that new code base and raises it up or lowers it down, depending upon how you think about it. It demotes the role of the Nitro Hypervisor and steps into a supervisory role, being responsible for controlling all confidentiality in the system. The Nitro Isolation Engine is therefore  responsible for all of the isolation, both between customer instances and between customer instances and the Nitro Hypervisor.

[![Thumbnail 770](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/770.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=770)

 The three key things about the Nitro Isolation Engine to understand are that it provides compartmentalization, meaning that by looking at the code base of the Nitro Isolation Engine, one can reason about and understand the confidentiality of the overall entire system. Second is that it's been formally verified. This means that we brought automated reasoning and engineering together on day one to make automated reasoning a first-class consideration throughout the entire design and implementation process of the Nitro Isolation Engine, providing us strong mathematical assurance of customer workload isolation.

Lastly is transparency. AWS will enable access to the Nitro Isolation Engine for customers so that they can evaluate the implementation and the associated formal verification proofs themselves. This means that the confidential computing protection of the AWS Nitro System has been repositioned and redeveloped to offer the highest level of assurance, making it the world's first formally verified hypervisor for cloud computing. With that, I'd like to invite out my colleague Karimallah Raslan to speak a bit about the engineering process for the Nitro Isolation Engine. Thank you very much.

[![Thumbnail 870](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/870.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=870)

[![Thumbnail 880](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/880.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=880)

### Engineering the Nitro Isolation Engine: Foundational Concepts and Architectural Design

Hello everyone. Thank you to J.D. What a journey. My name is Karimallah Raslan. I'm part of the Nitro Hypervisor team. I have been  part of this journey for the past 10 years. I'm a Senior Principal in EC2. Before diving into the Nitro Isolation Engine and taking you one step lower,  I would like to introduce you to three foundational concepts that will set the stage for everything I will say afterwards. It will also show you how we are thinking about hypervisors, how we designed it, and how the Nitro Isolation Engine is a natural step in our design of hypervisors.

[![Thumbnail 900](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/900.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=900)

 The first concept is memory isolation.

One of the critical jobs of a hypervisor is to partition physical memory and assign it safely to customers. Hypervisors do this by using a concept called virtual memory. This is a hardware abstracted concept that comes from a hardware unit called the CPU MMU. This CPU MMU works with the hypervisor to provide mapping from what we call the guest physical address space to the actual host physical address space that underpins the virtual machines.

[![Thumbnail 940](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/940.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=940)

The second critical concept is exception levels. This is another hardware abstraction that comes directly from the CPU,  and at each different exception level, you have access to different permissions and different features of the CPU. This is why you see, for example, the Nitro Hypervisor positioned at EL2 or exception level 2. The reason for this is because it needs features that only exist in exception level 2 that help it manage all the virtual machines running below it.

[![Thumbnail 970](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/970.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=970)

Once we introduce these exception levels, you need a way between exception  levels to communicate. This is done through very well-defined entry points that are sometimes called system calls or hypercalls. These entry points allow lower privilege software to communicate and ask for requests from the higher privilege software. For this example, you can see an operating system kernel running, maybe a Linux kernel, and you see user-based applications requesting services from this kernel. They do this by using system calls, which are well-defined entry points between these exception levels.

[![Thumbnail 1010](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/1010.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=1010)

The third foundational concept is the principle of least privilege. What this means in reality  is that whenever you are designing any software, you need to look at the environment you are executing in and audit all the resources and permissions that you are giving to this environment. For example, are you running as root or not? Do you have access to the full system call interface from the Linux kernel or not? While you are auditing all of these resources, you need to only allow the resources that are critical for this specific application to function. Any other resources should be completely blocked, and any other permissions should be completely blocked.

The way to think about it is that the resources and permissions in your environment are supposed to be an allow list. Everything by default is blocked, and you only allow the minimum permissions that are needed so that you can function properly. This is a principle that you can use for all systems, but it's super critical to use for systems that host possibly untrusted code or receive external traffic.

[![Thumbnail 1070](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/1070.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=1070)

[![Thumbnail 1080](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/1080.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=1080)

Just a quick recap. We talked about address spaces and how they are used to  partition memory and isolate it. We spoke about exception levels and how they work together, and we spoke about the principle of least privilege. So now let's talk about isolation. What are  we actually isolating? We keep repeating isolating something about customers. When we talk about isolation, what we mean is that we are isolating customer data, which lives in three resources on your host. They live as CPU state, which is CPU registers, they live in your host memory, or they live in host devices. When we talk about isolation in this session, we are talking about isolating data in one of these three resources.

[![Thumbnail 1110](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/1110.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=1110)

For example, if we look at the Nitro Hypervisor  today, this is a sample of the tasks that the Nitro Hypervisor does. Even though the Nitro Hypervisor is super minimal because we minimized it explicitly, because we wanted to have a very small footprint that only does the bare minimum needed to virtualize the machine, building a virtual machine for a customer is not an easy task. It's still complex and requires lots of small tasks here and there. You can look at this list and see there are lots of tasks here that are not just for isolating memory but are for the proper functionality of a hypervisor.

[![Thumbnail 1150](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/1150.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=1150)

Let's filter only on the tasks that are there to isolate memory and to isolate customer data. You would see that it is just a subset  of the overall tasks. As an example, the first two tasks are about isolating memory from CPU access and device access. If we look at this picture, what would this mean for us? It would mean that if the Nitro Hypervisor looks like this, all of this functionality lives in exception level 2.

[![Thumbnail 1170](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/1170.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=1170)

[![Thumbnail 1180](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/1180.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=1180)

We want to enhance the hypervisor.  The first thing that comes to mind is to immediately split all the functionality that lives in the Nitro Hypervisor that is related to isolation primitives  and move all of this functionality into its own component that is just focused on one thing and one thing only, which is isolating customer data. Now, let's apply one of the principles we learned, which is the principle of least privilege. If we look at the Nitro Hypervisor, does the Nitro Hypervisor need to be at exception level 2? There have to be some features of exception level 2 and some extra privileges, and this is why it was there originally.

[![Thumbnail 1210](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/1210.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=1210)

None of these privileges are actually needed to function if you're not isolating customer data. And this is why the second step  is to actually demote the hypervisor and lower access to all the privileges that are there in Exception Level 2. What's interesting is that if we apply the same thinking about the Nitro Isolation Engine, once you think about it, then you realize you actually need the Nitro Isolation Engine to be at this exception level because this is where it can isolate memory. As an example, this is where it can create address spaces for virtual machines. This is where it can context switch between one customer to another customer, protecting customer data and registers and so on.

[![Thumbnail 1260](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/1260.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=1260)

And this is why we need the Nitro Isolation Engine to live at the bottom of the whole stack and to protect everything on top of it, and we can basically now demote the Nitro Hypervisor to be running at a lower exception level. Once we do this, then we need to talk about how they communicate, because after all, the Nitro Isolation Engine is just isolating and making sure that  customer data is fully isolated across all the three devices that we spoke about. We do this through basically these hypercalls between the Nitro Hypervisor and the Nitro Isolation Engine. So what happens here is that Nitro Hypervisor will receive requests to create a virtual machine, and that will convey this intent to the Nitro Isolation Engine and say something like, hey, can you please map this physical page to this virtual machine or this customer instance. And now it is the job of the Nitro Isolation Engine to make sure that while I'm applying this intent, I don't actually break any of the isolation boundaries. And this is why all the customer data protection and isolation goes from the Nitro Hypervisor directly to the Nitro Isolation Engine.

[![Thumbnail 1310](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/1310.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=1310)

### Building from First Principles: Rust Implementation and Integrated Formal Proofs

But we didn't stop there. We thought, okay, if we're actually going to add a new layer  at the bottom of our virtualization stack, this is now a foundational layer. This is not an incremental improvement. It's significantly a change in the architecture of Nitro Hypervisor. And similar to what JD said, this is actually one of the biggest changes we have done in the past 10 years on the Nitro Hypervisor. What if we actually thought from first principles? Let's start building it from scratch and think from first principles how we want to build and design system software that's foundational in building something like isolation for customers. And that's why it was built in Rust programming language instead of C, because we wanted all of the memory safety properties that Rust brings there.

[![Thumbnail 1360](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/1360.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=1360)

[![Thumbnail 1390](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/1390.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=1390)

But once you basically go that far and think, okay, I want to build it from scratch, I want to build it with Rust, I need to rearchitect the hypervisor, why stop there? What if we actually completely changed the  way we develop system software and introduced proofs into it? What if our promises to customers are not just promises, but rather they are proofs? What if the correctness of the hypervisor and its ability to actually isolate customer data is not just code that is implemented, but also proofs that show that this code is truly isolating data and there are no mistakes and there's no corner cases that are not covered? And this is why when we started this Nitro Isolation Engine from day one, we decided to basically work with our automated reasoning scientists  and we wanted to build something from day one that's formally proven end to end that actually proves all the properties of isolation. So this was not like we built it and then we decided now let's engage formal teams. No, we actually started from day one when we were designing it, working with a formal team trying to figure out how we design something that can be proven.

[![Thumbnail 1440](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/1440.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=1440)

So if you look at typical software development process, it always starts with you start designing something. If you are obviously test driven development, you start writing your unit tests and then you build from that the implementation, you do your code reviews, and then you start after you finish a component or a system, you start fuzzing and penetration testing. We actually wanted to change this process and add to it formal proofs. We completely integrated formal proofs in every step of the way of the whole development process.  So while we are designing the system, we were thinking, okay, what are we actually trying to achieve with this design? Let's create a formal mathematical specification that describes precisely and accurately what we want to achieve. And we did this as part of the implementation as well.

So while we are implementing, we always think, okay, let's figure out a way to prove that this implementation is truly doing what we have in our specification, because it's very hard to prove that your code is doing what you wanted to do unless you have lots of testing, and now we have an extra tool which is actually the formal proof. So the way to think about formal proof, it's not a replacement of your typical software development process and your quality bar. It is just an extra tool that you have to significantly raise the bar of your correctness of basically your implementation. And with this, I would like to hand over to Nathan, who's going to jump deeper into automated reasoning and formal proofs.

### Automated Reasoning Explained: Specifications, Transition Relations, and Formal Mathematics

Thank you, Kareem. Hi, I'm Nathan Chong. I'm Principal Applied Scientist at Amazon.

[![Thumbnail 1520](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/1520.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=1520)

[![Thumbnail 1530](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/1530.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=1530)

In this part of the talk, I'd like to give you a more tangible understanding of automated reasoning, what it is, how we've used it, and the deep and durable value it provides. So, what is automated reasoning? Simply put, it's the application  of mathematical logic for reasoning about systems so that we can precisely capture the envelope of a system's behavior. That is what a system  can do, must do, and importantly, must never do when we consider all possible inputs in all reachable states. For a system like the Nitro Isolation Engine, this means under any event that the Nitro Hypervisor or a guest VM might trigger when the system is in any reachable state.

[![Thumbnail 1600](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/1600.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=1600)

This is challenging. Let me show you with a small system, a program that implements this Rust function prototype, taking three U64 unsigned 64-bit values, X, Y, and Z, and returns a result type, either a U64 or an error. Let's say we wanted to show a behavior that the system should never have, for example, never returning an error for any possible input. If we wanted to show that property through exhaustive testing, we'd need 2 to the 192nd power test cases, one for every possible assignment  of X, Y, and Z.

This is a massive number. To give you a sense of the scale, imagine I gave you a processor capable of executing a billion test cases a second, and you had a billion such processors, so a billion billion test cases per second. Even with that rate of compute, we'd still need longer than the age of the universe to finish executing this many test cases. So what we need is a technique that's complementary to testing if we're looking to establish properties that hold universally, that is, for all possible inputs in all reachable states. And that is the role of automated reasoning.

There are four properties that are key to what we've proven in the Nitro Isolation Engine. Let's picture them as a mountain that we want to climb. The good news is that where we start from, our base camp, is in a great place. As Kareem mentioned, we designed and implemented the Nitro Isolation Engine from scratch in the Rust programming language, which is a great choice for new systems code because of the language's emphasis on safety, and in particular, memory safety. This is important because memory safety errors are very often the root cause of security issues.

[![Thumbnail 1730](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/1730.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=1730)

But we can climb further, because the memory safety guarantees of Rust only apply to the safe subset. Like other systems code, we need to use unsafe code to implement low-level features, such as custom memory allocators. So we begin by proving the memory safety of both safe and unsafe Rust code. But we can climb further, because memory-safe Rust programs can still have runtime errors, for example, if you try to unwrap a None option value. So we prove additionally the unreachability of such conditions, which is to say,  the absence of runtime errors, which is important for the reliability of the system.

[![Thumbnail 1750](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/1750.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=1750)

[![Thumbnail 1780](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/1780.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=1780)

But we can climb further, because memory-safe Rust programs that don't have runtime errors might still compute the wrong result.  So we proved functional correctness, that the system does exactly what we expect and nothing else. Now we're almost at the top. There's one more push, which is that even if you compute the right result every time, you still need to be very careful about information flow. For example, a hypervisor must always properly scrub guest memory. So we proved that only authorized information flows can occur, which is to say, we proved the confidentiality  and integrity of guest VM data at all times.

Now we're at the top, and it's a pretty good view. We're at a height that not many reach. These are all properties that hypervisors must have, but very few provide mathematical assurance of. One of the major reasons is that it's very hard to retrofit this kind of verification.

[![Thumbnail 1820](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/1820.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=1820)

It really needs to be baked in from the very beginning as a first-class consideration. Today, our proofs cover the core implementation of the Nitro Isolation Engine that is responsible for creating, running, and destroying guest virtual machines.  This is the VM lifecycle that you see here. We started with this foundation because it represents the majority of the normal runtime of the system in practice. But of course, we're not stopping here. Our commitment is to keep pushing the frontier of the proof until we cover all aspects of the implementation. So these proofs are a foundation that will only strengthen as time goes on.

[![Thumbnail 1860](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/1860.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=1860)

I'd like to go deeper now and tell you about two key requirements of automated reasoning  that are important factors in its value. Let's start with something familiar: the implementation. This is the code that's deployed and executed in production. The first requirement of automated reasoning is that we define a formal specification that precisely captures the envelope of the system's behavior. And the second requirement is that we rigorously connect the implementation and the specification in the form of a machine-checked mathematical proof. Specification and proof. These are two unusual requirements, and I'd like to unpack each of those for you.

[![Thumbnail 1920](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/1920.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=1920)

But before I do, I think it's worth putting this kind of work in context by talking about limitations that are inherent in any application of automated reasoning to a computing system. These are gaps both conceptually above and below.  Above, in the sense that we can't prove the specification is correct, we have to carefully audit it. And below, in the sense that the implementation that we prove properties over is always some abstraction of the deployed artifact, which ultimately is a physical process in the real world. Electrons moving in transistors, and therefore subject to physical effects that are outside the realm of automated reasoning. Automated reasoning is a powerful technique, and it's important these gaps are acknowledged so that we can deal with them in other ways. And we do. But for now, let's get back to talking about specifications and proofs.

[![Thumbnail 1970](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/1970.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=1970)

[![Thumbnail 2000](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/2000.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=2000)

A specification for a system is  like a blueprint for a building. It's an abstraction. A good specification captures what behaviors a system should have without prescribing how the system should implement it. And one of the major advantages of thinking and writing down a specification early, before writing any code, is that it's hard. And it requires you to truly understand what you're building. Here's  a great quote from the cartoonist Richard Guindon that you might relate to. And let me follow up with an example from the Nitro Isolation Engine.

[![Thumbnail 2080](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/2080.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=2080)

This is the map hypercall from the Isolation Engine's API. The Nitro Hypervisor calls this hypercall to transfer ownership of physical pages. As Karimallah spoke about, this is necessary because only the Isolation Engine has direct control of the page tables that govern guest physical address space. We have the host physical address space in the middle, and all of the blue pages are mapped into the Nitro Hypervisor's guest physical address space, which is on the left. The hypervisor takes a VMID that identifies a target VM, a host address that specifies a page in the Nitro Hypervisor's guest physical address space, and a guest address that specifies a page or address in the VM's guest physical address space. And the result of the map hypercall is that the page moves from the Nitro Hypervisor to the target VM. 

[![Thumbnail 2100](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/2100.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=2100)

So, I'll map a page from the source, map it into the destination. Why is that difficult to specify? Well, if you start to think and write down the specification for this hypercall, you'll quickly realize there are a number of edge cases. Here are just some of them. Issues with page alignment, the size  of address spaces, the state of pages, and many more. Writing down a specification forces you to think about these issues early.

So I hope you can see that for certain kinds of systems, particularly ones like the Nitro Isolation Engine, the act of writing down a specification is in itself a very valuable process.

[![Thumbnail 2130](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/2130.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=2130)

But we can go further. This is a quote from the computer scientist Leslie Lamport that takes the previous  quote to the next level. Essentially, Lamport is saying that for certain kinds of tasks, like writing specifications, mathematics is an even sharper tool than writing. And he's right. For example, let's use a mathematical idea called a transition relation to really sharpen what we mean.

[![Thumbnail 2160](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/2160.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=2160)

[![Thumbnail 2190](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/2190.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=2190)

To illustrate this idea, here's a new bit of Rust code. It defines a struct State  with two U64 components, X and Y, with an initializer and two methods, tick_x and tick_y, that increment their respective fields. Let's call new to get a fresh state, this pair (0,0), representing the initial values of X and Y. And then call tick_y, which moves us to a new state (0,2), because of the increment in this method.  Another way of looking at this is that the state (0,0) is related to the state (0,2) as a result of the event tick_y.

And if we think more symbolically, we could write it like this: a relation between the symbolic state (x,y) and a new symbolic state where the X component stays the same and the Y component is incremented. This is a transition relation. And a question for you later will be, what's the transition relation for tick_x?

[![Thumbnail 2230](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/2230.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=2230)

[![Thumbnail 2240](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/2240.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=2240)

[![Thumbnail 2250](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/2250.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=2250)

Stepping back from this particular example,  the power of the idea of a transition relation is that it allows us to capture the behavior of an event symbolically  from a symbolic state S to a new symbolic state S prime. Let's apply this to the map hypercall and capture  the specification that it behaves transactionally. What we mean by that is that on every error case, we demand that there is no state change. S prime is equal to S. And only on success do we do the page transfer. S prime is the state obtained from S by doing that operation.

[![Thumbnail 2290](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/2290.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=2290)

Notice that now we're saying a lot more about how the system should change, or indeed not change, as a result of the hypercall. But we can go further. There's this second part to Lamport's quote that says this. It says an even higher bar  for certain types of tasks, such as writing specifications, than mathematics is formal mathematics, which means saying what you mean in precise mathematical logic.

[![Thumbnail 2320](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/2320.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=2320)

So for completeness and fun, I'm going to show you a real example in the next slide. There's going to be a lot of detail, and I'm not expecting you to read it all. This is the transition relation for the success case of the map hypercall.  And I think it's worth showing you this, even though I'm not going to step through all the details, to give you a more tangible understanding of what it looks like to take the idea of a transition relation into a full accounting that is rigorous and formal in mathematical logic. This is what we mean when we say that an event or hypercall is specified in the Isolation Engine.

[![Thumbnail 2350](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/2350.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=2350)

[![Thumbnail 2370](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/2370.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=2370)

### Machine-Checked Mathematical Proofs and Conclusion: Preview Availability on Graviton 5

So that's part one: specifications.  Let's move now to the second unusual requirement of automated reasoning, proof, which is how we connect an implementation to its formal specification. And in the context of the Isolation Engine, proof means machine-checked mathematical proof  in the Isabelle proof assistant. Isabelle is an interactive theorem prover that's been used in some of the world's largest and most important automated reasoning projects. It's a tool for writing and checking mathematical proofs.

Now proof is an overloaded word. For example, it's commonly used as any kind of evidence towards some fact. But we have a stricter, tighter definition.

[![Thumbnail 2410](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/2410.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=2410)

[![Thumbnail 2420](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/2420.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=2420)

[![Thumbnail 2430](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/2430.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=2430)

Let me explain by way of a story about the  great mathematician Carl Gauss. As the story goes, as a school child, he was asked by his teacher to sum the first 100 numbers  as a way of using up his time. But he immediately saw the answer because he saw that this summation could be rewritten as the sum of the pairs,  1 and 100, 2 and 99, 3 and 98, and so on, meaning there are 50 pairs that each sum to 101.

[![Thumbnail 2450](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/2450.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=2450)

[![Thumbnail 2470](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/2470.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=2470)

Now let's generalize this to a question about any natural number. Using our previous experience, we might guess the following.  But how do we know this is right for all natural numbers? It looks right, it feels right. I'm telling you it's right. None of those are proof. What if we did a bunch of testing? We might test the first billion numbers, a little bit like the exhaustive testing I showed you at the beginning.  Is that a proof? It isn't, because the set of natural numbers is infinite. We can't test our way to a proof.

[![Thumbnail 2480](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/2480.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=2480)

What we need  is a mathematical proof using the principle of mathematical induction, which is two parts: a base case and a step case. A good analogy for induction is to think of a line of dominoes. We want to knock all the dominoes down, which is to say we want to prove the property for all natural numbers. The base case shows that the first domino will fall, and the step case says that if you have two adjacent dominoes, if the first falls, then the second will too. Combined, this is a finite argument that shows that all dominoes will fall.

[![Thumbnail 2530](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/2530.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=2530)

If you didn't get all of that, don't worry. But for completeness and for fun, I'm going to lay out all the details for you. You don't need to read all of this. This is a full proof. But I do want you to notice two things.  One is it's finite, fits on a single page. And second, every step of this proof can be checked for its validity, and indeed, every step must be valid. This is a mathematical proof: a finite chain of reasoning that establishes the property once and for all, where every link in the chain or step is a logically sound deduction.

[![Thumbnail 2570](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/2570.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=2570)

But we can push this further using the Isabelle Proof Assistant. This is the same proof, but now in Isabelle. The proof of the previous slide was rigorous,  but informal, because it relied on you as the reader to check the validity of each step. In this proof in Isabelle, we can rely on Isabelle to do that checking for us. That's why we call this a machine-checked mathematical proof. And all the proofs we have for the Nitro Isolation Engine are machine-checked mathematical proofs. And although finding a proof might be difficult, checking a proof when it's in this form is straightforward. Isabelle won't let us take any invalid steps in our chain of reasoning.

[![Thumbnail 2620](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/2620.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=2620)

[![Thumbnail 2640](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/2640.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=2640)

So this is what it's like to prove a simple property over the natural numbers. You might ask me, what does it take, what kind of math do you need  to scale this up to proving a rigorous connection between the implementation and specification of the Nitro Isolation Engine, which is a more complicated artifact? The short answer is it's a lot more work, built on decades of work in this area. I've listed  the core ideas we've needed, and each would be a full talk in itself to cover properly. So we'll set these aside for now.

[![Thumbnail 2660](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/2660.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=2660)

[![Thumbnail 2690](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/2690.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=2690)

So that's part two: proof. Now that we've seen both specification and proof, let's pop to the top.  If you look back, you'll notice I've told you the same story twice. It's one of an increasingly high bar. I gave you the intuition or the idea of a proof or a specification, showed you how mathematics makes that idea sharper, and finally, gave you glimpses of what that looks like in formal mathematics to show you the proof bar that we use in the Nitro Isolation Engine. So that now you know  what we mean when we say that a property is proven of the Nitro Isolation Engine. And as a result, I hope you now have a more tangible understanding of automated reasoning and the deep and durable value that it offers.

[![Thumbnail 2730](https://raw.githubusercontent.com/kazuya-iwami/devto-repo/main/posts/images/0f3c6f36d9b3def9/2730.jpg)](https://www.youtube.com/watch?v=b0P55gHhG4g&t=2730)

Let's wrap up. In this session, JD told you the story of the AWS Nitro System and our continual commitment to raising the bar. Kareem and I gave you details about an exciting new chapter, the Nitro Isolation Engine: a new, minimal, formally verified enhancement to the Nitro System  that compartmentalizes only what is strictly necessary for the task of isolation. We are in preview today as an always-on default capability of Graviton 5, and you can request access to the preview with this link.

I'd like to finish with two thank yous. Firstly, yourselves, for your time and attention. It's a privilege to share this work with you. And secondly, special thanks to the many engineers and scientists not on this stage that have worked tirelessly for several years to make the Nitro Isolation Engine a reality. Thank you, and please do give us feedback in the app.


----

; This article is entirely auto-generated using Amazon Bedrock.
